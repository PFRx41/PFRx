"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/airdrop";
exports.ids = ["pages/api/airdrop"];
exports.modules = {

/***/ "@solana/web3.js":
/*!**********************************!*\
  !*** external "@solana/web3.js" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("@solana/web3.js");

/***/ }),

/***/ "axios?6fac":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

module.exports = require("axios");

/***/ }),

/***/ "bs58":
/*!***********************!*\
  !*** external "bs58" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("bs58");

/***/ }),

/***/ "exceljs":
/*!**************************!*\
  !*** external "exceljs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("exceljs");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fairdrop&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cairdrop.js&middlewareConfigBase64=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fairdrop&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cairdrop.js&middlewareConfigBase64=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_airdrop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\airdrop.js */ \"(api)/./pages/api/airdrop.js\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_airdrop_js__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_airdrop_js__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/airdrop\",\n        pathname: \"/api/airdrop\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_airdrop_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmFpcmRyb3AmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyU1Q2FwaSU1Q2FpcmRyb3AuanMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDcUQ7QUFDckQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLGtEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxrREFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haXJkcm9wLWRhc2hib2FyZC8/OTI5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXNcXFxcYXBpXFxcXGFpcmRyb3AuanNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9haXJkcm9wXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvYWlyZHJvcFwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fairdrop&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cairdrop.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/excel.js":
/*!**********************!*\
  !*** ./lib/excel.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst ExcelJS = __webpack_require__(/*! exceljs */ \"exceljs\");\nconst fs = (__webpack_require__(/*! fs */ \"fs\").promises);\nasync function appendToExcel(date, claimed, airdropped) {\n    const workbook = new ExcelJS.Workbook();\n    const filePath = \"/tmp/dashboard_data.xlsx\";\n    try {\n        if (await fs.access(filePath).then(()=>true).catch(()=>false)) {\n            await workbook.xlsx.readFile(filePath);\n        }\n        let sheet = workbook.getWorksheet(\"Data\");\n        if (!sheet) {\n            sheet = workbook.addWorksheet(\"Data\");\n            sheet.addRow([\n                \"Date\",\n                \"Fees Claimed (SOL)\",\n                \"Airdrops Sent (SOL)\"\n            ]);\n        }\n        sheet.addRow([\n            date.toISOString(),\n            claimed,\n            airdropped\n        ]);\n        await workbook.xlsx.writeFile(filePath);\n    } catch (error) {\n        throw new Error(`Error writing to Excel: ${error.message}`);\n    }\n}\nasync function readExcelData() {\n    const filePath = \"/tmp/dashboard_data.xlsx\";\n    try {\n        if (!await fs.access(filePath).then(()=>true).catch(()=>false)) {\n            return {\n                data: [],\n                totalClaimed: 0,\n                totalAirdropped: 0,\n                lastUpdated: null\n            };\n        }\n        const workbook = new ExcelJS.Workbook();\n        await workbook.xlsx.readFile(filePath);\n        const sheet = workbook.getWorksheet(\"Data\");\n        if (!sheet) {\n            return {\n                data: [],\n                totalClaimed: 0,\n                totalAirdropped: 0,\n                lastUpdated: null\n            };\n        }\n        const data = [];\n        let totalClaimed = 0;\n        let totalAirdropped = 0;\n        let lastUpdated = null;\n        sheet.eachRow((row, rowNumber)=>{\n            if (rowNumber === 1) return; // Skip header\n            const rowData = {\n                Date: row.getCell(1).value,\n                \"Fees Claimed (SOL)\": row.getCell(2).value || 0,\n                \"Airdrops Sent (SOL)\": row.getCell(3).value || 0\n            };\n            totalClaimed += rowData[\"Fees Claimed (SOL)\"];\n            totalAirdropped += rowData[\"Airdrops Sent (SOL)\"];\n            if (!lastUpdated || new Date(rowData.Date) > new Date(lastUpdated)) {\n                lastUpdated = rowData.Date;\n            }\n            data.push(rowData);\n        });\n        return {\n            data,\n            totalClaimed,\n            totalAirdropped,\n            lastUpdated\n        };\n    } catch (error) {\n        throw new Error(`Error reading dashboard data: ${error.message}`);\n    }\n}\nmodule.exports = {\n    appendToExcel,\n    readExcelData\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvZXhjZWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDLHdCQUFTO0FBQ2pDLE1BQU1DLEtBQUtELDhDQUFzQjtBQUVqQyxlQUFlRyxjQUFjQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsVUFBVTtJQUNwRCxNQUFNQyxXQUFXLElBQUlSLFFBQVFTLFFBQVE7SUFDckMsTUFBTUMsV0FBVztJQUNqQixJQUFJO1FBQ0YsSUFBSSxNQUFNUixHQUFHUyxNQUFNLENBQUNELFVBQVVFLElBQUksQ0FBQyxJQUFNLE1BQU1DLEtBQUssQ0FBQyxJQUFNLFFBQVE7WUFDakUsTUFBTUwsU0FBU00sSUFBSSxDQUFDQyxRQUFRLENBQUNMO1FBQy9CO1FBQ0EsSUFBSU0sUUFBUVIsU0FBU1MsWUFBWSxDQUFDO1FBQ2xDLElBQUksQ0FBQ0QsT0FBTztZQUNWQSxRQUFRUixTQUFTVSxZQUFZLENBQUM7WUFDOUJGLE1BQU1HLE1BQU0sQ0FBQztnQkFBQztnQkFBUTtnQkFBc0I7YUFBc0I7UUFDcEU7UUFDQUgsTUFBTUcsTUFBTSxDQUFDO1lBQUNkLEtBQUtlLFdBQVc7WUFBSWQ7WUFBU0M7U0FBVztRQUN0RCxNQUFNQyxTQUFTTSxJQUFJLENBQUNPLFNBQVMsQ0FBQ1g7SUFDaEMsRUFBRSxPQUFPWSxPQUFPO1FBQ2QsTUFBTSxJQUFJQyxNQUFNLENBQUMsd0JBQXdCLEVBQUVELE1BQU1FLE9BQU8sQ0FBQyxDQUFDO0lBQzVEO0FBQ0Y7QUFFQSxlQUFlQztJQUNiLE1BQU1mLFdBQVc7SUFDakIsSUFBSTtRQUNGLElBQUksQ0FBRSxNQUFNUixHQUFHUyxNQUFNLENBQUNELFVBQVVFLElBQUksQ0FBQyxJQUFNLE1BQU1DLEtBQUssQ0FBQyxJQUFNLFFBQVM7WUFDcEUsT0FBTztnQkFBRWEsTUFBTSxFQUFFO2dCQUFFQyxjQUFjO2dCQUFHQyxpQkFBaUI7Z0JBQUdDLGFBQWE7WUFBSztRQUM1RTtRQUNBLE1BQU1yQixXQUFXLElBQUlSLFFBQVFTLFFBQVE7UUFDckMsTUFBTUQsU0FBU00sSUFBSSxDQUFDQyxRQUFRLENBQUNMO1FBQzdCLE1BQU1NLFFBQVFSLFNBQVNTLFlBQVksQ0FBQztRQUNwQyxJQUFJLENBQUNELE9BQU87WUFDVixPQUFPO2dCQUFFVSxNQUFNLEVBQUU7Z0JBQUVDLGNBQWM7Z0JBQUdDLGlCQUFpQjtnQkFBR0MsYUFBYTtZQUFLO1FBQzVFO1FBQ0EsTUFBTUgsT0FBTyxFQUFFO1FBQ2YsSUFBSUMsZUFBZTtRQUNuQixJQUFJQyxrQkFBa0I7UUFDdEIsSUFBSUMsY0FBYztRQUNsQmIsTUFBTWMsT0FBTyxDQUFDLENBQUNDLEtBQUtDO1lBQ2xCLElBQUlBLGNBQWMsR0FBRyxRQUFRLGNBQWM7WUFDM0MsTUFBTUMsVUFBVTtnQkFDZEMsTUFBTUgsSUFBSUksT0FBTyxDQUFDLEdBQUdDLEtBQUs7Z0JBQzFCLHNCQUFzQkwsSUFBSUksT0FBTyxDQUFDLEdBQUdDLEtBQUssSUFBSTtnQkFDOUMsdUJBQXVCTCxJQUFJSSxPQUFPLENBQUMsR0FBR0MsS0FBSyxJQUFJO1lBQ2pEO1lBQ0FULGdCQUFnQk0sT0FBTyxDQUFDLHFCQUFxQjtZQUM3Q0wsbUJBQW1CSyxPQUFPLENBQUMsc0JBQXNCO1lBQ2pELElBQUksQ0FBQ0osZUFBZSxJQUFJSyxLQUFLRCxRQUFRQyxJQUFJLElBQUksSUFBSUEsS0FBS0wsY0FBYztnQkFDbEVBLGNBQWNJLFFBQVFDLElBQUk7WUFDNUI7WUFDQVIsS0FBS1csSUFBSSxDQUFDSjtRQUNaO1FBQ0EsT0FBTztZQUFFUDtZQUFNQztZQUFjQztZQUFpQkM7UUFBWTtJQUM1RCxFQUFFLE9BQU9QLE9BQU87UUFDZCxNQUFNLElBQUlDLE1BQU0sQ0FBQyw4QkFBOEIsRUFBRUQsTUFBTUUsT0FBTyxDQUFDLENBQUM7SUFDbEU7QUFDRjtBQUVBYyxPQUFPQyxPQUFPLEdBQUc7SUFDZm5DO0lBQ0FxQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlyZHJvcC1kYXNoYm9hcmQvLi9saWIvZXhjZWwuanM/MDZkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFeGNlbEpTID0gcmVxdWlyZShcImV4Y2VsanNcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpLnByb21pc2VzO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gYXBwZW5kVG9FeGNlbChkYXRlLCBjbGFpbWVkLCBhaXJkcm9wcGVkKSB7XHJcbiAgY29uc3Qgd29ya2Jvb2sgPSBuZXcgRXhjZWxKUy5Xb3JrYm9vaygpO1xyXG4gIGNvbnN0IGZpbGVQYXRoID0gXCIvdG1wL2Rhc2hib2FyZF9kYXRhLnhsc3hcIjtcclxuICB0cnkge1xyXG4gICAgaWYgKGF3YWl0IGZzLmFjY2VzcyhmaWxlUGF0aCkudGhlbigoKSA9PiB0cnVlKS5jYXRjaCgoKSA9PiBmYWxzZSkpIHtcclxuICAgICAgYXdhaXQgd29ya2Jvb2sueGxzeC5yZWFkRmlsZShmaWxlUGF0aCk7XHJcbiAgICB9XHJcbiAgICBsZXQgc2hlZXQgPSB3b3JrYm9vay5nZXRXb3Jrc2hlZXQoXCJEYXRhXCIpO1xyXG4gICAgaWYgKCFzaGVldCkge1xyXG4gICAgICBzaGVldCA9IHdvcmtib29rLmFkZFdvcmtzaGVldChcIkRhdGFcIik7XHJcbiAgICAgIHNoZWV0LmFkZFJvdyhbXCJEYXRlXCIsIFwiRmVlcyBDbGFpbWVkIChTT0wpXCIsIFwiQWlyZHJvcHMgU2VudCAoU09MKVwiXSk7XHJcbiAgICB9XHJcbiAgICBzaGVldC5hZGRSb3coW2RhdGUudG9JU09TdHJpbmcoKSwgY2xhaW1lZCwgYWlyZHJvcHBlZF0pO1xyXG4gICAgYXdhaXQgd29ya2Jvb2sueGxzeC53cml0ZUZpbGUoZmlsZVBhdGgpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdyaXRpbmcgdG8gRXhjZWw6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHJlYWRFeGNlbERhdGEoKSB7XHJcbiAgY29uc3QgZmlsZVBhdGggPSBcIi90bXAvZGFzaGJvYXJkX2RhdGEueGxzeFwiO1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoIShhd2FpdCBmcy5hY2Nlc3MoZmlsZVBhdGgpLnRoZW4oKCkgPT4gdHJ1ZSkuY2F0Y2goKCkgPT4gZmFsc2UpKSkge1xyXG4gICAgICByZXR1cm4geyBkYXRhOiBbXSwgdG90YWxDbGFpbWVkOiAwLCB0b3RhbEFpcmRyb3BwZWQ6IDAsIGxhc3RVcGRhdGVkOiBudWxsIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCB3b3JrYm9vayA9IG5ldyBFeGNlbEpTLldvcmtib29rKCk7XHJcbiAgICBhd2FpdCB3b3JrYm9vay54bHN4LnJlYWRGaWxlKGZpbGVQYXRoKTtcclxuICAgIGNvbnN0IHNoZWV0ID0gd29ya2Jvb2suZ2V0V29ya3NoZWV0KFwiRGF0YVwiKTtcclxuICAgIGlmICghc2hlZXQpIHtcclxuICAgICAgcmV0dXJuIHsgZGF0YTogW10sIHRvdGFsQ2xhaW1lZDogMCwgdG90YWxBaXJkcm9wcGVkOiAwLCBsYXN0VXBkYXRlZDogbnVsbCB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGF0YSA9IFtdO1xyXG4gICAgbGV0IHRvdGFsQ2xhaW1lZCA9IDA7XHJcbiAgICBsZXQgdG90YWxBaXJkcm9wcGVkID0gMDtcclxuICAgIGxldCBsYXN0VXBkYXRlZCA9IG51bGw7XHJcbiAgICBzaGVldC5lYWNoUm93KChyb3csIHJvd051bWJlcikgPT4ge1xyXG4gICAgICBpZiAocm93TnVtYmVyID09PSAxKSByZXR1cm47IC8vIFNraXAgaGVhZGVyXHJcbiAgICAgIGNvbnN0IHJvd0RhdGEgPSB7XHJcbiAgICAgICAgRGF0ZTogcm93LmdldENlbGwoMSkudmFsdWUsXHJcbiAgICAgICAgXCJGZWVzIENsYWltZWQgKFNPTClcIjogcm93LmdldENlbGwoMikudmFsdWUgfHwgMCxcclxuICAgICAgICBcIkFpcmRyb3BzIFNlbnQgKFNPTClcIjogcm93LmdldENlbGwoMykudmFsdWUgfHwgMCxcclxuICAgICAgfTtcclxuICAgICAgdG90YWxDbGFpbWVkICs9IHJvd0RhdGFbXCJGZWVzIENsYWltZWQgKFNPTClcIl07XHJcbiAgICAgIHRvdGFsQWlyZHJvcHBlZCArPSByb3dEYXRhW1wiQWlyZHJvcHMgU2VudCAoU09MKVwiXTtcclxuICAgICAgaWYgKCFsYXN0VXBkYXRlZCB8fCBuZXcgRGF0ZShyb3dEYXRhLkRhdGUpID4gbmV3IERhdGUobGFzdFVwZGF0ZWQpKSB7XHJcbiAgICAgICAgbGFzdFVwZGF0ZWQgPSByb3dEYXRhLkRhdGU7XHJcbiAgICAgIH1cclxuICAgICAgZGF0YS5wdXNoKHJvd0RhdGEpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4geyBkYXRhLCB0b3RhbENsYWltZWQsIHRvdGFsQWlyZHJvcHBlZCwgbGFzdFVwZGF0ZWQgfTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciByZWFkaW5nIGRhc2hib2FyZCBkYXRhOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBhcHBlbmRUb0V4Y2VsLFxyXG4gIHJlYWRFeGNlbERhdGEsXHJcbn07Il0sIm5hbWVzIjpbIkV4Y2VsSlMiLCJyZXF1aXJlIiwiZnMiLCJwcm9taXNlcyIsImFwcGVuZFRvRXhjZWwiLCJkYXRlIiwiY2xhaW1lZCIsImFpcmRyb3BwZWQiLCJ3b3JrYm9vayIsIldvcmtib29rIiwiZmlsZVBhdGgiLCJhY2Nlc3MiLCJ0aGVuIiwiY2F0Y2giLCJ4bHN4IiwicmVhZEZpbGUiLCJzaGVldCIsImdldFdvcmtzaGVldCIsImFkZFdvcmtzaGVldCIsImFkZFJvdyIsInRvSVNPU3RyaW5nIiwid3JpdGVGaWxlIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJyZWFkRXhjZWxEYXRhIiwiZGF0YSIsInRvdGFsQ2xhaW1lZCIsInRvdGFsQWlyZHJvcHBlZCIsImxhc3RVcGRhdGVkIiwiZWFjaFJvdyIsInJvdyIsInJvd051bWJlciIsInJvd0RhdGEiLCJEYXRlIiwiZ2V0Q2VsbCIsInZhbHVlIiwicHVzaCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./lib/excel.js\n");

/***/ }),

/***/ "(api)/./lib/solana.js":
/*!***********************!*\
  !*** ./lib/solana.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Connection, Keypair, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL, VersionedTransaction } = __webpack_require__(/*! @solana/web3.js */ \"@solana/web3.js\");\nconst axios = __webpack_require__(/*! axios */ \"axios?6fac\");\nconst bs58 = __webpack_require__(/*! bs58 */ \"bs58\");\nasync function initializeKeypair() {\n    try {\n        try {\n            const secretKeyArray = JSON.parse(process.env.PRIVATE_KEY);\n            const secretKeyBytes = Uint8Array.from(secretKeyArray);\n            if (secretKeyBytes.length !== 64) {\n                throw new Error(`Secret key must be 64 bytes, got ${secretKeyBytes.length}`);\n            }\n            return Keypair.fromSecretKey(secretKeyBytes);\n        } catch (jsonError) {\n            try {\n                const secretKeyBytes = bs58.decode(process.env.PRIVATE_KEY);\n                if (secretKeyBytes.length !== 64) {\n                    throw new Error(`Base58 secret key must decode to 64 bytes, got ${secretKeyBytes.length}`);\n                }\n                return Keypair.fromSecretKey(secretKeyBytes);\n            } catch (bs58Error) {\n                throw new Error(`Invalid private key format: JSON error (${jsonError.message}), Base58 error (${bs58Error.message})`);\n            }\n        }\n    } catch (error) {\n        throw new Error(`Invalid secret key: ${error.message}`);\n    }\n}\nasync function claimFeesForToken(tokenMint, connection, keypair, logToFile) {\n    try {\n        await logToFile(`Claiming fees for token ${tokenMint} with wallet ${keypair.publicKey.toBase58()} on devnet`);\n        const initialBalance = await connection.getBalance(keypair.publicKey, \"confirmed\");\n        const response = await axios.post(\"https://pumpportal.fun/api/trade-local\", {\n            publicKey: keypair.publicKey.toBase58(),\n            action: \"collectCreatorFee\",\n            priorityFee: 0.000001\n        });\n        const messageBytes = Buffer.from(response.data, \"base64\");\n        const message = VersionedTransaction.deserialize(messageBytes).message;\n        const tx = new VersionedTransaction(message);\n        tx.sign([\n            keypair\n        ]);\n        const signature = await connection.sendTransaction(tx, {\n            preflightCommitment: \"confirmed\"\n        });\n        await connection.confirmTransaction(signature, \"confirmed\");\n        const finalBalance = await connection.getBalance(keypair.publicKey, \"confirmed\");\n        const txDetails = await connection.getTransaction(signature, {\n            commitment: \"confirmed\",\n            maxSupportedTransactionVersion: 0\n        });\n        const txFee = txDetails.meta.fee;\n        const claimedLamports = finalBalance - initialBalance + txFee;\n        const claimedSol = claimedLamports / LAMPORTS_PER_SOL;\n        await logToFile(`Transaction confirmed: https://solscan.io/tx/${signature}?cluster=devnet`);\n        await logToFile(`Claimed ${claimedSol.toFixed(6)} SOL on devnet`);\n        return claimedSol;\n    } catch (error) {\n        await logToFile(`Unexpected error in claimFeesForToken on devnet: ${error.message}`);\n        return 0;\n    }\n}\nasync function getTokenDecimals(mintAddress, logToFile) {\n    const url = process.env.HELIUS_RPC_URL;\n    const payload = {\n        jsonrpc: \"2.0\",\n        id: \"get-account-info\",\n        method: \"getAccountInfo\",\n        params: [\n            mintAddress,\n            {\n                encoding: \"jsonParsed\"\n            }\n        ]\n    };\n    try {\n        const response = await axios.post(url, payload);\n        if (!response.data.result?.value) {\n            throw new Error(`No account info found for mint ${mintAddress} on mainnet`);\n        }\n        const decimals = response.data.result.value.data.parsed.info.decimals;\n        await logToFile(`Fetched decimals: ${decimals} for mint ${mintAddress} on mainnet`);\n        return decimals;\n    } catch (error) {\n        await logToFile(`Failed to fetch decimals for mint ${mintAddress} on mainnet: ${error.message}`);\n        throw error;\n    }\n}\nasync function fetchTokenHolders(tokenMintAddress, logToFile) {\n    const url = process.env.HELIUS_RPC_URL;\n    const decimals = await getTokenDecimals(tokenMintAddress, logToFile);\n    await logToFile(`Token decimals: ${decimals}`);\n    let page = 1;\n    const allHolders = [];\n    while(true){\n        const payload = {\n            jsonrpc: \"2.0\",\n            id: \"helius-test\",\n            method: \"getTokenAccounts\",\n            params: {\n                page: page,\n                limit: 1000,\n                mint: tokenMintAddress,\n                displayOptions: {}\n            }\n        };\n        try {\n            const response = await axios.post(url, payload);\n            if (response.status !== 200) {\n                const errorMsg = `Error fetching holders from mainnet: ${response.status}, ${response.statusText}`;\n                await logToFile(errorMsg);\n                break;\n            }\n            const data = response.data;\n            if (!data.result?.token_accounts?.length) {\n                const msg = `No more results from mainnet. Total pages processed: ${page - 1}`;\n                await logToFile(msg);\n                break;\n            }\n            await logToFile(`Processing page ${page} with ${data.result.token_accounts.length} accounts from mainnet`);\n            for (const account of data.result.token_accounts){\n                if (account.amount > 0) {\n                    const balance = account.amount / Math.pow(10, decimals);\n                    allHolders.push({\n                        holder_address: account.owner,\n                        balance: balance,\n                        token_account: account.address\n                    });\n                }\n            }\n            page++;\n        } catch (error) {\n            const errorMsg = `Error fetching page ${page} from mainnet: ${error.message}`;\n            await logToFile(errorMsg);\n            break;\n        }\n    }\n    return allHolders;\n}\nasync function validateMainnetAddress(connection, address, logToFile) {\n    try {\n        const pubkey = new PublicKey(address);\n        const accountInfo = await connection.getAccountInfo(pubkey, \"confirmed\");\n        const exists = !!accountInfo;\n        await logToFile(`Validated address ${address} on devnet: ${exists ? \"Exists\" : \"Does not exist\"}`);\n        return exists;\n    } catch (error) {\n        await logToFile(`Error validating address ${address} on devnet: ${error.message}`);\n        return false;\n    }\n}\nasync function sendAirdrop(connection, keypair, recipients, logToFile) {\n    const senderPubkey = keypair.publicKey;\n    const TRANSACTION_FEE = 5000;\n    const totalAmount = recipients.reduce((sum, { amount })=>sum + amount, 0);\n    const balance = await connection.getBalance(senderPubkey, \"confirmed\");\n    if (balance < totalAmount + TRANSACTION_FEE * recipients.length) {\n        const errorMsg = `Insufficient funds on devnet. Have: ${balance / LAMPORTS_PER_SOL} SOL, Need: ${(totalAmount + TRANSACTION_FEE * recipients.length) / LAMPORTS_PER_SOL} SOL`;\n        await logToFile(errorMsg);\n        return 0;\n    }\n    let totalSentLamports = 0;\n    for (const { address, amount } of recipients){\n        if (amount <= 0) {\n            await logToFile(`Skipping zero or negative amount for ${address}`);\n            continue;\n        }\n        try {\n            await logToFile(`Preparing to send ${amount / LAMPORTS_PER_SOL} SOL from ${senderPubkey} to ${address} on devnet`);\n            let success = false;\n            for(let attempt = 1; attempt <= 3; attempt++){\n                try {\n                    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash(\"confirmed\");\n                    const transaction = new Transaction({\n                        recentBlockhash: blockhash,\n                        feePayer: senderPubkey\n                    }).add(SystemProgram.transfer({\n                        fromPubkey: senderPubkey,\n                        toPubkey: new PublicKey(address),\n                        lamports: Math.floor(amount)\n                    }));\n                    const signature = await connection.sendTransaction(transaction, [\n                        keypair\n                    ], {\n                        skipPreflight: false\n                    });\n                    await logToFile(`Transaction sent with signature: ${signature} to ${address} on devnet`);\n                    const confirmation = await connection.confirmTransaction({\n                        signature,\n                        blockhash,\n                        lastValidBlockHeight\n                    }, \"confirmed\");\n                    if (confirmation.value.err) {\n                        throw new Error(`Transaction failed: ${confirmation.value.err}`);\n                    }\n                    await logToFile(`Airdrop successful! Sent ${amount / LAMPORTS_PER_SOL} SOL to ${address} on devnet`);\n                    success = true;\n                    break;\n                } catch (error) {\n                    await logToFile(`Error on attempt ${attempt} for ${address} on devnet: ${error.message}`);\n                    await new Promise((resolve)=>setTimeout(resolve, 3000));\n                }\n            }\n            if (success) {\n                totalSentLamports += amount;\n            }\n        } catch (error) {\n            await logToFile(`Critical error sending to ${address} on devnet: ${error.message}`);\n        }\n    }\n    return totalSentLamports;\n}\nmodule.exports = {\n    initializeKeypair,\n    claimFeesForToken,\n    fetchTokenHolders,\n    validateMainnetAddress,\n    sendAirdrop\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VUFBVSxDQUFDLGlDQUFpQyxFQUFFZSxVQUFVLElBQUksRUFBRW1ELFFBQVEsVUFBVSxDQUFDO29CQUN2RixNQUFNNkIsZUFBZSxNQUFNakcsV0FBV29CLGtCQUFrQixDQUN0RDt3QkFBRUg7d0JBQVdtRTt3QkFBV0M7b0JBQXFCLEdBQzdDO29CQUVGLElBQUlZLGFBQWF0RCxLQUFLLENBQUN1RCxHQUFHLEVBQUU7d0JBQzFCLE1BQU0sSUFBSTNHLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRTBHLGFBQWF0RCxLQUFLLENBQUN1RCxHQUFHLENBQUMsQ0FBQztvQkFDakU7b0JBQ0EsTUFBTWhHLFVBQVUsQ0FBQyx5QkFBeUIsRUFBRTBELFNBQVNyRixpQkFBaUIsUUFBUSxFQUFFNkYsUUFBUSxVQUFVLENBQUM7b0JBQ25HYyxVQUFVO29CQUNWO2dCQUNGLEVBQUUsT0FBT3JGLE9BQU87b0JBQ2QsTUFBTUssVUFBVSxDQUFDLGlCQUFpQixFQUFFaUYsUUFBUSxLQUFLLEVBQUVmLFFBQVEsWUFBWSxFQUFFdkUsTUFBTUQsT0FBTyxDQUFDLENBQUM7b0JBQ3hGLE1BQU0sSUFBSXVHLFFBQVEsQ0FBQ0MsVUFBWUMsV0FBV0QsU0FBUztnQkFDckQ7WUFDRjtZQUNBLElBQUlsQixTQUFTO2dCQUNYRCxxQkFBcUJyQjtZQUN2QjtRQUNGLEVBQUUsT0FBTy9ELE9BQU87WUFDZCxNQUFNSyxVQUFVLENBQUMsMEJBQTBCLEVBQUVrRSxRQUFRLFlBQVksRUFBRXZFLE1BQU1ELE9BQU8sQ0FBQyxDQUFDO1FBQ3BGO0lBQ0Y7SUFDQSxPQUFPcUY7QUFDVDtBQUVBcUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2YzSDtJQUNBa0I7SUFDQWlEO0lBQ0FzQjtJQUNBSztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlyZHJvcC1kYXNoYm9hcmQvLi9saWIvc29sYW5hLmpzPzQ3MGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBDb25uZWN0aW9uLCBLZXlwYWlyLCBQdWJsaWNLZXksIFRyYW5zYWN0aW9uLCBTeXN0ZW1Qcm9ncmFtLCBMQU1QT1JUU19QRVJfU09MLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiB9ID0gcmVxdWlyZShcIkBzb2xhbmEvd2ViMy5qc1wiKTtcclxuY29uc3QgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XHJcbmNvbnN0IGJzNTggPSByZXF1aXJlKFwiYnM1OFwiKTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVLZXlwYWlyKCkge1xyXG4gIHRyeSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzZWNyZXRLZXlBcnJheSA9IEpTT04ucGFyc2UocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpO1xyXG4gICAgICBjb25zdCBzZWNyZXRLZXlCeXRlcyA9IFVpbnQ4QXJyYXkuZnJvbShzZWNyZXRLZXlBcnJheSk7XHJcbiAgICAgIGlmIChzZWNyZXRLZXlCeXRlcy5sZW5ndGggIT09IDY0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZWNyZXQga2V5IG11c3QgYmUgNjQgYnl0ZXMsIGdvdCAke3NlY3JldEtleUJ5dGVzLmxlbmd0aH1gKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gS2V5cGFpci5mcm9tU2VjcmV0S2V5KHNlY3JldEtleUJ5dGVzKTtcclxuICAgIH0gY2F0Y2ggKGpzb25FcnJvcikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHNlY3JldEtleUJ5dGVzID0gYnM1OC5kZWNvZGUocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpO1xyXG4gICAgICAgIGlmIChzZWNyZXRLZXlCeXRlcy5sZW5ndGggIT09IDY0KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhc2U1OCBzZWNyZXQga2V5IG11c3QgZGVjb2RlIHRvIDY0IGJ5dGVzLCBnb3QgJHtzZWNyZXRLZXlCeXRlcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBLZXlwYWlyLmZyb21TZWNyZXRLZXkoc2VjcmV0S2V5Qnl0ZXMpO1xyXG4gICAgICB9IGNhdGNoIChiczU4RXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJpdmF0ZSBrZXkgZm9ybWF0OiBKU09OIGVycm9yICgke2pzb25FcnJvci5tZXNzYWdlfSksIEJhc2U1OCBlcnJvciAoJHticzU4RXJyb3IubWVzc2FnZX0pYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlY3JldCBrZXk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGNsYWltRmVlc0ZvclRva2VuKHRva2VuTWludCwgY29ubmVjdGlvbiwga2V5cGFpciwgbG9nVG9GaWxlKSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgQ2xhaW1pbmcgZmVlcyBmb3IgdG9rZW4gJHt0b2tlbk1pbnR9IHdpdGggd2FsbGV0ICR7a2V5cGFpci5wdWJsaWNLZXkudG9CYXNlNTgoKX0gb24gZGV2bmV0YCk7XHJcbiAgICBjb25zdCBpbml0aWFsQmFsYW5jZSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QmFsYW5jZShrZXlwYWlyLnB1YmxpY0tleSwgXCJjb25maXJtZWRcIik7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoXCJodHRwczovL3B1bXBwb3J0YWwuZnVuL2FwaS90cmFkZS1sb2NhbFwiLCB7XHJcbiAgICAgIHB1YmxpY0tleToga2V5cGFpci5wdWJsaWNLZXkudG9CYXNlNTgoKSxcclxuICAgICAgYWN0aW9uOiBcImNvbGxlY3RDcmVhdG9yRmVlXCIsXHJcbiAgICAgIHByaW9yaXR5RmVlOiAwLjAwMDAwMSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbWVzc2FnZUJ5dGVzID0gQnVmZmVyLmZyb20ocmVzcG9uc2UuZGF0YSwgXCJiYXNlNjRcIik7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gVmVyc2lvbmVkVHJhbnNhY3Rpb24uZGVzZXJpYWxpemUobWVzc2FnZUJ5dGVzKS5tZXNzYWdlO1xyXG4gICAgY29uc3QgdHggPSBuZXcgVmVyc2lvbmVkVHJhbnNhY3Rpb24obWVzc2FnZSk7XHJcbiAgICB0eC5zaWduKFtrZXlwYWlyXSk7XHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0eCwgeyBwcmVmbGlnaHRDb21taXRtZW50OiBcImNvbmZpcm1lZFwiIH0pO1xyXG4gICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBcImNvbmZpcm1lZFwiKTtcclxuICAgIGNvbnN0IGZpbmFsQmFsYW5jZSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QmFsYW5jZShrZXlwYWlyLnB1YmxpY0tleSwgXCJjb25maXJtZWRcIik7XHJcbiAgICBjb25zdCB0eERldGFpbHMgPSBhd2FpdCBjb25uZWN0aW9uLmdldFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgeyBjb21taXRtZW50OiBcImNvbmZpcm1lZFwiLCBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb246IDAgfSk7XHJcbiAgICBjb25zdCB0eEZlZSA9IHR4RGV0YWlscy5tZXRhLmZlZTtcclxuICAgIGNvbnN0IGNsYWltZWRMYW1wb3J0cyA9IChmaW5hbEJhbGFuY2UgLSBpbml0aWFsQmFsYW5jZSkgKyB0eEZlZTtcclxuICAgIGNvbnN0IGNsYWltZWRTb2wgPSBjbGFpbWVkTGFtcG9ydHMgLyBMQU1QT1JUU19QRVJfU09MO1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBUcmFuc2FjdGlvbiBjb25maXJtZWQ6IGh0dHBzOi8vc29sc2Nhbi5pby90eC8ke3NpZ25hdHVyZX0/Y2x1c3Rlcj1kZXZuZXRgKTtcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgQ2xhaW1lZCAke2NsYWltZWRTb2wudG9GaXhlZCg2KX0gU09MIG9uIGRldm5ldGApO1xyXG4gICAgcmV0dXJuIGNsYWltZWRTb2w7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgVW5leHBlY3RlZCBlcnJvciBpbiBjbGFpbUZlZXNGb3JUb2tlbiBvbiBkZXZuZXQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0VG9rZW5EZWNpbWFscyhtaW50QWRkcmVzcywgbG9nVG9GaWxlKSB7XHJcbiAgY29uc3QgdXJsID0gcHJvY2Vzcy5lbnYuSEVMSVVTX1JQQ19VUkw7XHJcbiAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgIGpzb25ycGM6IFwiMi4wXCIsXHJcbiAgICBpZDogXCJnZXQtYWNjb3VudC1pbmZvXCIsXHJcbiAgICBtZXRob2Q6IFwiZ2V0QWNjb3VudEluZm9cIixcclxuICAgIHBhcmFtczogW21pbnRBZGRyZXNzLCB7IGVuY29kaW5nOiBcImpzb25QYXJzZWRcIiB9XSxcclxuICB9O1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QodXJsLCBwYXlsb2FkKTtcclxuICAgIGlmICghcmVzcG9uc2UuZGF0YS5yZXN1bHQ/LnZhbHVlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gYWNjb3VudCBpbmZvIGZvdW5kIGZvciBtaW50ICR7bWludEFkZHJlc3N9IG9uIG1haW5uZXRgKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlY2ltYWxzID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQudmFsdWUuZGF0YS5wYXJzZWQuaW5mby5kZWNpbWFscztcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgRmV0Y2hlZCBkZWNpbWFsczogJHtkZWNpbWFsc30gZm9yIG1pbnQgJHttaW50QWRkcmVzc30gb24gbWFpbm5ldGApO1xyXG4gICAgcmV0dXJuIGRlY2ltYWxzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBhd2FpdCBsb2dUb0ZpbGUoYEZhaWxlZCB0byBmZXRjaCBkZWNpbWFscyBmb3IgbWludCAke21pbnRBZGRyZXNzfSBvbiBtYWlubmV0OiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoVG9rZW5Ib2xkZXJzKHRva2VuTWludEFkZHJlc3MsIGxvZ1RvRmlsZSkge1xyXG4gIGNvbnN0IHVybCA9IHByb2Nlc3MuZW52LkhFTElVU19SUENfVVJMO1xyXG4gIGNvbnN0IGRlY2ltYWxzID0gYXdhaXQgZ2V0VG9rZW5EZWNpbWFscyh0b2tlbk1pbnRBZGRyZXNzLCBsb2dUb0ZpbGUpO1xyXG4gIGF3YWl0IGxvZ1RvRmlsZShgVG9rZW4gZGVjaW1hbHM6ICR7ZGVjaW1hbHN9YCk7XHJcbiAgbGV0IHBhZ2UgPSAxO1xyXG4gIGNvbnN0IGFsbEhvbGRlcnMgPSBbXTtcclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAganNvbnJwYzogXCIyLjBcIixcclxuICAgICAgaWQ6IFwiaGVsaXVzLXRlc3RcIixcclxuICAgICAgbWV0aG9kOiBcImdldFRva2VuQWNjb3VudHNcIixcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgcGFnZTogcGFnZSxcclxuICAgICAgICBsaW1pdDogMTAwMCxcclxuICAgICAgICBtaW50OiB0b2tlbk1pbnRBZGRyZXNzLFxyXG4gICAgICAgIGRpc3BsYXlPcHRpb25zOiB7fSxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QodXJsLCBwYXlsb2FkKTtcclxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBgRXJyb3IgZmV0Y2hpbmcgaG9sZGVycyBmcm9tIG1haW5uZXQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSwgJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XHJcbiAgICAgICAgYXdhaXQgbG9nVG9GaWxlKGVycm9yTXNnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgaWYgKCFkYXRhLnJlc3VsdD8udG9rZW5fYWNjb3VudHM/Lmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IGBObyBtb3JlIHJlc3VsdHMgZnJvbSBtYWlubmV0LiBUb3RhbCBwYWdlcyBwcm9jZXNzZWQ6ICR7cGFnZSAtIDF9YDtcclxuICAgICAgICBhd2FpdCBsb2dUb0ZpbGUobXNnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBhd2FpdCBsb2dUb0ZpbGUoYFByb2Nlc3NpbmcgcGFnZSAke3BhZ2V9IHdpdGggJHtkYXRhLnJlc3VsdC50b2tlbl9hY2NvdW50cy5sZW5ndGh9IGFjY291bnRzIGZyb20gbWFpbm5ldGApO1xyXG4gICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgZGF0YS5yZXN1bHQudG9rZW5fYWNjb3VudHMpIHtcclxuICAgICAgICBpZiAoYWNjb3VudC5hbW91bnQgPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYWNjb3VudC5hbW91bnQgLyBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xyXG4gICAgICAgICAgYWxsSG9sZGVycy5wdXNoKHtcclxuICAgICAgICAgICAgaG9sZGVyX2FkZHJlc3M6IGFjY291bnQub3duZXIsXHJcbiAgICAgICAgICAgIGJhbGFuY2U6IGJhbGFuY2UsXHJcbiAgICAgICAgICAgIHRva2VuX2FjY291bnQ6IGFjY291bnQuYWRkcmVzcyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwYWdlKys7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBlcnJvck1zZyA9IGBFcnJvciBmZXRjaGluZyBwYWdlICR7cGFnZX0gZnJvbSBtYWlubmV0OiAke2Vycm9yLm1lc3NhZ2V9YDtcclxuICAgICAgYXdhaXQgbG9nVG9GaWxlKGVycm9yTXNnKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBhbGxIb2xkZXJzO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZU1haW5uZXRBZGRyZXNzKGNvbm5lY3Rpb24sIGFkZHJlc3MsIGxvZ1RvRmlsZSkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwdWJrZXkgPSBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xyXG4gICAgY29uc3QgYWNjb3VudEluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHB1YmtleSwgXCJjb25maXJtZWRcIik7XHJcbiAgICBjb25zdCBleGlzdHMgPSAhIWFjY291bnRJbmZvO1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBWYWxpZGF0ZWQgYWRkcmVzcyAke2FkZHJlc3N9IG9uIGRldm5ldDogJHtleGlzdHMgPyBcIkV4aXN0c1wiIDogXCJEb2VzIG5vdCBleGlzdFwifWApO1xyXG4gICAgcmV0dXJuIGV4aXN0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBFcnJvciB2YWxpZGF0aW5nIGFkZHJlc3MgJHthZGRyZXNzfSBvbiBkZXZuZXQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRBaXJkcm9wKGNvbm5lY3Rpb24sIGtleXBhaXIsIHJlY2lwaWVudHMsIGxvZ1RvRmlsZSkge1xyXG4gIGNvbnN0IHNlbmRlclB1YmtleSA9IGtleXBhaXIucHVibGljS2V5O1xyXG4gIGNvbnN0IFRSQU5TQUNUSU9OX0ZFRSA9IDUwMDA7XHJcbiAgY29uc3QgdG90YWxBbW91bnQgPSByZWNpcGllbnRzLnJlZHVjZSgoc3VtLCB7IGFtb3VudCB9KSA9PiBzdW0gKyBhbW91bnQsIDApO1xyXG4gIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb25uZWN0aW9uLmdldEJhbGFuY2Uoc2VuZGVyUHVia2V5LCBcImNvbmZpcm1lZFwiKTtcclxuICBpZiAoYmFsYW5jZSA8IHRvdGFsQW1vdW50ICsgVFJBTlNBQ1RJT05fRkVFICogcmVjaXBpZW50cy5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGVycm9yTXNnID0gYEluc3VmZmljaWVudCBmdW5kcyBvbiBkZXZuZXQuIEhhdmU6ICR7YmFsYW5jZSAvIExBTVBPUlRTX1BFUl9TT0x9IFNPTCwgTmVlZDogJHsodG90YWxBbW91bnQgKyBUUkFOU0FDVElPTl9GRUUgKiByZWNpcGllbnRzLmxlbmd0aCkgLyBMQU1QT1JUU19QRVJfU09MfSBTT0xgO1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGVycm9yTXNnKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBsZXQgdG90YWxTZW50TGFtcG9ydHMgPSAwO1xyXG4gIGZvciAoY29uc3QgeyBhZGRyZXNzLCBhbW91bnQgfSBvZiByZWNpcGllbnRzKSB7XHJcbiAgICBpZiAoYW1vdW50IDw9IDApIHtcclxuICAgICAgYXdhaXQgbG9nVG9GaWxlKGBTa2lwcGluZyB6ZXJvIG9yIG5lZ2F0aXZlIGFtb3VudCBmb3IgJHthZGRyZXNzfWApO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGxvZ1RvRmlsZShgUHJlcGFyaW5nIHRvIHNlbmQgJHthbW91bnQgLyBMQU1QT1JUU19QRVJfU09MfSBTT0wgZnJvbSAke3NlbmRlclB1YmtleX0gdG8gJHthZGRyZXNzfSBvbiBkZXZuZXRgKTtcclxuICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcclxuICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gMzsgYXR0ZW1wdCsrKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodCB9ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goXCJjb25maXJtZWRcIik7XHJcbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbih7IHJlY2VudEJsb2NraGFzaDogYmxvY2toYXNoLCBmZWVQYXllcjogc2VuZGVyUHVia2V5IH0pLmFkZChcclxuICAgICAgICAgICAgU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XHJcbiAgICAgICAgICAgICAgZnJvbVB1YmtleTogc2VuZGVyUHVia2V5LFxyXG4gICAgICAgICAgICAgIHRvUHVia2V5OiBuZXcgUHVibGljS2V5KGFkZHJlc3MpLFxyXG4gICAgICAgICAgICAgIGxhbXBvcnRzOiBNYXRoLmZsb29yKGFtb3VudCksXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIFtrZXlwYWlyXSwgeyBza2lwUHJlZmxpZ2h0OiBmYWxzZSB9KTtcclxuICAgICAgICAgIGF3YWl0IGxvZ1RvRmlsZShgVHJhbnNhY3Rpb24gc2VudCB3aXRoIHNpZ25hdHVyZTogJHtzaWduYXR1cmV9IHRvICR7YWRkcmVzc30gb24gZGV2bmV0YCk7XHJcbiAgICAgICAgICBjb25zdCBjb25maXJtYXRpb24gPSBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihcclxuICAgICAgICAgICAgeyBzaWduYXR1cmUsIGJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQgfSxcclxuICAgICAgICAgICAgXCJjb25maXJtZWRcIlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGlmIChjb25maXJtYXRpb24udmFsdWUuZXJyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gZmFpbGVkOiAke2NvbmZpcm1hdGlvbi52YWx1ZS5lcnJ9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoYEFpcmRyb3Agc3VjY2Vzc2Z1bCEgU2VudCAke2Ftb3VudCAvIExBTVBPUlRTX1BFUl9TT0x9IFNPTCB0byAke2FkZHJlc3N9IG9uIGRldm5ldGApO1xyXG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgYXdhaXQgbG9nVG9GaWxlKGBFcnJvciBvbiBhdHRlbXB0ICR7YXR0ZW1wdH0gZm9yICR7YWRkcmVzc30gb24gZGV2bmV0OiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgdG90YWxTZW50TGFtcG9ydHMgKz0gYW1vdW50O1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBhd2FpdCBsb2dUb0ZpbGUoYENyaXRpY2FsIGVycm9yIHNlbmRpbmcgdG8gJHthZGRyZXNzfSBvbiBkZXZuZXQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRvdGFsU2VudExhbXBvcnRzO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpbml0aWFsaXplS2V5cGFpcixcclxuICBjbGFpbUZlZXNGb3JUb2tlbixcclxuICBmZXRjaFRva2VuSG9sZGVycyxcclxuICB2YWxpZGF0ZU1haW5uZXRBZGRyZXNzLFxyXG4gIHNlbmRBaXJkcm9wLFxyXG59OyJdLCJuYW1lcyI6WyJDb25uZWN0aW9uIiwiS2V5cGFpciIsIlB1YmxpY0tleSIsIlRyYW5zYWN0aW9uIiwiU3lzdGVtUHJvZ3JhbSIsIkxBTVBPUlRTX1BFUl9TT0wiLCJWZXJzaW9uZWRUcmFuc2FjdGlvbiIsInJlcXVpcmUiLCJheGlvcyIsImJzNTgiLCJpbml0aWFsaXplS2V5cGFpciIsInNlY3JldEtleUFycmF5IiwiSlNPTiIsInBhcnNlIiwicHJvY2VzcyIsImVudiIsIlBSSVZBVEVfS0VZIiwic2VjcmV0S2V5Qnl0ZXMiLCJVaW50OEFycmF5IiwiZnJvbSIsImxlbmd0aCIsIkVycm9yIiwiZnJvbVNlY3JldEtleSIsImpzb25FcnJvciIsImRlY29kZSIsImJzNThFcnJvciIsIm1lc3NhZ2UiLCJlcnJvciIsImNsYWltRmVlc0ZvclRva2VuIiwidG9rZW5NaW50IiwiY29ubmVjdGlvbiIsImtleXBhaXIiLCJsb2dUb0ZpbGUiLCJwdWJsaWNLZXkiLCJ0b0Jhc2U1OCIsImluaXRpYWxCYWxhbmNlIiwiZ2V0QmFsYW5jZSIsInJlc3BvbnNlIiwicG9zdCIsImFjdGlvbiIsInByaW9yaXR5RmVlIiwibWVzc2FnZUJ5dGVzIiwiQnVmZmVyIiwiZGF0YSIsImRlc2VyaWFsaXplIiwidHgiLCJzaWduIiwic2lnbmF0dXJlIiwic2VuZFRyYW5zYWN0aW9uIiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsImNvbmZpcm1UcmFuc2FjdGlvbiIsImZpbmFsQmFsYW5jZSIsInR4RGV0YWlscyIsImdldFRyYW5zYWN0aW9uIiwiY29tbWl0bWVudCIsIm1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbiIsInR4RmVlIiwibWV0YSIsImZlZSIsImNsYWltZWRMYW1wb3J0cyIsImNsYWltZWRTb2wiLCJ0b0ZpeGVkIiwiZ2V0VG9rZW5EZWNpbWFscyIsIm1pbnRBZGRyZXNzIiwidXJsIiwiSEVMSVVTX1JQQ19VUkwiLCJwYXlsb2FkIiwianNvbnJwYyIsImlkIiwibWV0aG9kIiwicGFyYW1zIiwiZW5jb2RpbmciLCJyZXN1bHQiLCJ2YWx1ZSIsImRlY2ltYWxzIiwicGFyc2VkIiwiaW5mbyIsImZldGNoVG9rZW5Ib2xkZXJzIiwidG9rZW5NaW50QWRkcmVzcyIsInBhZ2UiLCJhbGxIb2xkZXJzIiwibGltaXQiLCJtaW50IiwiZGlzcGxheU9wdGlvbnMiLCJzdGF0dXMiLCJlcnJvck1zZyIsInN0YXR1c1RleHQiLCJ0b2tlbl9hY2NvdW50cyIsIm1zZyIsImFjY291bnQiLCJhbW91bnQiLCJiYWxhbmNlIiwiTWF0aCIsInBvdyIsInB1c2giLCJob2xkZXJfYWRkcmVzcyIsIm93bmVyIiwidG9rZW5fYWNjb3VudCIsImFkZHJlc3MiLCJ2YWxpZGF0ZU1haW5uZXRBZGRyZXNzIiwicHVia2V5IiwiYWNjb3VudEluZm8iLCJnZXRBY2NvdW50SW5mbyIsImV4aXN0cyIsInNlbmRBaXJkcm9wIiwicmVjaXBpZW50cyIsInNlbmRlclB1YmtleSIsIlRSQU5TQUNUSU9OX0ZFRSIsInRvdGFsQW1vdW50IiwicmVkdWNlIiwic3VtIiwidG90YWxTZW50TGFtcG9ydHMiLCJzdWNjZXNzIiwiYXR0ZW1wdCIsImJsb2NraGFzaCIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0IiwiZ2V0TGF0ZXN0QmxvY2toYXNoIiwidHJhbnNhY3Rpb24iLCJyZWNlbnRCbG9ja2hhc2giLCJmZWVQYXllciIsImFkZCIsInRyYW5zZmVyIiwiZnJvbVB1YmtleSIsInRvUHVia2V5IiwibGFtcG9ydHMiLCJmbG9vciIsInNraXBQcmVmbGlnaHQiLCJjb25maXJtYXRpb24iLCJlcnIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/solana.js\n");

/***/ }),

/***/ "(api)/./pages/api/airdrop.js":
/*!******************************!*\
  !*** ./pages/api/airdrop.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\nconst { Connection, LAMPORTS_PER_SOL } = __webpack_require__(/*! @solana/web3.js */ \"@solana/web3.js\");\nconst fs = (__webpack_require__(/*! fs */ \"fs\").promises);\nconst path = __webpack_require__(/*! path */ \"path\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst { initializeKeypair, claimFeesForToken, fetchTokenHolders, validateMainnetAddress, sendAirdrop } = __webpack_require__(/*! ../../lib/solana */ \"(api)/./lib/solana.js\");\nconst { appendToExcel } = __webpack_require__(/*! ../../lib/excel */ \"(api)/./lib/excel.js\");\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    const connection = new Connection(\"https://api.devnet.solana.com\", \"confirmed\");\n    let keypair;\n    try {\n        keypair = await initializeKeypair();\n    } catch (error) {\n        await logToFile(`Invalid secret key: ${error.message}`);\n        return res.status(500).json({\n            error: `Invalid secret key: ${error.message}`\n        });\n    }\n    async function logToFile(message, logFile = path.join(os.tmpdir(), \"airdrop_log.txt\")) {\n        const timestamp = new Date().toISOString().replace(/T/, \" \").replace(/\\..+/, \"\");\n        try {\n            await fs.appendFile(logFile, `[${timestamp}] ${message}\\n`);\n        } catch (err) {\n            console.error(`Failed to write to log file ${logFile}: ${err.message}`);\n            throw err;\n        }\n    }\n    try {\n        await logToFile(`Starting airdrop cycle (holder scraping on mainnet, airdrop on devnet). Temp directory: ${os.tmpdir()}`);\n        const claimedSol = await claimFeesForToken(process.env.TOKEN_MINT_ADDRESS, connection, keypair, logToFile);\n        await logToFile(\"Fetching token holders from mainnet...\");\n        const holders = await fetchTokenHolders(process.env.TOKEN_MINT_ADDRESS, logToFile);\n        const qualifiedHolders = [];\n        for (const holder of holders){\n            if (await validateMainnetAddress(connection, holder.holder_address, logToFile)) {\n                qualifiedHolders.push(holder);\n            }\n        }\n        const outputContent = [\n            `Token Holders for Mint: ${process.env.TOKEN_MINT_ADDRESS} (fetched from mainnet)`,\n            `Total Holders: ${holders.length}`,\n            `Qualified Holders (on devnet): ${qualifiedHolders.length}`,\n            \"-\".repeat(50),\n            ...holders.map((holder)=>`Holder: ${holder.holder_address}, Balance: ${holder.balance}, Token Account: ${holder.token_account}, Qualified: ${qualifiedHolders.some((q)=>q.holder_address === holder.holder_address) ? \"Yes\" : \"No\"}`)\n        ].join(\"\\n\");\n        const holdersFilePath = path.join(os.tmpdir(), \"token_holders.txt\");\n        await fs.writeFile(holdersFilePath, outputContent);\n        await logToFile(`Saved ${holders.length} token holders (${qualifiedHolders.length} qualified) to ${holdersFilePath}`);\n        const balance = await connection.getBalance(keypair.publicKey, \"confirmed\");\n        await logToFile(`Devnet wallet balance: ${balance / LAMPORTS_PER_SOL} SOL`);\n        let airdroppedLamports = 0;\n        const MINIMUM_BALANCE = 0.2 * LAMPORTS_PER_SOL;\n        if (balance > MINIMUM_BALANCE) {\n            const distributableLamports = Math.floor(balance - MINIMUM_BALANCE);\n            await logToFile(`Distributable amount: ${distributableLamports / LAMPORTS_PER_SOL} SOL`);\n            const feeWalletValid = await validateMainnetAddress(connection, process.env.FEE_WALLET_ADDRESS, logToFile);\n            if (!feeWalletValid) {\n                await logToFile(`Fee wallet ${process.env.FEE_WALLET_ADDRESS} does not exist on devnet`);\n                return res.status(400).json({\n                    error: `Fee wallet ${process.env.FEE_WALLET_ADDRESS} does not exist on devnet`\n                });\n            }\n            const feeAmount = Math.floor(distributableLamports * 0.1);\n            let holdersAmount = distributableLamports - feeAmount;\n            const holdersCount = qualifiedHolders.length;\n            const recipients = [];\n            let weights = [];\n            if (feeAmount > 0) {\n                recipients.push({\n                    address: process.env.FEE_WALLET_ADDRESS,\n                    amount: feeAmount\n                });\n            }\n            if (holdersCount > 0 && holdersAmount > 0) {\n                weights = qualifiedHolders.map((holder)=>Math.log10(holder.balance + 1));\n                const totalWeight = weights.reduce((sum, weight)=>sum + weight, 0);\n                if (totalWeight <= 0) {\n                    await logToFile(\"No valid weights for holders, sending all to fee wallet\");\n                    recipients[0].amount += holdersAmount;\n                    holdersAmount = 0;\n                } else {\n                    for(let i = 0; i < qualifiedHolders.length; i++){\n                        const holder = qualifiedHolders[i];\n                        const weight = weights[i];\n                        const amount = Math.floor(weight / totalWeight * holdersAmount);\n                        if (amount > 0) {\n                            recipients.push({\n                                address: holder.holder_address,\n                                amount\n                            });\n                        }\n                    }\n                    const totalHoldersAmount = recipients.slice(1).reduce((sum, r)=>sum + r.amount, 0);\n                    if (holdersAmount > totalHoldersAmount) {\n                        recipients[0].amount += holdersAmount - totalHoldersAmount;\n                    }\n                }\n            } else if (holdersAmount > 0) {\n                recipients[0].amount += holdersAmount;\n                holdersAmount = 0;\n            }\n            const distributionContent = [\n                \"\\nAirdrop Distribution (on devnet, 10% fee wallet, 90% holders with logarithmic weighting)\",\n                \"-\".repeat(50),\n                `Fee Wallet (${process.env.FEE_WALLET_ADDRESS}): ${(recipients.find((r)=>r.address === process.env.FEE_WALLET_ADDRESS)?.amount || 0) / LAMPORTS_PER_SOL} SOL`,\n                ...qualifiedHolders.map((holder, i)=>`Holder (${holder.holder_address}): ${(recipients.find((r)=>r.address === holder.holder_address)?.amount || 0) / LAMPORTS_PER_SOL} SOL (Weight: ${(weights[i] || 0).toFixed(4)})`)\n            ].join(\"\\n\");\n            await fs.appendFile(holdersFilePath, distributionContent);\n            await logToFile(distributionContent);\n            if (recipients.length > 0) {\n                airdroppedLamports = await sendAirdrop(connection, keypair, recipients, logToFile);\n                if (airdroppedLamports > 0) {\n                    await logToFile(\"Airdrop completed successfully on devnet\");\n                } else {\n                    await logToFile(\"Airdrop failed on devnet, see logs for details\");\n                }\n            } else {\n                await logToFile(\"No valid recipients, skipping airdrop on devnet\");\n            }\n        } else {\n            await logToFile(\"Devnet wallet balance <= 0.2 SOL, skipping airdrop\");\n        }\n        const airdroppedSol = airdroppedLamports / LAMPORTS_PER_SOL;\n        await appendToExcel(new Date(), claimedSol, airdroppedSol);\n        res.status(200).json({\n            message: \"Airdrop cycle completed\",\n            claimedSol,\n            airdroppedSol\n        });\n    } catch (error) {\n        await logToFile(`Error in airdrop loop: ${error.message}`);\n        res.status(500).json({\n            error: `Error in airdrop loop: ${error.message}`\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXFCLEdBQUc7b0JBQzFCLE1BQU1qQyxVQUFVO2dCQUNsQixPQUFPO29CQUNMLE1BQU1BLFVBQVU7Z0JBQ2xCO1lBQ0YsT0FBTztnQkFDTCxNQUFNQSxVQUFVO1lBQ2xCO1FBQ0YsT0FBTztZQUNMLE1BQU1BLFVBQVU7UUFDbEI7UUFDQSxNQUFNMkQsZ0JBQWdCMUIscUJBQXFCdEQ7UUFDM0MsTUFBTVcsY0FBYyxJQUFJZ0IsUUFBUU0sWUFBWStDO1FBQzVDbEUsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFSyxTQUFTO1lBQTJCVztZQUFZK0M7UUFBYztJQUN2RixFQUFFLE9BQU85RCxPQUFPO1FBQ2QsTUFBTUcsVUFBVSxDQUFDLHVCQUF1QixFQUFFSCxNQUFNSSxPQUFPLENBQUMsQ0FBQztRQUN6RFIsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFQyxPQUFPLENBQUMsdUJBQXVCLEVBQUVBLE1BQU1JLE9BQU8sQ0FBQyxDQUFDO1FBQUM7SUFDMUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpcmRyb3AtZGFzaGJvYXJkLy4vcGFnZXMvYXBpL2FpcmRyb3AuanM/Njc1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IENvbm5lY3Rpb24sIExBTVBPUlRTX1BFUl9TT0wgfSA9IHJlcXVpcmUoXCJAc29sYW5hL3dlYjMuanNcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpLnByb21pc2VzO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xyXG5jb25zdCB7IGluaXRpYWxpemVLZXlwYWlyLCBjbGFpbUZlZXNGb3JUb2tlbiwgZmV0Y2hUb2tlbkhvbGRlcnMsIHZhbGlkYXRlTWFpbm5ldEFkZHJlc3MsIHNlbmRBaXJkcm9wIH0gPSByZXF1aXJlKFwiLi4vLi4vbGliL3NvbGFuYVwiKTtcclxuY29uc3QgeyBhcHBlbmRUb0V4Y2VsIH0gPSByZXF1aXJlKFwiLi4vLi4vbGliL2V4Y2VsXCIpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcykge1xyXG4gIGlmIChyZXEubWV0aG9kICE9PSBcIlBPU1RcIikge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgZXJyb3I6IFwiTWV0aG9kIG5vdCBhbGxvd2VkXCIgfSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oXCJodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbVwiLCBcImNvbmZpcm1lZFwiKTtcclxuICBsZXQga2V5cGFpcjtcclxuICB0cnkge1xyXG4gICAga2V5cGFpciA9IGF3YWl0IGluaXRpYWxpemVLZXlwYWlyKCk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgSW52YWxpZCBzZWNyZXQga2V5OiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogYEludmFsaWQgc2VjcmV0IGtleTogJHtlcnJvci5tZXNzYWdlfWAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBmdW5jdGlvbiBsb2dUb0ZpbGUobWVzc2FnZSwgbG9nRmlsZSA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgXCJhaXJkcm9wX2xvZy50eHRcIikpIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9ULywgXCIgXCIpLnJlcGxhY2UoL1xcLi4rLywgXCJcIik7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBmcy5hcHBlbmRGaWxlKGxvZ0ZpbGUsIGBbJHt0aW1lc3RhbXB9XSAke21lc3NhZ2V9XFxuYCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHdyaXRlIHRvIGxvZyBmaWxlICR7bG9nRmlsZX06ICR7ZXJyLm1lc3NhZ2V9YCk7XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBsb2dUb0ZpbGUoYFN0YXJ0aW5nIGFpcmRyb3AgY3ljbGUgKGhvbGRlciBzY3JhcGluZyBvbiBtYWlubmV0LCBhaXJkcm9wIG9uIGRldm5ldCkuIFRlbXAgZGlyZWN0b3J5OiAke29zLnRtcGRpcigpfWApO1xyXG4gICAgY29uc3QgY2xhaW1lZFNvbCA9IGF3YWl0IGNsYWltRmVlc0ZvclRva2VuKHByb2Nlc3MuZW52LlRPS0VOX01JTlRfQUREUkVTUywgY29ubmVjdGlvbiwga2V5cGFpciwgbG9nVG9GaWxlKTtcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShcIkZldGNoaW5nIHRva2VuIGhvbGRlcnMgZnJvbSBtYWlubmV0Li4uXCIpO1xyXG4gICAgY29uc3QgaG9sZGVycyA9IGF3YWl0IGZldGNoVG9rZW5Ib2xkZXJzKHByb2Nlc3MuZW52LlRPS0VOX01JTlRfQUREUkVTUywgbG9nVG9GaWxlKTtcclxuICAgIGNvbnN0IHF1YWxpZmllZEhvbGRlcnMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgaG9sZGVyIG9mIGhvbGRlcnMpIHtcclxuICAgICAgaWYgKGF3YWl0IHZhbGlkYXRlTWFpbm5ldEFkZHJlc3MoY29ubmVjdGlvbiwgaG9sZGVyLmhvbGRlcl9hZGRyZXNzLCBsb2dUb0ZpbGUpKSB7XHJcbiAgICAgICAgcXVhbGlmaWVkSG9sZGVycy5wdXNoKGhvbGRlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBbXHJcbiAgICAgIGBUb2tlbiBIb2xkZXJzIGZvciBNaW50OiAke3Byb2Nlc3MuZW52LlRPS0VOX01JTlRfQUREUkVTU30gKGZldGNoZWQgZnJvbSBtYWlubmV0KWAsXHJcbiAgICAgIGBUb3RhbCBIb2xkZXJzOiAke2hvbGRlcnMubGVuZ3RofWAsXHJcbiAgICAgIGBRdWFsaWZpZWQgSG9sZGVycyAob24gZGV2bmV0KTogJHtxdWFsaWZpZWRIb2xkZXJzLmxlbmd0aH1gLFxyXG4gICAgICBcIi1cIi5yZXBlYXQoNTApLFxyXG4gICAgICAuLi5ob2xkZXJzLm1hcChcclxuICAgICAgICAoaG9sZGVyKSA9PiBgSG9sZGVyOiAke2hvbGRlci5ob2xkZXJfYWRkcmVzc30sIEJhbGFuY2U6ICR7aG9sZGVyLmJhbGFuY2V9LCBUb2tlbiBBY2NvdW50OiAke2hvbGRlci50b2tlbl9hY2NvdW50fSwgUXVhbGlmaWVkOiAke3F1YWxpZmllZEhvbGRlcnMuc29tZShxID0+IHEuaG9sZGVyX2FkZHJlc3MgPT09IGhvbGRlci5ob2xkZXJfYWRkcmVzcykgPyBcIlllc1wiIDogXCJOb1wifWBcclxuICAgICAgKSxcclxuICAgIF0uam9pbihcIlxcblwiKTtcclxuICAgIGNvbnN0IGhvbGRlcnNGaWxlUGF0aCA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgXCJ0b2tlbl9ob2xkZXJzLnR4dFwiKTtcclxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShob2xkZXJzRmlsZVBhdGgsIG91dHB1dENvbnRlbnQpO1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBTYXZlZCAke2hvbGRlcnMubGVuZ3RofSB0b2tlbiBob2xkZXJzICgke3F1YWxpZmllZEhvbGRlcnMubGVuZ3RofSBxdWFsaWZpZWQpIHRvICR7aG9sZGVyc0ZpbGVQYXRofWApO1xyXG4gICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QmFsYW5jZShrZXlwYWlyLnB1YmxpY0tleSwgXCJjb25maXJtZWRcIik7XHJcbiAgICBhd2FpdCBsb2dUb0ZpbGUoYERldm5ldCB3YWxsZXQgYmFsYW5jZTogJHtiYWxhbmNlIC8gTEFNUE9SVFNfUEVSX1NPTH0gU09MYCk7XHJcbiAgICBsZXQgYWlyZHJvcHBlZExhbXBvcnRzID0gMDtcclxuICAgIGNvbnN0IE1JTklNVU1fQkFMQU5DRSA9IDAuMiAqIExBTVBPUlRTX1BFUl9TT0w7XHJcbiAgICBpZiAoYmFsYW5jZSA+IE1JTklNVU1fQkFMQU5DRSkge1xyXG4gICAgICBjb25zdCBkaXN0cmlidXRhYmxlTGFtcG9ydHMgPSBNYXRoLmZsb29yKGJhbGFuY2UgLSBNSU5JTVVNX0JBTEFOQ0UpO1xyXG4gICAgICBhd2FpdCBsb2dUb0ZpbGUoYERpc3RyaWJ1dGFibGUgYW1vdW50OiAke2Rpc3RyaWJ1dGFibGVMYW1wb3J0cyAvIExBTVBPUlRTX1BFUl9TT0x9IFNPTGApO1xyXG4gICAgICBjb25zdCBmZWVXYWxsZXRWYWxpZCA9IGF3YWl0IHZhbGlkYXRlTWFpbm5ldEFkZHJlc3MoY29ubmVjdGlvbiwgcHJvY2Vzcy5lbnYuRkVFX1dBTExFVF9BRERSRVNTLCBsb2dUb0ZpbGUpO1xyXG4gICAgICBpZiAoIWZlZVdhbGxldFZhbGlkKSB7XHJcbiAgICAgICAgYXdhaXQgbG9nVG9GaWxlKGBGZWUgd2FsbGV0ICR7cHJvY2Vzcy5lbnYuRkVFX1dBTExFVF9BRERSRVNTfSBkb2VzIG5vdCBleGlzdCBvbiBkZXZuZXRgKTtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogYEZlZSB3YWxsZXQgJHtwcm9jZXNzLmVudi5GRUVfV0FMTEVUX0FERFJFU1N9IGRvZXMgbm90IGV4aXN0IG9uIGRldm5ldGAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZmVlQW1vdW50ID0gTWF0aC5mbG9vcihkaXN0cmlidXRhYmxlTGFtcG9ydHMgKiAwLjEpO1xyXG4gICAgICBsZXQgaG9sZGVyc0Ftb3VudCA9IGRpc3RyaWJ1dGFibGVMYW1wb3J0cyAtIGZlZUFtb3VudDtcclxuICAgICAgY29uc3QgaG9sZGVyc0NvdW50ID0gcXVhbGlmaWVkSG9sZGVycy5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IHJlY2lwaWVudHMgPSBbXTtcclxuICAgICAgbGV0IHdlaWdodHMgPSBbXTtcclxuICAgICAgaWYgKGZlZUFtb3VudCA+IDApIHtcclxuICAgICAgICByZWNpcGllbnRzLnB1c2goeyBhZGRyZXNzOiBwcm9jZXNzLmVudi5GRUVfV0FMTEVUX0FERFJFU1MsIGFtb3VudDogZmVlQW1vdW50IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChob2xkZXJzQ291bnQgPiAwICYmIGhvbGRlcnNBbW91bnQgPiAwKSB7XHJcbiAgICAgICAgd2VpZ2h0cyA9IHF1YWxpZmllZEhvbGRlcnMubWFwKGhvbGRlciA9PiBNYXRoLmxvZzEwKGhvbGRlci5iYWxhbmNlICsgMSkpO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsV2VpZ2h0ID0gd2VpZ2h0cy5yZWR1Y2UoKHN1bSwgd2VpZ2h0KSA9PiBzdW0gKyB3ZWlnaHQsIDApO1xyXG4gICAgICAgIGlmICh0b3RhbFdlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoXCJObyB2YWxpZCB3ZWlnaHRzIGZvciBob2xkZXJzLCBzZW5kaW5nIGFsbCB0byBmZWUgd2FsbGV0XCIpO1xyXG4gICAgICAgICAgcmVjaXBpZW50c1swXS5hbW91bnQgKz0gaG9sZGVyc0Ftb3VudDtcclxuICAgICAgICAgIGhvbGRlcnNBbW91bnQgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YWxpZmllZEhvbGRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaG9sZGVyID0gcXVhbGlmaWVkSG9sZGVyc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gd2VpZ2h0c1tpXTtcclxuICAgICAgICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5mbG9vcigod2VpZ2h0IC8gdG90YWxXZWlnaHQpICogaG9sZGVyc0Ftb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChhbW91bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgcmVjaXBpZW50cy5wdXNoKHsgYWRkcmVzczogaG9sZGVyLmhvbGRlcl9hZGRyZXNzLCBhbW91bnQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IHRvdGFsSG9sZGVyc0Ftb3VudCA9IHJlY2lwaWVudHMuc2xpY2UoMSkucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuYW1vdW50LCAwKTtcclxuICAgICAgICAgIGlmIChob2xkZXJzQW1vdW50ID4gdG90YWxIb2xkZXJzQW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJlY2lwaWVudHNbMF0uYW1vdW50ICs9IGhvbGRlcnNBbW91bnQgLSB0b3RhbEhvbGRlcnNBbW91bnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGhvbGRlcnNBbW91bnQgPiAwKSB7XHJcbiAgICAgICAgcmVjaXBpZW50c1swXS5hbW91bnQgKz0gaG9sZGVyc0Ftb3VudDtcclxuICAgICAgICBob2xkZXJzQW1vdW50ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkaXN0cmlidXRpb25Db250ZW50ID0gW1xyXG4gICAgICAgIFwiXFxuQWlyZHJvcCBEaXN0cmlidXRpb24gKG9uIGRldm5ldCwgMTAlIGZlZSB3YWxsZXQsIDkwJSBob2xkZXJzIHdpdGggbG9nYXJpdGhtaWMgd2VpZ2h0aW5nKVwiLFxyXG4gICAgICAgIFwiLVwiLnJlcGVhdCg1MCksXHJcbiAgICAgICAgYEZlZSBXYWxsZXQgKCR7cHJvY2Vzcy5lbnYuRkVFX1dBTExFVF9BRERSRVNTfSk6ICR7KHJlY2lwaWVudHMuZmluZChyID0+IHIuYWRkcmVzcyA9PT0gcHJvY2Vzcy5lbnYuRkVFX1dBTExFVF9BRERSRVNTKT8uYW1vdW50IHx8IDApIC8gTEFNUE9SVFNfUEVSX1NPTH0gU09MYCxcclxuICAgICAgICAuLi5xdWFsaWZpZWRIb2xkZXJzLm1hcChcclxuICAgICAgICAgIChob2xkZXIsIGkpID0+IGBIb2xkZXIgKCR7aG9sZGVyLmhvbGRlcl9hZGRyZXNzfSk6ICR7KHJlY2lwaWVudHMuZmluZChyID0+IHIuYWRkcmVzcyA9PT0gaG9sZGVyLmhvbGRlcl9hZGRyZXNzKT8uYW1vdW50IHx8IDApIC8gTEFNUE9SVFNfUEVSX1NPTH0gU09MIChXZWlnaHQ6ICR7KHdlaWdodHNbaV0gfHwgMCkudG9GaXhlZCg0KX0pYFxyXG4gICAgICAgICksXHJcbiAgICAgIF0uam9pbihcIlxcblwiKTtcclxuICAgICAgYXdhaXQgZnMuYXBwZW5kRmlsZShob2xkZXJzRmlsZVBhdGgsIGRpc3RyaWJ1dGlvbkNvbnRlbnQpO1xyXG4gICAgICBhd2FpdCBsb2dUb0ZpbGUoZGlzdHJpYnV0aW9uQ29udGVudCk7XHJcbiAgICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBhaXJkcm9wcGVkTGFtcG9ydHMgPSBhd2FpdCBzZW5kQWlyZHJvcChjb25uZWN0aW9uLCBrZXlwYWlyLCByZWNpcGllbnRzLCBsb2dUb0ZpbGUpO1xyXG4gICAgICAgIGlmIChhaXJkcm9wcGVkTGFtcG9ydHMgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoXCJBaXJkcm9wIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgb24gZGV2bmV0XCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoXCJBaXJkcm9wIGZhaWxlZCBvbiBkZXZuZXQsIHNlZSBsb2dzIGZvciBkZXRhaWxzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoXCJObyB2YWxpZCByZWNpcGllbnRzLCBza2lwcGluZyBhaXJkcm9wIG9uIGRldm5ldFwiKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXdhaXQgbG9nVG9GaWxlKFwiRGV2bmV0IHdhbGxldCBiYWxhbmNlIDw9IDAuMiBTT0wsIHNraXBwaW5nIGFpcmRyb3BcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhaXJkcm9wcGVkU29sID0gYWlyZHJvcHBlZExhbXBvcnRzIC8gTEFNUE9SVFNfUEVSX1NPTDtcclxuICAgIGF3YWl0IGFwcGVuZFRvRXhjZWwobmV3IERhdGUoKSwgY2xhaW1lZFNvbCwgYWlyZHJvcHBlZFNvbCk7XHJcbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih7IG1lc3NhZ2U6IFwiQWlyZHJvcCBjeWNsZSBjb21wbGV0ZWRcIiwgY2xhaW1lZFNvbCwgYWlyZHJvcHBlZFNvbCB9KTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBFcnJvciBpbiBhaXJkcm9wIGxvb3A6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6IGBFcnJvciBpbiBhaXJkcm9wIGxvb3A6ICR7ZXJyb3IubWVzc2FnZX1gIH0pO1xyXG4gIH1cclxufSJdLCJuYW1lcyI6WyJDb25uZWN0aW9uIiwiTEFNUE9SVFNfUEVSX1NPTCIsInJlcXVpcmUiLCJmcyIsInByb21pc2VzIiwicGF0aCIsIm9zIiwiaW5pdGlhbGl6ZUtleXBhaXIiLCJjbGFpbUZlZXNGb3JUb2tlbiIsImZldGNoVG9rZW5Ib2xkZXJzIiwidmFsaWRhdGVNYWlubmV0QWRkcmVzcyIsInNlbmRBaXJkcm9wIiwiYXBwZW5kVG9FeGNlbCIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJjb25uZWN0aW9uIiwia2V5cGFpciIsImxvZ1RvRmlsZSIsIm1lc3NhZ2UiLCJsb2dGaWxlIiwiam9pbiIsInRtcGRpciIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJhcHBlbmRGaWxlIiwiZXJyIiwiY29uc29sZSIsImNsYWltZWRTb2wiLCJwcm9jZXNzIiwiZW52IiwiVE9LRU5fTUlOVF9BRERSRVNTIiwiaG9sZGVycyIsInF1YWxpZmllZEhvbGRlcnMiLCJob2xkZXIiLCJob2xkZXJfYWRkcmVzcyIsInB1c2giLCJvdXRwdXRDb250ZW50IiwibGVuZ3RoIiwicmVwZWF0IiwibWFwIiwiYmFsYW5jZSIsInRva2VuX2FjY291bnQiLCJzb21lIiwicSIsImhvbGRlcnNGaWxlUGF0aCIsIndyaXRlRmlsZSIsImdldEJhbGFuY2UiLCJwdWJsaWNLZXkiLCJhaXJkcm9wcGVkTGFtcG9ydHMiLCJNSU5JTVVNX0JBTEFOQ0UiLCJkaXN0cmlidXRhYmxlTGFtcG9ydHMiLCJNYXRoIiwiZmxvb3IiLCJmZWVXYWxsZXRWYWxpZCIsIkZFRV9XQUxMRVRfQUREUkVTUyIsImZlZUFtb3VudCIsImhvbGRlcnNBbW91bnQiLCJob2xkZXJzQ291bnQiLCJyZWNpcGllbnRzIiwid2VpZ2h0cyIsImFkZHJlc3MiLCJhbW91bnQiLCJsb2cxMCIsInRvdGFsV2VpZ2h0IiwicmVkdWNlIiwic3VtIiwid2VpZ2h0IiwiaSIsInRvdGFsSG9sZGVyc0Ftb3VudCIsInNsaWNlIiwiciIsImRpc3RyaWJ1dGlvbkNvbnRlbnQiLCJmaW5kIiwidG9GaXhlZCIsImFpcmRyb3BwZWRTb2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/airdrop.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fairdrop&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cairdrop.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();