"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/airdrop";
exports.ids = ["pages/api/airdrop"];
exports.modules = {

/***/ "@solana/web3.js":
/*!**********************************!*\
  !*** external "@solana/web3.js" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("@solana/web3.js");

/***/ }),

/***/ "aws-sdk":
/*!**************************!*\
  !*** external "aws-sdk" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("aws-sdk");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

module.exports = require("axios");

/***/ }),

/***/ "bs58":
/*!***********************!*\
  !*** external "bs58" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("bs58");

/***/ }),

/***/ "exceljs":
/*!**************************!*\
  !*** external "exceljs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("exceljs");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "pusher":
/*!*************************!*\
  !*** external "pusher" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("pusher");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fairdrop&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cairdrop.js&middlewareConfigBase64=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fairdrop&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cairdrop.js&middlewareConfigBase64=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_airdrop_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\airdrop.js */ \"(api)/./pages/api/airdrop.js\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_airdrop_js__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_airdrop_js__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/airdrop\",\n        pathname: \"/api/airdrop\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_airdrop_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmFpcmRyb3AmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyU1Q2FwaSU1Q2FpcmRyb3AuanMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDcUQ7QUFDckQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLGtEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxrREFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haXJkcm9wLWRhc2hib2FyZC8/OTI5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXNcXFxcYXBpXFxcXGFpcmRyb3AuanNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9haXJkcm9wXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvYWlyZHJvcFwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fairdrop&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cairdrop.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./lib/excel.js":
/*!**********************!*\
  !*** ./lib/excel.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst ExcelJS = __webpack_require__(/*! exceljs */ \"exceljs\");\nconst fs = (__webpack_require__(/*! fs */ \"fs\").promises);\nconst path = __webpack_require__(/*! path */ \"path\");\nconst AWS = __webpack_require__(/*! aws-sdk */ \"aws-sdk\");\nconst s3 = new AWS.S3({\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    region: process.env.AWS_REGION\n});\nasync function appendToExcel(date, claimed, airdropped) {\n    const workbook = new ExcelJS.Workbook();\n    const filePath = path.join(process.cwd(), \"dashboard_data.xlsx\");\n    const s3Key = \"dashboard_data.xlsx\";\n    try {\n        // Download from S3 if exists\n        try {\n            const s3Data = await s3.getObject({\n                Bucket: process.env.AWS_S3_BUCKET,\n                Key: s3Key\n            }).promise();\n            await fs.writeFile(filePath, s3Data.Body);\n            await workbook.xlsx.readFile(filePath);\n        } catch (error) {\n            if (error.code !== \"NoSuchKey\") {\n                throw new Error(`Error downloading from S3: ${error.message}`);\n            }\n        }\n        let sheet = workbook.getWorksheet(\"Data\");\n        if (!sheet) {\n            sheet = workbook.addWorksheet(\"Data\");\n            sheet.addRow([\n                \"Date\",\n                \"Fees Claimed (SOL)\",\n                \"Airdrops Sent (SOL)\"\n            ]);\n        }\n        sheet.addRow([\n            date.toISOString(),\n            claimed,\n            airdropped\n        ]);\n        await workbook.xlsx.writeFile(filePath);\n        // Upload to S3\n        const fileContent = await fs.readFile(filePath);\n        await s3.upload({\n            Bucket: process.env.AWS_S3_BUCKET,\n            Key: s3Key,\n            Body: fileContent,\n            ContentType: \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n        }).promise();\n    } catch (error) {\n        throw new Error(`Error writing to Excel: ${error.message}`);\n    }\n}\nasync function readExcelData() {\n    const filePath = path.join(process.cwd(), \"dashboard_data.xlsx\");\n    const s3Key = \"dashboard_data.xlsx\";\n    try {\n        // Download from S3 if exists\n        try {\n            const s3Data = await s3.getObject({\n                Bucket: process.env.AWS_S3_BUCKET,\n                Key: s3Key\n            }).promise();\n            await fs.writeFile(filePath, s3Data.Body);\n        } catch (error) {\n            if (error.code !== \"NoSuchKey\") {\n                throw new Error(`Error downloading from S3: ${error.message}`);\n            }\n            return {\n                data: [],\n                totalClaimed: 0,\n                totalAirdropped: 0,\n                lastUpdated: null\n            };\n        }\n        const workbook = new ExcelJS.Workbook();\n        await workbook.xlsx.readFile(filePath);\n        const sheet = workbook.getWorksheet(\"Data\");\n        if (!sheet) {\n            return {\n                data: [],\n                totalClaimed: 0,\n                totalAirdropped: 0,\n                lastUpdated: null\n            };\n        }\n        const data = [];\n        let totalClaimed = 0;\n        let totalAirdropped = 0;\n        let lastUpdated = null;\n        sheet.eachRow((row, rowNumber)=>{\n            if (rowNumber === 1) return; // Skip header\n            const rowData = {\n                Date: row.getCell(1).value,\n                \"Fees Claimed (SOL)\": row.getCell(2).value || 0,\n                \"Airdrops Sent (SOL)\": row.getCell(3).value || 0\n            };\n            totalClaimed += rowData[\"Fees Claimed (SOL)\"];\n            totalAirdropped += rowData[\"Airdrops Sent (SOL)\"];\n            if (!lastUpdated || new Date(rowData.Date) > new Date(lastUpdated)) {\n                lastUpdated = rowData.Date;\n            }\n            data.push(rowData);\n        });\n        return {\n            data,\n            totalClaimed,\n            totalAirdropped,\n            lastUpdated\n        };\n    } catch (error) {\n        throw new Error(`Error reading dashboard data: ${error.message}`);\n    }\n}\nmodule.exports = {\n    appendToExcel,\n    readExcelData\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9saWIvZXhjZWwuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDLHdCQUFTO0FBQ2pDLE1BQU1DLEtBQUtELDhDQUFzQjtBQUNqQyxNQUFNRyxPQUFPSCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNSSxNQUFNSixtQkFBT0EsQ0FBQyx3QkFBUztBQUU3QixNQUFNSyxLQUFLLElBQUlELElBQUlFLEVBQUUsQ0FBQztJQUNwQkMsYUFBYUMsUUFBUUMsR0FBRyxDQUFDQyxpQkFBaUI7SUFDMUNDLGlCQUFpQkgsUUFBUUMsR0FBRyxDQUFDRyxxQkFBcUI7SUFDbERDLFFBQVFMLFFBQVFDLEdBQUcsQ0FBQ0ssVUFBVTtBQUNoQztBQUVBLGVBQWVDLGNBQWNDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxVQUFVO0lBQ3BELE1BQU1DLFdBQVcsSUFBSXBCLFFBQVFxQixRQUFRO0lBQ3JDLE1BQU1DLFdBQVdsQixLQUFLbUIsSUFBSSxDQUFDZCxRQUFRZSxHQUFHLElBQUk7SUFDMUMsTUFBTUMsUUFBUTtJQUVkLElBQUk7UUFDRiw2QkFBNkI7UUFDN0IsSUFBSTtZQUNGLE1BQU1DLFNBQVMsTUFBTXBCLEdBQUdxQixTQUFTLENBQUM7Z0JBQUVDLFFBQVFuQixRQUFRQyxHQUFHLENBQUNtQixhQUFhO2dCQUFFQyxLQUFLTDtZQUFNLEdBQUdNLE9BQU87WUFDNUYsTUFBTTdCLEdBQUc4QixTQUFTLENBQUNWLFVBQVVJLE9BQU9PLElBQUk7WUFDeEMsTUFBTWIsU0FBU2MsSUFBSSxDQUFDQyxRQUFRLENBQUNiO1FBQy9CLEVBQUUsT0FBT2MsT0FBTztZQUNkLElBQUlBLE1BQU1DLElBQUksS0FBSyxhQUFhO2dCQUM5QixNQUFNLElBQUlDLE1BQU0sQ0FBQywyQkFBMkIsRUFBRUYsTUFBTUcsT0FBTyxDQUFDLENBQUM7WUFDL0Q7UUFDRjtRQUVBLElBQUlDLFFBQVFwQixTQUFTcUIsWUFBWSxDQUFDO1FBQ2xDLElBQUksQ0FBQ0QsT0FBTztZQUNWQSxRQUFRcEIsU0FBU3NCLFlBQVksQ0FBQztZQUM5QkYsTUFBTUcsTUFBTSxDQUFDO2dCQUFDO2dCQUFRO2dCQUFzQjthQUFzQjtRQUNwRTtRQUNBSCxNQUFNRyxNQUFNLENBQUM7WUFBQzFCLEtBQUsyQixXQUFXO1lBQUkxQjtZQUFTQztTQUFXO1FBQ3RELE1BQU1DLFNBQVNjLElBQUksQ0FBQ0YsU0FBUyxDQUFDVjtRQUU5QixlQUFlO1FBQ2YsTUFBTXVCLGNBQWMsTUFBTTNDLEdBQUdpQyxRQUFRLENBQUNiO1FBQ3RDLE1BQU1oQixHQUFHd0MsTUFBTSxDQUFDO1lBQ2RsQixRQUFRbkIsUUFBUUMsR0FBRyxDQUFDbUIsYUFBYTtZQUNqQ0MsS0FBS0w7WUFDTFEsTUFBTVk7WUFDTkUsYUFBYTtRQUNmLEdBQUdoQixPQUFPO0lBQ1osRUFBRSxPQUFPSyxPQUFPO1FBQ2QsTUFBTSxJQUFJRSxNQUFNLENBQUMsd0JBQXdCLEVBQUVGLE1BQU1HLE9BQU8sQ0FBQyxDQUFDO0lBQzVEO0FBQ0Y7QUFFQSxlQUFlUztJQUNiLE1BQU0xQixXQUFXbEIsS0FBS21CLElBQUksQ0FBQ2QsUUFBUWUsR0FBRyxJQUFJO0lBQzFDLE1BQU1DLFFBQVE7SUFFZCxJQUFJO1FBQ0YsNkJBQTZCO1FBQzdCLElBQUk7WUFDRixNQUFNQyxTQUFTLE1BQU1wQixHQUFHcUIsU0FBUyxDQUFDO2dCQUFFQyxRQUFRbkIsUUFBUUMsR0FBRyxDQUFDbUIsYUFBYTtnQkFBRUMsS0FBS0w7WUFBTSxHQUFHTSxPQUFPO1lBQzVGLE1BQU03QixHQUFHOEIsU0FBUyxDQUFDVixVQUFVSSxPQUFPTyxJQUFJO1FBQzFDLEVBQUUsT0FBT0csT0FBTztZQUNkLElBQUlBLE1BQU1DLElBQUksS0FBSyxhQUFhO2dCQUM5QixNQUFNLElBQUlDLE1BQU0sQ0FBQywyQkFBMkIsRUFBRUYsTUFBTUcsT0FBTyxDQUFDLENBQUM7WUFDL0Q7WUFDQSxPQUFPO2dCQUFFVSxNQUFNLEVBQUU7Z0JBQUVDLGNBQWM7Z0JBQUdDLGlCQUFpQjtnQkFBR0MsYUFBYTtZQUFLO1FBQzVFO1FBRUEsTUFBTWhDLFdBQVcsSUFBSXBCLFFBQVFxQixRQUFRO1FBQ3JDLE1BQU1ELFNBQVNjLElBQUksQ0FBQ0MsUUFBUSxDQUFDYjtRQUM3QixNQUFNa0IsUUFBUXBCLFNBQVNxQixZQUFZLENBQUM7UUFDcEMsSUFBSSxDQUFDRCxPQUFPO1lBQ1YsT0FBTztnQkFBRVMsTUFBTSxFQUFFO2dCQUFFQyxjQUFjO2dCQUFHQyxpQkFBaUI7Z0JBQUdDLGFBQWE7WUFBSztRQUM1RTtRQUNBLE1BQU1ILE9BQU8sRUFBRTtRQUNmLElBQUlDLGVBQWU7UUFDbkIsSUFBSUMsa0JBQWtCO1FBQ3RCLElBQUlDLGNBQWM7UUFDbEJaLE1BQU1hLE9BQU8sQ0FBQyxDQUFDQyxLQUFLQztZQUNsQixJQUFJQSxjQUFjLEdBQUcsUUFBUSxjQUFjO1lBQzNDLE1BQU1DLFVBQVU7Z0JBQ2RDLE1BQU1ILElBQUlJLE9BQU8sQ0FBQyxHQUFHQyxLQUFLO2dCQUMxQixzQkFBc0JMLElBQUlJLE9BQU8sQ0FBQyxHQUFHQyxLQUFLLElBQUk7Z0JBQzlDLHVCQUF1QkwsSUFBSUksT0FBTyxDQUFDLEdBQUdDLEtBQUssSUFBSTtZQUNqRDtZQUNBVCxnQkFBZ0JNLE9BQU8sQ0FBQyxxQkFBcUI7WUFDN0NMLG1CQUFtQkssT0FBTyxDQUFDLHNCQUFzQjtZQUNqRCxJQUFJLENBQUNKLGVBQWUsSUFBSUssS0FBS0QsUUFBUUMsSUFBSSxJQUFJLElBQUlBLEtBQUtMLGNBQWM7Z0JBQ2xFQSxjQUFjSSxRQUFRQyxJQUFJO1lBQzVCO1lBQ0FSLEtBQUtXLElBQUksQ0FBQ0o7UUFDWjtRQUNBLE9BQU87WUFBRVA7WUFBTUM7WUFBY0M7WUFBaUJDO1FBQVk7SUFDNUQsRUFBRSxPQUFPaEIsT0FBTztRQUNkLE1BQU0sSUFBSUUsTUFBTSxDQUFDLDhCQUE4QixFQUFFRixNQUFNRyxPQUFPLENBQUMsQ0FBQztJQUNsRTtBQUNGO0FBRUFzQixPQUFPQyxPQUFPLEdBQUc7SUFDZjlDO0lBQ0FnQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlyZHJvcC1kYXNoYm9hcmQvLi9saWIvZXhjZWwuanM/MDZkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFeGNlbEpTID0gcmVxdWlyZShcImV4Y2VsanNcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpLnByb21pc2VzO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IEFXUyA9IHJlcXVpcmUoXCJhd3Mtc2RrXCIpO1xyXG5cclxuY29uc3QgczMgPSBuZXcgQVdTLlMzKHtcclxuICBhY2Nlc3NLZXlJZDogcHJvY2Vzcy5lbnYuQVdTX0FDQ0VTU19LRVlfSUQsXHJcbiAgc2VjcmV0QWNjZXNzS2V5OiBwcm9jZXNzLmVudi5BV1NfU0VDUkVUX0FDQ0VTU19LRVksXHJcbiAgcmVnaW9uOiBwcm9jZXNzLmVudi5BV1NfUkVHSU9OLFxyXG59KTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGFwcGVuZFRvRXhjZWwoZGF0ZSwgY2xhaW1lZCwgYWlyZHJvcHBlZCkge1xyXG4gIGNvbnN0IHdvcmtib29rID0gbmV3IEV4Y2VsSlMuV29ya2Jvb2soKTtcclxuICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCBcImRhc2hib2FyZF9kYXRhLnhsc3hcIik7XHJcbiAgY29uc3QgczNLZXkgPSBcImRhc2hib2FyZF9kYXRhLnhsc3hcIjtcclxuXHJcbiAgdHJ5IHtcclxuICAgIC8vIERvd25sb2FkIGZyb20gUzMgaWYgZXhpc3RzXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzM0RhdGEgPSBhd2FpdCBzMy5nZXRPYmplY3QoeyBCdWNrZXQ6IHByb2Nlc3MuZW52LkFXU19TM19CVUNLRVQsIEtleTogczNLZXkgfSkucHJvbWlzZSgpO1xyXG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIHMzRGF0YS5Cb2R5KTtcclxuICAgICAgYXdhaXQgd29ya2Jvb2sueGxzeC5yZWFkRmlsZShmaWxlUGF0aCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3IuY29kZSAhPT0gXCJOb1N1Y2hLZXlcIikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZG93bmxvYWRpbmcgZnJvbSBTMzogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHNoZWV0ID0gd29ya2Jvb2suZ2V0V29ya3NoZWV0KFwiRGF0YVwiKTtcclxuICAgIGlmICghc2hlZXQpIHtcclxuICAgICAgc2hlZXQgPSB3b3JrYm9vay5hZGRXb3Jrc2hlZXQoXCJEYXRhXCIpO1xyXG4gICAgICBzaGVldC5hZGRSb3coW1wiRGF0ZVwiLCBcIkZlZXMgQ2xhaW1lZCAoU09MKVwiLCBcIkFpcmRyb3BzIFNlbnQgKFNPTClcIl0pO1xyXG4gICAgfVxyXG4gICAgc2hlZXQuYWRkUm93KFtkYXRlLnRvSVNPU3RyaW5nKCksIGNsYWltZWQsIGFpcmRyb3BwZWRdKTtcclxuICAgIGF3YWl0IHdvcmtib29rLnhsc3gud3JpdGVGaWxlKGZpbGVQYXRoKTtcclxuXHJcbiAgICAvLyBVcGxvYWQgdG8gUzNcclxuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgpO1xyXG4gICAgYXdhaXQgczMudXBsb2FkKHtcclxuICAgICAgQnVja2V0OiBwcm9jZXNzLmVudi5BV1NfUzNfQlVDS0VULFxyXG4gICAgICBLZXk6IHMzS2V5LFxyXG4gICAgICBCb2R5OiBmaWxlQ29udGVudCxcclxuICAgICAgQ29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXRcIixcclxuICAgIH0pLnByb21pc2UoKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB3cml0aW5nIHRvIEV4Y2VsOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgfVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiByZWFkRXhjZWxEYXRhKCkge1xyXG4gIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIFwiZGFzaGJvYXJkX2RhdGEueGxzeFwiKTtcclxuICBjb25zdCBzM0tleSA9IFwiZGFzaGJvYXJkX2RhdGEueGxzeFwiO1xyXG5cclxuICB0cnkge1xyXG4gICAgLy8gRG93bmxvYWQgZnJvbSBTMyBpZiBleGlzdHNcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHMzRGF0YSA9IGF3YWl0IHMzLmdldE9iamVjdCh7IEJ1Y2tldDogcHJvY2Vzcy5lbnYuQVdTX1MzX0JVQ0tFVCwgS2V5OiBzM0tleSB9KS5wcm9taXNlKCk7XHJcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlUGF0aCwgczNEYXRhLkJvZHkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yLmNvZGUgIT09IFwiTm9TdWNoS2V5XCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRvd25sb2FkaW5nIGZyb20gUzM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4geyBkYXRhOiBbXSwgdG90YWxDbGFpbWVkOiAwLCB0b3RhbEFpcmRyb3BwZWQ6IDAsIGxhc3RVcGRhdGVkOiBudWxsIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgd29ya2Jvb2sgPSBuZXcgRXhjZWxKUy5Xb3JrYm9vaygpO1xyXG4gICAgYXdhaXQgd29ya2Jvb2sueGxzeC5yZWFkRmlsZShmaWxlUGF0aCk7XHJcbiAgICBjb25zdCBzaGVldCA9IHdvcmtib29rLmdldFdvcmtzaGVldChcIkRhdGFcIik7XHJcbiAgICBpZiAoIXNoZWV0KSB7XHJcbiAgICAgIHJldHVybiB7IGRhdGE6IFtdLCB0b3RhbENsYWltZWQ6IDAsIHRvdGFsQWlyZHJvcHBlZDogMCwgbGFzdFVwZGF0ZWQ6IG51bGwgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGEgPSBbXTtcclxuICAgIGxldCB0b3RhbENsYWltZWQgPSAwO1xyXG4gICAgbGV0IHRvdGFsQWlyZHJvcHBlZCA9IDA7XHJcbiAgICBsZXQgbGFzdFVwZGF0ZWQgPSBudWxsO1xyXG4gICAgc2hlZXQuZWFjaFJvdygocm93LCByb3dOdW1iZXIpID0+IHtcclxuICAgICAgaWYgKHJvd051bWJlciA9PT0gMSkgcmV0dXJuOyAvLyBTa2lwIGhlYWRlclxyXG4gICAgICBjb25zdCByb3dEYXRhID0ge1xyXG4gICAgICAgIERhdGU6IHJvdy5nZXRDZWxsKDEpLnZhbHVlLFxyXG4gICAgICAgIFwiRmVlcyBDbGFpbWVkIChTT0wpXCI6IHJvdy5nZXRDZWxsKDIpLnZhbHVlIHx8IDAsXHJcbiAgICAgICAgXCJBaXJkcm9wcyBTZW50IChTT0wpXCI6IHJvdy5nZXRDZWxsKDMpLnZhbHVlIHx8IDAsXHJcbiAgICAgIH07XHJcbiAgICAgIHRvdGFsQ2xhaW1lZCArPSByb3dEYXRhW1wiRmVlcyBDbGFpbWVkIChTT0wpXCJdO1xyXG4gICAgICB0b3RhbEFpcmRyb3BwZWQgKz0gcm93RGF0YVtcIkFpcmRyb3BzIFNlbnQgKFNPTClcIl07XHJcbiAgICAgIGlmICghbGFzdFVwZGF0ZWQgfHwgbmV3IERhdGUocm93RGF0YS5EYXRlKSA+IG5ldyBEYXRlKGxhc3RVcGRhdGVkKSkge1xyXG4gICAgICAgIGxhc3RVcGRhdGVkID0gcm93RGF0YS5EYXRlO1xyXG4gICAgICB9XHJcbiAgICAgIGRhdGEucHVzaChyb3dEYXRhKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHsgZGF0YSwgdG90YWxDbGFpbWVkLCB0b3RhbEFpcmRyb3BwZWQsIGxhc3RVcGRhdGVkIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcmVhZGluZyBkYXNoYm9hcmQgZGF0YTogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgYXBwZW5kVG9FeGNlbCxcclxuICByZWFkRXhjZWxEYXRhLFxyXG59OyJdLCJuYW1lcyI6WyJFeGNlbEpTIiwicmVxdWlyZSIsImZzIiwicHJvbWlzZXMiLCJwYXRoIiwiQVdTIiwiczMiLCJTMyIsImFjY2Vzc0tleUlkIiwicHJvY2VzcyIsImVudiIsIkFXU19BQ0NFU1NfS0VZX0lEIiwic2VjcmV0QWNjZXNzS2V5IiwiQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZIiwicmVnaW9uIiwiQVdTX1JFR0lPTiIsImFwcGVuZFRvRXhjZWwiLCJkYXRlIiwiY2xhaW1lZCIsImFpcmRyb3BwZWQiLCJ3b3JrYm9vayIsIldvcmtib29rIiwiZmlsZVBhdGgiLCJqb2luIiwiY3dkIiwiczNLZXkiLCJzM0RhdGEiLCJnZXRPYmplY3QiLCJCdWNrZXQiLCJBV1NfUzNfQlVDS0VUIiwiS2V5IiwicHJvbWlzZSIsIndyaXRlRmlsZSIsIkJvZHkiLCJ4bHN4IiwicmVhZEZpbGUiLCJlcnJvciIsImNvZGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJzaGVldCIsImdldFdvcmtzaGVldCIsImFkZFdvcmtzaGVldCIsImFkZFJvdyIsInRvSVNPU3RyaW5nIiwiZmlsZUNvbnRlbnQiLCJ1cGxvYWQiLCJDb250ZW50VHlwZSIsInJlYWRFeGNlbERhdGEiLCJkYXRhIiwidG90YWxDbGFpbWVkIiwidG90YWxBaXJkcm9wcGVkIiwibGFzdFVwZGF0ZWQiLCJlYWNoUm93Iiwicm93Iiwicm93TnVtYmVyIiwicm93RGF0YSIsIkRhdGUiLCJnZXRDZWxsIiwidmFsdWUiLCJwdXNoIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./lib/excel.js\n");

/***/ }),

/***/ "(api)/./lib/solana.js":
/*!***********************!*\
  !*** ./lib/solana.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Connection, Keypair, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL, VersionedTransaction } = __webpack_require__(/*! @solana/web3.js */ \"@solana/web3.js\");\nconst axios = __webpack_require__(/*! axios */ \"axios\");\nconst bs58 = __webpack_require__(/*! bs58 */ \"bs58\");\nasync function initializeKeypair() {\n    try {\n        try {\n            const secretKeyArray = JSON.parse(process.env.PRIVATE_KEY);\n            const secretKeyBytes = Uint8Array.from(secretKeyArray);\n            if (secretKeyBytes.length !== 64) {\n                throw new Error(`Secret key must be 64 bytes, got ${secretKeyBytes.length}`);\n            }\n            return Keypair.fromSecretKey(secretKeyBytes);\n        } catch (jsonError) {\n            try {\n                const secretKeyBytes = bs58.decode(process.env.PRIVATE_KEY);\n                if (secretKeyBytes.length !== 64) {\n                    throw new Error(`Base58 secret key must decode to 64 bytes, got ${secretKeyBytes.length}`);\n                }\n                return Keypair.fromSecretKey(secretKeyBytes);\n            } catch (bs58Error) {\n                throw new Error(`Invalid private key format: JSON error (${jsonError.message}), Base58 error (${bs58Error.message})`);\n            }\n        }\n    } catch (error) {\n        throw new Error(`Invalid secret key: ${error.message}`);\n    }\n}\nasync function claimFeesForToken(tokenMint, connection, keypair, logToFile) {\n    try {\n        await logToFile(`Claiming fees for token ${tokenMint} with wallet ${keypair.publicKey.toBase58()} on devnet`);\n        const initialBalance = await connection.getBalance(keypair.publicKey, \"confirmed\");\n        const response = await axios.post(\"https://pumpportal.fun/api/trade-local\", {\n            publicKey: keypair.publicKey.toBase58(),\n            action: \"collectCreatorFee\",\n            priorityFee: 0.000001\n        });\n        const messageBytes = Buffer.from(response.data, \"base64\");\n        const message = VersionedTransaction.deserialize(messageBytes).message;\n        const tx = new VersionedTransaction(message);\n        tx.sign([\n            keypair\n        ]);\n        const signature = await connection.sendTransaction(tx, {\n            preflightCommitment: \"confirmed\"\n        });\n        await connection.confirmTransaction(signature, \"confirmed\");\n        const finalBalance = await connection.getBalance(keypair.publicKey, \"confirmed\");\n        const txDetails = await connection.getTransaction(signature, {\n            commitment: \"confirmed\",\n            maxSupportedTransactionVersion: 0\n        });\n        const txFee = txDetails.meta.fee;\n        const claimedLamports = finalBalance - initialBalance + txFee;\n        const claimedSol = claimedLamports / LAMPORTS_PER_SOL;\n        await logToFile(`Transaction confirmed: https://solscan.io/tx/${signature}?cluster=devnet`);\n        await logToFile(`Claimed ${claimedSol.toFixed(6)} SOL on devnet`);\n        return claimedSol;\n    } catch (error) {\n        await logToFile(`Unexpected error in claimFeesForToken on devnet: ${error.message}`);\n        return 0;\n    }\n}\nasync function getTokenDecimals(mintAddress, logToFile) {\n    const url = process.env.HELIUS_RPC_URL;\n    const payload = {\n        jsonrpc: \"2.0\",\n        id: \"get-account-info\",\n        method: \"getAccountInfo\",\n        params: [\n            mintAddress,\n            {\n                encoding: \"jsonParsed\"\n            }\n        ]\n    };\n    try {\n        const response = await axios.post(url, payload);\n        if (!response.data.result?.value) {\n            throw new Error(`No account info found for mint ${mintAddress} on mainnet`);\n        }\n        const decimals = response.data.result.value.data.parsed.info.decimals;\n        await logToFile(`Fetched decimals: ${decimals} for mint ${mintAddress} on mainnet`);\n        return decimals;\n    } catch (error) {\n        await logToFile(`Failed to fetch decimals for mint ${mintAddress} on mainnet: ${error.message}`);\n        throw error;\n    }\n}\nasync function fetchTokenHolders(tokenMintAddress, logToFile) {\n    const url = process.env.HELIUS_RPC_URL;\n    const decimals = await getTokenDecimals(tokenMintAddress, logToFile);\n    await logToFile(`Token decimals: ${decimals}`);\n    let page = 1;\n    const allHolders = [];\n    while(true){\n        const payload = {\n            jsonrpc: \"2.0\",\n            id: \"helius-test\",\n            method: \"getTokenAccounts\",\n            params: {\n                page: page,\n                limit: 1000,\n                mint: tokenMintAddress,\n                displayOptions: {}\n            }\n        };\n        try {\n            const response = await axios.post(url, payload);\n            if (response.status !== 200) {\n                const errorMsg = `Error fetching holders from mainnet: ${response.status}, ${response.statusText}`;\n                await logToFile(errorMsg);\n                break;\n            }\n            const data = response.data;\n            if (!data.result?.token_accounts?.length) {\n                const msg = `No more results from mainnet. Total pages processed: ${page - 1}`;\n                await logToFile(msg);\n                break;\n            }\n            await logToFile(`Processing page ${page} with ${data.result.token_accounts.length} accounts from mainnet`);\n            for (const account of data.result.token_accounts){\n                if (account.amount > 0) {\n                    const balance = account.amount / Math.pow(10, decimals);\n                    allHolders.push({\n                        holder_address: account.owner,\n                        balance: balance,\n                        token_account: account.address\n                    });\n                }\n            }\n            page++;\n        } catch (error) {\n            const errorMsg = `Error fetching page ${page} from mainnet: ${error.message}`;\n            await logToFile(errorMsg);\n            break;\n        }\n    }\n    return allHolders;\n}\nasync function validateMainnetAddress(connection, address, logToFile) {\n    try {\n        const pubkey = new PublicKey(address);\n        const accountInfo = await connection.getAccountInfo(pubkey, \"confirmed\");\n        const exists = !!accountInfo;\n        await logToFile(`Validated address ${address} on devnet: ${exists ? \"Exists\" : \"Does not exist\"}`);\n        return exists;\n    } catch (error) {\n        await logToFile(`Error validating address ${address} on devnet: ${error.message}`);\n        return false;\n    }\n}\nasync function sendAirdrop(connection, keypair, recipients, logToFile) {\n    const senderPubkey = keypair.publicKey;\n    const TRANSACTION_FEE = 5000;\n    const totalAmount = recipients.reduce((sum, { amount })=>sum + amount, 0);\n    const balance = await connection.getBalance(senderPubkey, \"confirmed\");\n    if (balance < totalAmount + TRANSACTION_FEE * recipients.length) {\n        const errorMsg = `Insufficient funds on devnet. Have: ${balance / LAMPORTS_PER_SOL} SOL, Need: ${(totalAmount + TRANSACTION_FEE * recipients.length) / LAMPORTS_PER_SOL} SOL`;\n        await logToFile(errorMsg);\n        return 0;\n    }\n    let totalSentLamports = 0;\n    for (const { address, amount } of recipients){\n        if (amount <= 0) {\n            await logToFile(`Skipping zero or negative amount for ${address}`);\n            continue;\n        }\n        try {\n            await logToFile(`Preparing to send ${amount / LAMPORTS_PER_SOL} SOL from ${senderPubkey} to ${address} on devnet`);\n            let success = false;\n            for(let attempt = 1; attempt <= 3; attempt++){\n                try {\n                    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash(\"confirmed\");\n                    const transaction = new Transaction({\n                        recentBlockhash: blockhash,\n                        feePayer: senderPubkey\n                    }).add(SystemProgram.transfer({\n                        fromPubkey: senderPubkey,\n                        toPubkey: new PublicKey(address),\n                        lamports: Math.floor(amount)\n                    }));\n                    const signature = await connection.sendTransaction(transaction, [\n                        keypair\n                    ], {\n                        skipPreflight: false\n                    });\n                    await logToFile(`Transaction sent with signature: ${signature} to ${address} on devnet`);\n                    const confirmation = await connection.confirmTransaction({\n                        signature,\n                        blockhash,\n                        lastValidBlockHeight\n                    }, \"confirmed\");\n                    if (confirmation.value.err) {\n                        throw new Error(`Transaction failed: ${confirmation.value.err}`);\n                    }\n                    await logToFile(`Airdrop successful! Sent ${amount / LAMPORTS_PER_SOL} SOL to ${address} on devnet`);\n                    success = true;\n                    break;\n                } catch (error) {\n                    await logToFile(`Error on attempt ${attempt} for ${address} on devnet: ${error.message}`);\n                    await new Promise((resolve)=>setTimeout(resolve, 3000));\n                }\n            }\n            if (success) {\n                totalSentLamports += amount;\n            }\n        } catch (error) {\n            await logToFile(`Critical error sending to ${address} on devnet: ${error.message}`);\n        }\n    }\n    return totalSentLamports;\n}\nmodule.exports = {\n    initializeKeypair,\n    claimFeesForToken,\n    fetchTokenHolders,\n    validateMainnetAddress,\n    sendAirdrop\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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VUFBVSxDQUFDLGlDQUFpQyxFQUFFZSxVQUFVLElBQUksRUFBRW1ELFFBQVEsVUFBVSxDQUFDO29CQUN2RixNQUFNNkIsZUFBZSxNQUFNakcsV0FBV29CLGtCQUFrQixDQUN0RDt3QkFBRUg7d0JBQVdtRTt3QkFBV0M7b0JBQXFCLEdBQzdDO29CQUVGLElBQUlZLGFBQWF0RCxLQUFLLENBQUN1RCxHQUFHLEVBQUU7d0JBQzFCLE1BQU0sSUFBSTNHLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRTBHLGFBQWF0RCxLQUFLLENBQUN1RCxHQUFHLENBQUMsQ0FBQztvQkFDakU7b0JBQ0EsTUFBTWhHLFVBQVUsQ0FBQyx5QkFBeUIsRUFBRTBELFNBQVNyRixpQkFBaUIsUUFBUSxFQUFFNkYsUUFBUSxVQUFVLENBQUM7b0JBQ25HYyxVQUFVO29CQUNWO2dCQUNGLEVBQUUsT0FBT3JGLE9BQU87b0JBQ2QsTUFBTUssVUFBVSxDQUFDLGlCQUFpQixFQUFFaUYsUUFBUSxLQUFLLEVBQUVmLFFBQVEsWUFBWSxFQUFFdkUsTUFBTUQsT0FBTyxDQUFDLENBQUM7b0JBQ3hGLE1BQU0sSUFBSXVHLFFBQVEsQ0FBQ0MsVUFBWUMsV0FBV0QsU0FBUztnQkFDckQ7WUFDRjtZQUNBLElBQUlsQixTQUFTO2dCQUNYRCxxQkFBcUJyQjtZQUN2QjtRQUNGLEVBQUUsT0FBTy9ELE9BQU87WUFDZCxNQUFNSyxVQUFVLENBQUMsMEJBQTBCLEVBQUVrRSxRQUFRLFlBQVksRUFBRXZFLE1BQU1ELE9BQU8sQ0FBQyxDQUFDO1FBQ3BGO0lBQ0Y7SUFDQSxPQUFPcUY7QUFDVDtBQUVBcUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2YzSDtJQUNBa0I7SUFDQWlEO0lBQ0FzQjtJQUNBSztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWlyZHJvcC1kYXNoYm9hcmQvLi9saWIvc29sYW5hLmpzPzQ3MGYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBDb25uZWN0aW9uLCBLZXlwYWlyLCBQdWJsaWNLZXksIFRyYW5zYWN0aW9uLCBTeXN0ZW1Qcm9ncmFtLCBMQU1QT1JUU19QRVJfU09MLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiB9ID0gcmVxdWlyZShcIkBzb2xhbmEvd2ViMy5qc1wiKTtcclxuY29uc3QgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XHJcbmNvbnN0IGJzNTggPSByZXF1aXJlKFwiYnM1OFwiKTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVLZXlwYWlyKCkge1xyXG4gIHRyeSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzZWNyZXRLZXlBcnJheSA9IEpTT04ucGFyc2UocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpO1xyXG4gICAgICBjb25zdCBzZWNyZXRLZXlCeXRlcyA9IFVpbnQ4QXJyYXkuZnJvbShzZWNyZXRLZXlBcnJheSk7XHJcbiAgICAgIGlmIChzZWNyZXRLZXlCeXRlcy5sZW5ndGggIT09IDY0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZWNyZXQga2V5IG11c3QgYmUgNjQgYnl0ZXMsIGdvdCAke3NlY3JldEtleUJ5dGVzLmxlbmd0aH1gKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gS2V5cGFpci5mcm9tU2VjcmV0S2V5KHNlY3JldEtleUJ5dGVzKTtcclxuICAgIH0gY2F0Y2ggKGpzb25FcnJvcikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHNlY3JldEtleUJ5dGVzID0gYnM1OC5kZWNvZGUocHJvY2Vzcy5lbnYuUFJJVkFURV9LRVkpO1xyXG4gICAgICAgIGlmIChzZWNyZXRLZXlCeXRlcy5sZW5ndGggIT09IDY0KSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhc2U1OCBzZWNyZXQga2V5IG11c3QgZGVjb2RlIHRvIDY0IGJ5dGVzLCBnb3QgJHtzZWNyZXRLZXlCeXRlcy5sZW5ndGh9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBLZXlwYWlyLmZyb21TZWNyZXRLZXkoc2VjcmV0S2V5Qnl0ZXMpO1xyXG4gICAgICB9IGNhdGNoIChiczU4RXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJpdmF0ZSBrZXkgZm9ybWF0OiBKU09OIGVycm9yICgke2pzb25FcnJvci5tZXNzYWdlfSksIEJhc2U1OCBlcnJvciAoJHticzU4RXJyb3IubWVzc2FnZX0pYCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlY3JldCBrZXk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGNsYWltRmVlc0ZvclRva2VuKHRva2VuTWludCwgY29ubmVjdGlvbiwga2V5cGFpciwgbG9nVG9GaWxlKSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgQ2xhaW1pbmcgZmVlcyBmb3IgdG9rZW4gJHt0b2tlbk1pbnR9IHdpdGggd2FsbGV0ICR7a2V5cGFpci5wdWJsaWNLZXkudG9CYXNlNTgoKX0gb24gZGV2bmV0YCk7XHJcbiAgICBjb25zdCBpbml0aWFsQmFsYW5jZSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QmFsYW5jZShrZXlwYWlyLnB1YmxpY0tleSwgXCJjb25maXJtZWRcIik7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoXCJodHRwczovL3B1bXBwb3J0YWwuZnVuL2FwaS90cmFkZS1sb2NhbFwiLCB7XHJcbiAgICAgIHB1YmxpY0tleToga2V5cGFpci5wdWJsaWNLZXkudG9CYXNlNTgoKSxcclxuICAgICAgYWN0aW9uOiBcImNvbGxlY3RDcmVhdG9yRmVlXCIsXHJcbiAgICAgIHByaW9yaXR5RmVlOiAwLjAwMDAwMSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbWVzc2FnZUJ5dGVzID0gQnVmZmVyLmZyb20ocmVzcG9uc2UuZGF0YSwgXCJiYXNlNjRcIik7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gVmVyc2lvbmVkVHJhbnNhY3Rpb24uZGVzZXJpYWxpemUobWVzc2FnZUJ5dGVzKS5tZXNzYWdlO1xyXG4gICAgY29uc3QgdHggPSBuZXcgVmVyc2lvbmVkVHJhbnNhY3Rpb24obWVzc2FnZSk7XHJcbiAgICB0eC5zaWduKFtrZXlwYWlyXSk7XHJcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0eCwgeyBwcmVmbGlnaHRDb21taXRtZW50OiBcImNvbmZpcm1lZFwiIH0pO1xyXG4gICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBcImNvbmZpcm1lZFwiKTtcclxuICAgIGNvbnN0IGZpbmFsQmFsYW5jZSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QmFsYW5jZShrZXlwYWlyLnB1YmxpY0tleSwgXCJjb25maXJtZWRcIik7XHJcbiAgICBjb25zdCB0eERldGFpbHMgPSBhd2FpdCBjb25uZWN0aW9uLmdldFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgeyBjb21taXRtZW50OiBcImNvbmZpcm1lZFwiLCBtYXhTdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb246IDAgfSk7XHJcbiAgICBjb25zdCB0eEZlZSA9IHR4RGV0YWlscy5tZXRhLmZlZTtcclxuICAgIGNvbnN0IGNsYWltZWRMYW1wb3J0cyA9IChmaW5hbEJhbGFuY2UgLSBpbml0aWFsQmFsYW5jZSkgKyB0eEZlZTtcclxuICAgIGNvbnN0IGNsYWltZWRTb2wgPSBjbGFpbWVkTGFtcG9ydHMgLyBMQU1QT1JUU19QRVJfU09MO1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBUcmFuc2FjdGlvbiBjb25maXJtZWQ6IGh0dHBzOi8vc29sc2Nhbi5pby90eC8ke3NpZ25hdHVyZX0/Y2x1c3Rlcj1kZXZuZXRgKTtcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgQ2xhaW1lZCAke2NsYWltZWRTb2wudG9GaXhlZCg2KX0gU09MIG9uIGRldm5ldGApO1xyXG4gICAgcmV0dXJuIGNsYWltZWRTb2w7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgVW5leHBlY3RlZCBlcnJvciBpbiBjbGFpbUZlZXNGb3JUb2tlbiBvbiBkZXZuZXQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0VG9rZW5EZWNpbWFscyhtaW50QWRkcmVzcywgbG9nVG9GaWxlKSB7XHJcbiAgY29uc3QgdXJsID0gcHJvY2Vzcy5lbnYuSEVMSVVTX1JQQ19VUkw7XHJcbiAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgIGpzb25ycGM6IFwiMi4wXCIsXHJcbiAgICBpZDogXCJnZXQtYWNjb3VudC1pbmZvXCIsXHJcbiAgICBtZXRob2Q6IFwiZ2V0QWNjb3VudEluZm9cIixcclxuICAgIHBhcmFtczogW21pbnRBZGRyZXNzLCB7IGVuY29kaW5nOiBcImpzb25QYXJzZWRcIiB9XSxcclxuICB9O1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QodXJsLCBwYXlsb2FkKTtcclxuICAgIGlmICghcmVzcG9uc2UuZGF0YS5yZXN1bHQ/LnZhbHVlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gYWNjb3VudCBpbmZvIGZvdW5kIGZvciBtaW50ICR7bWludEFkZHJlc3N9IG9uIG1haW5uZXRgKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlY2ltYWxzID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQudmFsdWUuZGF0YS5wYXJzZWQuaW5mby5kZWNpbWFscztcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgRmV0Y2hlZCBkZWNpbWFsczogJHtkZWNpbWFsc30gZm9yIG1pbnQgJHttaW50QWRkcmVzc30gb24gbWFpbm5ldGApO1xyXG4gICAgcmV0dXJuIGRlY2ltYWxzO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBhd2FpdCBsb2dUb0ZpbGUoYEZhaWxlZCB0byBmZXRjaCBkZWNpbWFscyBmb3IgbWludCAke21pbnRBZGRyZXNzfSBvbiBtYWlubmV0OiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGZldGNoVG9rZW5Ib2xkZXJzKHRva2VuTWludEFkZHJlc3MsIGxvZ1RvRmlsZSkge1xyXG4gIGNvbnN0IHVybCA9IHByb2Nlc3MuZW52LkhFTElVU19SUENfVVJMO1xyXG4gIGNvbnN0IGRlY2ltYWxzID0gYXdhaXQgZ2V0VG9rZW5EZWNpbWFscyh0b2tlbk1pbnRBZGRyZXNzLCBsb2dUb0ZpbGUpO1xyXG4gIGF3YWl0IGxvZ1RvRmlsZShgVG9rZW4gZGVjaW1hbHM6ICR7ZGVjaW1hbHN9YCk7XHJcbiAgbGV0IHBhZ2UgPSAxO1xyXG4gIGNvbnN0IGFsbEhvbGRlcnMgPSBbXTtcclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAganNvbnJwYzogXCIyLjBcIixcclxuICAgICAgaWQ6IFwiaGVsaXVzLXRlc3RcIixcclxuICAgICAgbWV0aG9kOiBcImdldFRva2VuQWNjb3VudHNcIixcclxuICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgcGFnZTogcGFnZSxcclxuICAgICAgICBsaW1pdDogMTAwMCxcclxuICAgICAgICBtaW50OiB0b2tlbk1pbnRBZGRyZXNzLFxyXG4gICAgICAgIGRpc3BsYXlPcHRpb25zOiB7fSxcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QodXJsLCBwYXlsb2FkKTtcclxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBgRXJyb3IgZmV0Y2hpbmcgaG9sZGVycyBmcm9tIG1haW5uZXQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSwgJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XHJcbiAgICAgICAgYXdhaXQgbG9nVG9GaWxlKGVycm9yTXNnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YTtcclxuICAgICAgaWYgKCFkYXRhLnJlc3VsdD8udG9rZW5fYWNjb3VudHM/Lmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IGBObyBtb3JlIHJlc3VsdHMgZnJvbSBtYWlubmV0LiBUb3RhbCBwYWdlcyBwcm9jZXNzZWQ6ICR7cGFnZSAtIDF9YDtcclxuICAgICAgICBhd2FpdCBsb2dUb0ZpbGUobXNnKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBhd2FpdCBsb2dUb0ZpbGUoYFByb2Nlc3NpbmcgcGFnZSAke3BhZ2V9IHdpdGggJHtkYXRhLnJlc3VsdC50b2tlbl9hY2NvdW50cy5sZW5ndGh9IGFjY291bnRzIGZyb20gbWFpbm5ldGApO1xyXG4gICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgZGF0YS5yZXN1bHQudG9rZW5fYWNjb3VudHMpIHtcclxuICAgICAgICBpZiAoYWNjb3VudC5hbW91bnQgPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYWNjb3VudC5hbW91bnQgLyBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xyXG4gICAgICAgICAgYWxsSG9sZGVycy5wdXNoKHtcclxuICAgICAgICAgICAgaG9sZGVyX2FkZHJlc3M6IGFjY291bnQub3duZXIsXHJcbiAgICAgICAgICAgIGJhbGFuY2U6IGJhbGFuY2UsXHJcbiAgICAgICAgICAgIHRva2VuX2FjY291bnQ6IGFjY291bnQuYWRkcmVzcyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwYWdlKys7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zdCBlcnJvck1zZyA9IGBFcnJvciBmZXRjaGluZyBwYWdlICR7cGFnZX0gZnJvbSBtYWlubmV0OiAke2Vycm9yLm1lc3NhZ2V9YDtcclxuICAgICAgYXdhaXQgbG9nVG9GaWxlKGVycm9yTXNnKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBhbGxIb2xkZXJzO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZU1haW5uZXRBZGRyZXNzKGNvbm5lY3Rpb24sIGFkZHJlc3MsIGxvZ1RvRmlsZSkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwdWJrZXkgPSBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xyXG4gICAgY29uc3QgYWNjb3VudEluZm8gPSBhd2FpdCBjb25uZWN0aW9uLmdldEFjY291bnRJbmZvKHB1YmtleSwgXCJjb25maXJtZWRcIik7XHJcbiAgICBjb25zdCBleGlzdHMgPSAhIWFjY291bnRJbmZvO1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBWYWxpZGF0ZWQgYWRkcmVzcyAke2FkZHJlc3N9IG9uIGRldm5ldDogJHtleGlzdHMgPyBcIkV4aXN0c1wiIDogXCJEb2VzIG5vdCBleGlzdFwifWApO1xyXG4gICAgcmV0dXJuIGV4aXN0cztcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBFcnJvciB2YWxpZGF0aW5nIGFkZHJlc3MgJHthZGRyZXNzfSBvbiBkZXZuZXQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRBaXJkcm9wKGNvbm5lY3Rpb24sIGtleXBhaXIsIHJlY2lwaWVudHMsIGxvZ1RvRmlsZSkge1xyXG4gIGNvbnN0IHNlbmRlclB1YmtleSA9IGtleXBhaXIucHVibGljS2V5O1xyXG4gIGNvbnN0IFRSQU5TQUNUSU9OX0ZFRSA9IDUwMDA7XHJcbiAgY29uc3QgdG90YWxBbW91bnQgPSByZWNpcGllbnRzLnJlZHVjZSgoc3VtLCB7IGFtb3VudCB9KSA9PiBzdW0gKyBhbW91bnQsIDApO1xyXG4gIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjb25uZWN0aW9uLmdldEJhbGFuY2Uoc2VuZGVyUHVia2V5LCBcImNvbmZpcm1lZFwiKTtcclxuICBpZiAoYmFsYW5jZSA8IHRvdGFsQW1vdW50ICsgVFJBTlNBQ1RJT05fRkVFICogcmVjaXBpZW50cy5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGVycm9yTXNnID0gYEluc3VmZmljaWVudCBmdW5kcyBvbiBkZXZuZXQuIEhhdmU6ICR7YmFsYW5jZSAvIExBTVBPUlRTX1BFUl9TT0x9IFNPTCwgTmVlZDogJHsodG90YWxBbW91bnQgKyBUUkFOU0FDVElPTl9GRUUgKiByZWNpcGllbnRzLmxlbmd0aCkgLyBMQU1QT1JUU19QRVJfU09MfSBTT0xgO1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGVycm9yTXNnKTtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBsZXQgdG90YWxTZW50TGFtcG9ydHMgPSAwO1xyXG4gIGZvciAoY29uc3QgeyBhZGRyZXNzLCBhbW91bnQgfSBvZiByZWNpcGllbnRzKSB7XHJcbiAgICBpZiAoYW1vdW50IDw9IDApIHtcclxuICAgICAgYXdhaXQgbG9nVG9GaWxlKGBTa2lwcGluZyB6ZXJvIG9yIG5lZ2F0aXZlIGFtb3VudCBmb3IgJHthZGRyZXNzfWApO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGxvZ1RvRmlsZShgUHJlcGFyaW5nIHRvIHNlbmQgJHthbW91bnQgLyBMQU1QT1JUU19QRVJfU09MfSBTT0wgZnJvbSAke3NlbmRlclB1YmtleX0gdG8gJHthZGRyZXNzfSBvbiBkZXZuZXRgKTtcclxuICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcclxuICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gMzsgYXR0ZW1wdCsrKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHsgYmxvY2toYXNoLCBsYXN0VmFsaWRCbG9ja0hlaWdodCB9ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goXCJjb25maXJtZWRcIik7XHJcbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbih7IHJlY2VudEJsb2NraGFzaDogYmxvY2toYXNoLCBmZWVQYXllcjogc2VuZGVyUHVia2V5IH0pLmFkZChcclxuICAgICAgICAgICAgU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XHJcbiAgICAgICAgICAgICAgZnJvbVB1YmtleTogc2VuZGVyUHVia2V5LFxyXG4gICAgICAgICAgICAgIHRvUHVia2V5OiBuZXcgUHVibGljS2V5KGFkZHJlc3MpLFxyXG4gICAgICAgICAgICAgIGxhbXBvcnRzOiBNYXRoLmZsb29yKGFtb3VudCksXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIFtrZXlwYWlyXSwgeyBza2lwUHJlZmxpZ2h0OiBmYWxzZSB9KTtcclxuICAgICAgICAgIGF3YWl0IGxvZ1RvRmlsZShgVHJhbnNhY3Rpb24gc2VudCB3aXRoIHNpZ25hdHVyZTogJHtzaWduYXR1cmV9IHRvICR7YWRkcmVzc30gb24gZGV2bmV0YCk7XHJcbiAgICAgICAgICBjb25zdCBjb25maXJtYXRpb24gPSBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihcclxuICAgICAgICAgICAgeyBzaWduYXR1cmUsIGJsb2NraGFzaCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQgfSxcclxuICAgICAgICAgICAgXCJjb25maXJtZWRcIlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGlmIChjb25maXJtYXRpb24udmFsdWUuZXJyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gZmFpbGVkOiAke2NvbmZpcm1hdGlvbi52YWx1ZS5lcnJ9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoYEFpcmRyb3Agc3VjY2Vzc2Z1bCEgU2VudCAke2Ftb3VudCAvIExBTVBPUlRTX1BFUl9TT0x9IFNPTCB0byAke2FkZHJlc3N9IG9uIGRldm5ldGApO1xyXG4gICAgICAgICAgc3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgYXdhaXQgbG9nVG9GaWxlKGBFcnJvciBvbiBhdHRlbXB0ICR7YXR0ZW1wdH0gZm9yICR7YWRkcmVzc30gb24gZGV2bmV0OiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdWNjZXNzKSB7XHJcbiAgICAgICAgdG90YWxTZW50TGFtcG9ydHMgKz0gYW1vdW50O1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBhd2FpdCBsb2dUb0ZpbGUoYENyaXRpY2FsIGVycm9yIHNlbmRpbmcgdG8gJHthZGRyZXNzfSBvbiBkZXZuZXQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRvdGFsU2VudExhbXBvcnRzO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBpbml0aWFsaXplS2V5cGFpcixcclxuICBjbGFpbUZlZXNGb3JUb2tlbixcclxuICBmZXRjaFRva2VuSG9sZGVycyxcclxuICB2YWxpZGF0ZU1haW5uZXRBZGRyZXNzLFxyXG4gIHNlbmRBaXJkcm9wLFxyXG59OyJdLCJuYW1lcyI6WyJDb25uZWN0aW9uIiwiS2V5cGFpciIsIlB1YmxpY0tleSIsIlRyYW5zYWN0aW9uIiwiU3lzdGVtUHJvZ3JhbSIsIkxBTVBPUlRTX1BFUl9TT0wiLCJWZXJzaW9uZWRUcmFuc2FjdGlvbiIsInJlcXVpcmUiLCJheGlvcyIsImJzNTgiLCJpbml0aWFsaXplS2V5cGFpciIsInNlY3JldEtleUFycmF5IiwiSlNPTiIsInBhcnNlIiwicHJvY2VzcyIsImVudiIsIlBSSVZBVEVfS0VZIiwic2VjcmV0S2V5Qnl0ZXMiLCJVaW50OEFycmF5IiwiZnJvbSIsImxlbmd0aCIsIkVycm9yIiwiZnJvbVNlY3JldEtleSIsImpzb25FcnJvciIsImRlY29kZSIsImJzNThFcnJvciIsIm1lc3NhZ2UiLCJlcnJvciIsImNsYWltRmVlc0ZvclRva2VuIiwidG9rZW5NaW50IiwiY29ubmVjdGlvbiIsImtleXBhaXIiLCJsb2dUb0ZpbGUiLCJwdWJsaWNLZXkiLCJ0b0Jhc2U1OCIsImluaXRpYWxCYWxhbmNlIiwiZ2V0QmFsYW5jZSIsInJlc3BvbnNlIiwicG9zdCIsImFjdGlvbiIsInByaW9yaXR5RmVlIiwibWVzc2FnZUJ5dGVzIiwiQnVmZmVyIiwiZGF0YSIsImRlc2VyaWFsaXplIiwidHgiLCJzaWduIiwic2lnbmF0dXJlIiwic2VuZFRyYW5zYWN0aW9uIiwicHJlZmxpZ2h0Q29tbWl0bWVudCIsImNvbmZpcm1UcmFuc2FjdGlvbiIsImZpbmFsQmFsYW5jZSIsInR4RGV0YWlscyIsImdldFRyYW5zYWN0aW9uIiwiY29tbWl0bWVudCIsIm1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbiIsInR4RmVlIiwibWV0YSIsImZlZSIsImNsYWltZWRMYW1wb3J0cyIsImNsYWltZWRTb2wiLCJ0b0ZpeGVkIiwiZ2V0VG9rZW5EZWNpbWFscyIsIm1pbnRBZGRyZXNzIiwidXJsIiwiSEVMSVVTX1JQQ19VUkwiLCJwYXlsb2FkIiwianNvbnJwYyIsImlkIiwibWV0aG9kIiwicGFyYW1zIiwiZW5jb2RpbmciLCJyZXN1bHQiLCJ2YWx1ZSIsImRlY2ltYWxzIiwicGFyc2VkIiwiaW5mbyIsImZldGNoVG9rZW5Ib2xkZXJzIiwidG9rZW5NaW50QWRkcmVzcyIsInBhZ2UiLCJhbGxIb2xkZXJzIiwibGltaXQiLCJtaW50IiwiZGlzcGxheU9wdGlvbnMiLCJzdGF0dXMiLCJlcnJvck1zZyIsInN0YXR1c1RleHQiLCJ0b2tlbl9hY2NvdW50cyIsIm1zZyIsImFjY291bnQiLCJhbW91bnQiLCJiYWxhbmNlIiwiTWF0aCIsInBvdyIsInB1c2giLCJob2xkZXJfYWRkcmVzcyIsIm93bmVyIiwidG9rZW5fYWNjb3VudCIsImFkZHJlc3MiLCJ2YWxpZGF0ZU1haW5uZXRBZGRyZXNzIiwicHVia2V5IiwiYWNjb3VudEluZm8iLCJnZXRBY2NvdW50SW5mbyIsImV4aXN0cyIsInNlbmRBaXJkcm9wIiwicmVjaXBpZW50cyIsInNlbmRlclB1YmtleSIsIlRSQU5TQUNUSU9OX0ZFRSIsInRvdGFsQW1vdW50IiwicmVkdWNlIiwic3VtIiwidG90YWxTZW50TGFtcG9ydHMiLCJzdWNjZXNzIiwiYXR0ZW1wdCIsImJsb2NraGFzaCIsImxhc3RWYWxpZEJsb2NrSGVpZ2h0IiwiZ2V0TGF0ZXN0QmxvY2toYXNoIiwidHJhbnNhY3Rpb24iLCJyZWNlbnRCbG9ja2hhc2giLCJmZWVQYXllciIsImFkZCIsInRyYW5zZmVyIiwiZnJvbVB1YmtleSIsInRvUHVia2V5IiwibGFtcG9ydHMiLCJmbG9vciIsInNraXBQcmVmbGlnaHQiLCJjb25maXJtYXRpb24iLCJlcnIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./lib/solana.js\n");

/***/ }),

/***/ "(api)/./pages/api/airdrop.js":
/*!******************************!*\
  !*** ./pages/api/airdrop.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\nconst { Connection, LAMPORTS_PER_SOL } = __webpack_require__(/*! @solana/web3.js */ \"@solana/web3.js\");\nconst fs = (__webpack_require__(/*! fs */ \"fs\").promises);\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Pusher = __webpack_require__(/*! pusher */ \"pusher\");\nconst { initializeKeypair, claimFeesForToken, fetchTokenHolders, validateMainnetAddress, sendAirdrop } = __webpack_require__(/*! ../../lib/solana */ \"(api)/./lib/solana.js\");\nconst { appendToExcel } = __webpack_require__(/*! ../../lib/excel */ \"(api)/./lib/excel.js\");\nconst pusher = new Pusher({\n    appId: process.env.PUSHER_APP_ID,\n    key: process.env.PUSHER_KEY,\n    secret: process.env.PUSHER_SECRET,\n    cluster: process.env.PUSHER_CLUSTER,\n    useTLS: true\n});\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    const connection = new Connection(\"https://api.devnet.solana.com\", \"confirmed\");\n    let keypair;\n    try {\n        keypair = await initializeKeypair();\n    } catch (error) {\n        await logToFile(`Invalid secret key: ${error.message}`);\n        return res.status(500).json({\n            error: `Invalid secret key: ${error.message}`\n        });\n    }\n    async function logToFile(message, logFile = path.join(process.cwd(), \"airdrop_log.txt\")) {\n        const timestamp = new Date().toISOString().replace(/T/, \" \").replace(/\\..+/, \"\");\n        try {\n            await fs.appendFile(logFile, `[${timestamp}] ${message}\\n`);\n        } catch (err) {\n            console.error(`Failed to write to log file ${logFile}: ${err.message}`);\n            throw err;\n        }\n    }\n    try {\n        // Clear airdrop log at the start of each cycle\n        const logFilePath = path.join(process.cwd(), \"airdrop_log.txt\");\n        await fs.writeFile(logFilePath, \"\");\n        await logToFile(`Starting airdrop cycle (holder scraping on mainnet, airdrop on devnet). Project directory: ${process.cwd()}`);\n        // Validate percentage environment variables\n        const holdersPercentage = parseFloat(process.env.HOLDERS_PERCENTAGE) || 90;\n        const feeWalletPercentage = parseFloat(process.env.FEE_WALLET_PERCENTAGE) || 10;\n        if (holdersPercentage + feeWalletPercentage !== 100) {\n            await logToFile(`Invalid percentages: HOLDERS_PERCENTAGE (${holdersPercentage}) + FEE_WALLET_PERCENTAGE (${feeWalletPercentage}) must equal 100`);\n            return res.status(400).json({\n                error: `Invalid percentages: HOLDERS_PERCENTAGE (${holdersPercentage}) + FEE_WALLET_PERCENTAGE (${feeWalletPercentage}) must equal 100`\n            });\n        }\n        // Bypass claimFeesForToken for devnet testing\n        await logToFile(`Bypassing fee claiming for token ${process.env.TOKEN_MINT_ADDRESS} on devnet`);\n        const claimedSol = 0; // await claimFeesForToken(process.env.TOKEN_MINT_ADDRESS, connection, keypair, logToFile);\n        await logToFile(\"Fetching token holders from mainnet...\");\n        const holders = await fetchTokenHolders(process.env.TOKEN_MINT_ADDRESS, logToFile);\n        const qualifiedHolders = [];\n        const MINIMUM_TOKEN_BALANCE = 100000; // 100,000 tokens\n        for (const holder of holders){\n            if (holder.balance >= MINIMUM_TOKEN_BALANCE && await validateMainnetAddress(connection, holder.holder_address, logToFile)) {\n                qualifiedHolders.push(holder);\n            }\n        }\n        const outputContent = [\n            `Token Holders for Mint: ${process.env.TOKEN_MINT_ADDRESS} (fetched from mainnet)`,\n            `Total Holders: ${holders.length}`,\n            `Qualified Holders (on devnet, min ${MINIMUM_TOKEN_BALANCE} tokens): ${qualifiedHolders.length}`,\n            \"-\".repeat(50),\n            ...holders.map((holder)=>`Holder: ${holder.holder_address}, Balance: ${holder.balance}, Token Account: ${holder.token_account}, Qualified: ${qualifiedHolders.some((q)=>q.holder_address === holder.holder_address) ? \"Yes\" : \"No\"}`)\n        ].join(\"\\n\");\n        const holdersFilePath = path.join(process.cwd(), \"token_holders.txt\");\n        await fs.writeFile(holdersFilePath, outputContent);\n        await logToFile(`Saved ${holders.length} token holders (${qualifiedHolders.length} qualified) to ${holdersFilePath}`);\n        const balance = await connection.getBalance(keypair.publicKey, \"confirmed\");\n        await logToFile(`Devnet wallet balance: ${balance / LAMPORTS_PER_SOL} SOL`);\n        let airdroppedLamports = 0;\n        const MINIMUM_BALANCE = 0.2 * LAMPORTS_PER_SOL;\n        if (balance > MINIMUM_BALANCE) {\n            const distributableLamports = Math.floor(balance - MINIMUM_BALANCE);\n            await logToFile(`Distributable amount: ${distributableLamports / LAMPORTS_PER_SOL} SOL`);\n            const feeWalletValid = await validateMainnetAddress(connection, process.env.FEE_WALLET_ADDRESS, logToFile);\n            if (!feeWalletValid) {\n                await logToFile(`Fee wallet ${process.env.FEE_WALLET_ADDRESS} does not exist on devnet`);\n                return res.status(400).json({\n                    error: `Fee wallet ${process.env.FEE_WALLET_ADDRESS} does not exist on devnet`\n                });\n            }\n            const feeAmount = Math.floor(distributableLamports * (feeWalletPercentage / 100));\n            let holdersAmount = distributableLamports - feeAmount;\n            const holdersCount = qualifiedHolders.length;\n            const recipients = [];\n            let weights = [];\n            if (feeAmount > 0) {\n                recipients.push({\n                    address: process.env.FEE_WALLET_ADDRESS,\n                    amount: feeAmount\n                });\n            }\n            if (holdersCount > 0 && holdersAmount > 0) {\n                weights = qualifiedHolders.map((holder)=>Math.log10(holder.balance + 1));\n                const totalWeight = weights.reduce((sum, weight)=>sum + weight, 0);\n                if (totalWeight <= 0) {\n                    await logToFile(\"No valid weights for holders, sending all to fee wallet\");\n                    recipients[0].amount += holdersAmount;\n                    holdersAmount = 0;\n                } else {\n                    for(let i = 0; i < qualifiedHolders.length; i++){\n                        const holder = qualifiedHolders[i];\n                        const weight = weights[i];\n                        const amount = Math.floor(weight / totalWeight * holdersAmount);\n                        if (amount > 0) {\n                            recipients.push({\n                                address: holder.holder_address,\n                                amount\n                            });\n                        }\n                    }\n                    const totalHoldersAmount = recipients.slice(1).reduce((sum, r)=>sum + r.amount, 0);\n                    if (holdersAmount > totalHoldersAmount) {\n                        recipients[0].amount += holdersAmount - totalHoldersAmount;\n                    }\n                }\n            } else if (holdersAmount > 0) {\n                recipients[0].amount += holdersAmount;\n                holdersAmount = 0;\n            }\n            const distributionContent = [\n                `\\nAirdrop Distribution (on devnet, ${feeWalletPercentage}% fee wallet, ${holdersPercentage}% holders with logarithmic weighting)`,\n                \"-\".repeat(50),\n                `Fee Wallet (${process.env.FEE_WALLET_ADDRESS}): ${(recipients.find((r)=>r.address === process.env.FEE_WALLET_ADDRESS)?.amount || 0) / LAMPORTS_PER_SOL} SOL`,\n                ...qualifiedHolders.map((holder, i)=>`Holder (${holder.holder_address}): ${(recipients.find((r)=>r.address === holder.holder_address)?.amount || 0) / LAMPORTS_PER_SOL} SOL (Weight: ${(weights[i] || 0).toFixed(4)})`)\n            ].join(\"\\n\");\n            await fs.appendFile(holdersFilePath, distributionContent);\n            await logToFile(distributionContent);\n            if (recipients.length > 0) {\n                airdroppedLamports = await sendAirdrop(connection, keypair, recipients, logToFile);\n                if (airdroppedLamports > 0) {\n                    await logToFile(\"Airdrop completed successfully on devnet\");\n                } else {\n                    await logToFile(\"Airdrop failed on devnet, see logs for details\");\n                }\n            } else {\n                await logToFile(\"No valid recipients, skipping airdrop on devnet\");\n            }\n        } else {\n            await logToFile(\"Devnet wallet balance <= 0.2 SOL, skipping airdrop\");\n        }\n        const airdroppedSol = airdroppedLamports / LAMPORTS_PER_SOL;\n        await appendToExcel(new Date(), claimedSol, airdroppedSol);\n        // Emit Pusher update\n        const dashboardData = await (__webpack_require__(/*! ../../lib/excel */ \"(api)/./lib/excel.js\").readExcelData)();\n        await pusher.trigger(\"airdrop-channel\", \"dashboard-update\", dashboardData);\n        res.status(200).json({\n            message: \"Airdrop cycle completed\",\n            claimedSol,\n            airdroppedSol\n        });\n    } catch (error) {\n        await logToFile(`Error in airdrop loop: ${error.message}`);\n        res.status(500).json({\n            error: `Error in airdrop loop: ${error.message}`\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0wsTUFBTUEsVUFBVTtnQkFDbEI7WUFDRixPQUFPO2dCQUNMLE1BQU1BLFVBQVU7WUFDbEI7UUFDRixPQUFPO1lBQ0wsTUFBTUEsVUFBVTtRQUNsQjtRQUNBLE1BQU1nRSxnQkFBZ0IxQixxQkFBcUJ2RTtRQUMzQyxNQUFNVyxjQUFjLElBQUk0QixRQUFRYyxZQUFZNEM7UUFDNUMscUJBQXFCO1FBQ3JCLE1BQU1DLGdCQUFnQixNQUFNakcsa0ZBQXdDO1FBQ3BFLE1BQU1XLE9BQU93RixPQUFPLENBQUMsbUJBQW1CLG9CQUFvQkY7UUFDNUR4RSxJQUFJRSxNQUFNLENBQUMsS0FBS0MsSUFBSSxDQUFDO1lBQUVLLFNBQVM7WUFBMkJtQjtZQUFZNEM7UUFBYztJQUN2RixFQUFFLE9BQU9uRSxPQUFPO1FBQ2QsTUFBTUcsVUFBVSxDQUFDLHVCQUF1QixFQUFFSCxNQUFNSSxPQUFPLENBQUMsQ0FBQztRQUN6RFIsSUFBSUUsTUFBTSxDQUFDLEtBQUtDLElBQUksQ0FBQztZQUFFQyxPQUFPLENBQUMsdUJBQXVCLEVBQUVBLE1BQU1JLE9BQU8sQ0FBQyxDQUFDO1FBQUM7SUFDMUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpcmRyb3AtZGFzaGJvYXJkLy4vcGFnZXMvYXBpL2FpcmRyb3AuanM/Njc1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IENvbm5lY3Rpb24sIExBTVBPUlRTX1BFUl9TT0wgfSA9IHJlcXVpcmUoXCJAc29sYW5hL3dlYjMuanNcIik7XHJcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpLnByb21pc2VzO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbmNvbnN0IFB1c2hlciA9IHJlcXVpcmUoXCJwdXNoZXJcIik7XHJcbmNvbnN0IHsgaW5pdGlhbGl6ZUtleXBhaXIsIGNsYWltRmVlc0ZvclRva2VuLCBmZXRjaFRva2VuSG9sZGVycywgdmFsaWRhdGVNYWlubmV0QWRkcmVzcywgc2VuZEFpcmRyb3AgfSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvc29sYW5hXCIpO1xyXG5jb25zdCB7IGFwcGVuZFRvRXhjZWwgfSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvZXhjZWxcIik7XHJcblxyXG5jb25zdCBwdXNoZXIgPSBuZXcgUHVzaGVyKHtcclxuICBhcHBJZDogcHJvY2Vzcy5lbnYuUFVTSEVSX0FQUF9JRCxcclxuICBrZXk6IHByb2Nlc3MuZW52LlBVU0hFUl9LRVksXHJcbiAgc2VjcmV0OiBwcm9jZXNzLmVudi5QVVNIRVJfU0VDUkVULFxyXG4gIGNsdXN0ZXI6IHByb2Nlc3MuZW52LlBVU0hFUl9DTFVTVEVSLFxyXG4gIHVzZVRMUzogdHJ1ZSxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzKSB7XHJcbiAgaWYgKHJlcS5tZXRob2QgIT09IFwiUE9TVFwiKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBlcnJvcjogXCJNZXRob2Qgbm90IGFsbG93ZWRcIiB9KTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihcImh0dHBzOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tXCIsIFwiY29uZmlybWVkXCIpO1xyXG4gIGxldCBrZXlwYWlyO1xyXG4gIHRyeSB7XHJcbiAgICBrZXlwYWlyID0gYXdhaXQgaW5pdGlhbGl6ZUtleXBhaXIoKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBJbnZhbGlkIHNlY3JldCBrZXk6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiBgSW52YWxpZCBzZWNyZXQga2V5OiAke2Vycm9yLm1lc3NhZ2V9YCB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGxvZ1RvRmlsZShtZXNzYWdlLCBsb2dGaWxlID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIFwiYWlyZHJvcF9sb2cudHh0XCIpKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvVC8sIFwiIFwiKS5yZXBsYWNlKC9cXC4uKy8sIFwiXCIpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgZnMuYXBwZW5kRmlsZShsb2dGaWxlLCBgWyR7dGltZXN0YW1wfV0gJHttZXNzYWdlfVxcbmApO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB3cml0ZSB0byBsb2cgZmlsZSAke2xvZ0ZpbGV9OiAke2Vyci5tZXNzYWdlfWApO1xyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgLy8gQ2xlYXIgYWlyZHJvcCBsb2cgYXQgdGhlIHN0YXJ0IG9mIGVhY2ggY3ljbGVcclxuICAgIGNvbnN0IGxvZ0ZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksIFwiYWlyZHJvcF9sb2cudHh0XCIpO1xyXG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGxvZ0ZpbGVQYXRoLCBcIlwiKTtcclxuICAgIGF3YWl0IGxvZ1RvRmlsZShgU3RhcnRpbmcgYWlyZHJvcCBjeWNsZSAoaG9sZGVyIHNjcmFwaW5nIG9uIG1haW5uZXQsIGFpcmRyb3Agb24gZGV2bmV0KS4gUHJvamVjdCBkaXJlY3Rvcnk6ICR7cHJvY2Vzcy5jd2QoKX1gKTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBwZXJjZW50YWdlIGVudmlyb25tZW50IHZhcmlhYmxlc1xyXG4gICAgY29uc3QgaG9sZGVyc1BlcmNlbnRhZ2UgPSBwYXJzZUZsb2F0KHByb2Nlc3MuZW52LkhPTERFUlNfUEVSQ0VOVEFHRSkgfHwgOTA7XHJcbiAgICBjb25zdCBmZWVXYWxsZXRQZXJjZW50YWdlID0gcGFyc2VGbG9hdChwcm9jZXNzLmVudi5GRUVfV0FMTEVUX1BFUkNFTlRBR0UpIHx8IDEwO1xyXG4gICAgaWYgKGhvbGRlcnNQZXJjZW50YWdlICsgZmVlV2FsbGV0UGVyY2VudGFnZSAhPT0gMTAwKSB7XHJcbiAgICAgIGF3YWl0IGxvZ1RvRmlsZShgSW52YWxpZCBwZXJjZW50YWdlczogSE9MREVSU19QRVJDRU5UQUdFICgke2hvbGRlcnNQZXJjZW50YWdlfSkgKyBGRUVfV0FMTEVUX1BFUkNFTlRBR0UgKCR7ZmVlV2FsbGV0UGVyY2VudGFnZX0pIG11c3QgZXF1YWwgMTAwYCk7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiBgSW52YWxpZCBwZXJjZW50YWdlczogSE9MREVSU19QRVJDRU5UQUdFICgke2hvbGRlcnNQZXJjZW50YWdlfSkgKyBGRUVfV0FMTEVUX1BFUkNFTlRBR0UgKCR7ZmVlV2FsbGV0UGVyY2VudGFnZX0pIG11c3QgZXF1YWwgMTAwYCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCeXBhc3MgY2xhaW1GZWVzRm9yVG9rZW4gZm9yIGRldm5ldCB0ZXN0aW5nXHJcbiAgICBhd2FpdCBsb2dUb0ZpbGUoYEJ5cGFzc2luZyBmZWUgY2xhaW1pbmcgZm9yIHRva2VuICR7cHJvY2Vzcy5lbnYuVE9LRU5fTUlOVF9BRERSRVNTfSBvbiBkZXZuZXRgKTtcclxuICAgIGNvbnN0IGNsYWltZWRTb2wgPSAwOyAvLyBhd2FpdCBjbGFpbUZlZXNGb3JUb2tlbihwcm9jZXNzLmVudi5UT0tFTl9NSU5UX0FERFJFU1MsIGNvbm5lY3Rpb24sIGtleXBhaXIsIGxvZ1RvRmlsZSk7XHJcblxyXG4gICAgYXdhaXQgbG9nVG9GaWxlKFwiRmV0Y2hpbmcgdG9rZW4gaG9sZGVycyBmcm9tIG1haW5uZXQuLi5cIik7XHJcbiAgICBjb25zdCBob2xkZXJzID0gYXdhaXQgZmV0Y2hUb2tlbkhvbGRlcnMocHJvY2Vzcy5lbnYuVE9LRU5fTUlOVF9BRERSRVNTLCBsb2dUb0ZpbGUpO1xyXG4gICAgY29uc3QgcXVhbGlmaWVkSG9sZGVycyA9IFtdO1xyXG4gICAgY29uc3QgTUlOSU1VTV9UT0tFTl9CQUxBTkNFID0gMTAwMDAwOyAvLyAxMDAsMDAwIHRva2Vuc1xyXG4gICAgZm9yIChjb25zdCBob2xkZXIgb2YgaG9sZGVycykge1xyXG4gICAgICBpZiAoaG9sZGVyLmJhbGFuY2UgPj0gTUlOSU1VTV9UT0tFTl9CQUxBTkNFICYmIGF3YWl0IHZhbGlkYXRlTWFpbm5ldEFkZHJlc3MoY29ubmVjdGlvbiwgaG9sZGVyLmhvbGRlcl9hZGRyZXNzLCBsb2dUb0ZpbGUpKSB7XHJcbiAgICAgICAgcXVhbGlmaWVkSG9sZGVycy5wdXNoKGhvbGRlcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBbXHJcbiAgICAgIGBUb2tlbiBIb2xkZXJzIGZvciBNaW50OiAke3Byb2Nlc3MuZW52LlRPS0VOX01JTlRfQUREUkVTU30gKGZldGNoZWQgZnJvbSBtYWlubmV0KWAsXHJcbiAgICAgIGBUb3RhbCBIb2xkZXJzOiAke2hvbGRlcnMubGVuZ3RofWAsXHJcbiAgICAgIGBRdWFsaWZpZWQgSG9sZGVycyAob24gZGV2bmV0LCBtaW4gJHtNSU5JTVVNX1RPS0VOX0JBTEFOQ0V9IHRva2Vucyk6ICR7cXVhbGlmaWVkSG9sZGVycy5sZW5ndGh9YCxcclxuICAgICAgXCItXCIucmVwZWF0KDUwKSxcclxuICAgICAgLi4uaG9sZGVycy5tYXAoXHJcbiAgICAgICAgKGhvbGRlcikgPT4gYEhvbGRlcjogJHtob2xkZXIuaG9sZGVyX2FkZHJlc3N9LCBCYWxhbmNlOiAke2hvbGRlci5iYWxhbmNlfSwgVG9rZW4gQWNjb3VudDogJHtob2xkZXIudG9rZW5fYWNjb3VudH0sIFF1YWxpZmllZDogJHtxdWFsaWZpZWRIb2xkZXJzLnNvbWUocSA9PiBxLmhvbGRlcl9hZGRyZXNzID09PSBob2xkZXIuaG9sZGVyX2FkZHJlc3MpID8gXCJZZXNcIiA6IFwiTm9cIn1gXHJcbiAgICAgICksXHJcbiAgICBdLmpvaW4oXCJcXG5cIik7XHJcbiAgICBjb25zdCBob2xkZXJzRmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgXCJ0b2tlbl9ob2xkZXJzLnR4dFwiKTtcclxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShob2xkZXJzRmlsZVBhdGgsIG91dHB1dENvbnRlbnQpO1xyXG4gICAgYXdhaXQgbG9nVG9GaWxlKGBTYXZlZCAke2hvbGRlcnMubGVuZ3RofSB0b2tlbiBob2xkZXJzICgke3F1YWxpZmllZEhvbGRlcnMubGVuZ3RofSBxdWFsaWZpZWQpIHRvICR7aG9sZGVyc0ZpbGVQYXRofWApO1xyXG4gICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QmFsYW5jZShrZXlwYWlyLnB1YmxpY0tleSwgXCJjb25maXJtZWRcIik7XHJcbiAgICBhd2FpdCBsb2dUb0ZpbGUoYERldm5ldCB3YWxsZXQgYmFsYW5jZTogJHtiYWxhbmNlIC8gTEFNUE9SVFNfUEVSX1NPTH0gU09MYCk7XHJcbiAgICBsZXQgYWlyZHJvcHBlZExhbXBvcnRzID0gMDtcclxuICAgIGNvbnN0IE1JTklNVU1fQkFMQU5DRSA9IDAuMiAqIExBTVBPUlRTX1BFUl9TT0w7XHJcbiAgICBpZiAoYmFsYW5jZSA+IE1JTklNVU1fQkFMQU5DRSkge1xyXG4gICAgICBjb25zdCBkaXN0cmlidXRhYmxlTGFtcG9ydHMgPSBNYXRoLmZsb29yKGJhbGFuY2UgLSBNSU5JTVVNX0JBTEFOQ0UpO1xyXG4gICAgICBhd2FpdCBsb2dUb0ZpbGUoYERpc3RyaWJ1dGFibGUgYW1vdW50OiAke2Rpc3RyaWJ1dGFibGVMYW1wb3J0cyAvIExBTVBPUlRTX1BFUl9TT0x9IFNPTGApO1xyXG4gICAgICBjb25zdCBmZWVXYWxsZXRWYWxpZCA9IGF3YWl0IHZhbGlkYXRlTWFpbm5ldEFkZHJlc3MoY29ubmVjdGlvbiwgcHJvY2Vzcy5lbnYuRkVFX1dBTExFVF9BRERSRVNTLCBsb2dUb0ZpbGUpO1xyXG4gICAgICBpZiAoIWZlZVdhbGxldFZhbGlkKSB7XHJcbiAgICAgICAgYXdhaXQgbG9nVG9GaWxlKGBGZWUgd2FsbGV0ICR7cHJvY2Vzcy5lbnYuRkVFX1dBTExFVF9BRERSRVNTfSBkb2VzIG5vdCBleGlzdCBvbiBkZXZuZXRgKTtcclxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDApLmpzb24oeyBlcnJvcjogYEZlZSB3YWxsZXQgJHtwcm9jZXNzLmVudi5GRUVfV0FMTEVUX0FERFJFU1N9IGRvZXMgbm90IGV4aXN0IG9uIGRldm5ldGAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZmVlQW1vdW50ID0gTWF0aC5mbG9vcihkaXN0cmlidXRhYmxlTGFtcG9ydHMgKiAoZmVlV2FsbGV0UGVyY2VudGFnZSAvIDEwMCkpO1xyXG4gICAgICBsZXQgaG9sZGVyc0Ftb3VudCA9IGRpc3RyaWJ1dGFibGVMYW1wb3J0cyAtIGZlZUFtb3VudDtcclxuICAgICAgY29uc3QgaG9sZGVyc0NvdW50ID0gcXVhbGlmaWVkSG9sZGVycy5sZW5ndGg7XHJcbiAgICAgIGNvbnN0IHJlY2lwaWVudHMgPSBbXTtcclxuICAgICAgbGV0IHdlaWdodHMgPSBbXTtcclxuICAgICAgaWYgKGZlZUFtb3VudCA+IDApIHtcclxuICAgICAgICByZWNpcGllbnRzLnB1c2goeyBhZGRyZXNzOiBwcm9jZXNzLmVudi5GRUVfV0FMTEVUX0FERFJFU1MsIGFtb3VudDogZmVlQW1vdW50IH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChob2xkZXJzQ291bnQgPiAwICYmIGhvbGRlcnNBbW91bnQgPiAwKSB7XHJcbiAgICAgICAgd2VpZ2h0cyA9IHF1YWxpZmllZEhvbGRlcnMubWFwKGhvbGRlciA9PiBNYXRoLmxvZzEwKGhvbGRlci5iYWxhbmNlICsgMSkpO1xyXG4gICAgICAgIGNvbnN0IHRvdGFsV2VpZ2h0ID0gd2VpZ2h0cy5yZWR1Y2UoKHN1bSwgd2VpZ2h0KSA9PiBzdW0gKyB3ZWlnaHQsIDApO1xyXG4gICAgICAgIGlmICh0b3RhbFdlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoXCJObyB2YWxpZCB3ZWlnaHRzIGZvciBob2xkZXJzLCBzZW5kaW5nIGFsbCB0byBmZWUgd2FsbGV0XCIpO1xyXG4gICAgICAgICAgcmVjaXBpZW50c1swXS5hbW91bnQgKz0gaG9sZGVyc0Ftb3VudDtcclxuICAgICAgICAgIGhvbGRlcnNBbW91bnQgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1YWxpZmllZEhvbGRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaG9sZGVyID0gcXVhbGlmaWVkSG9sZGVyc1tpXTtcclxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gd2VpZ2h0c1tpXTtcclxuICAgICAgICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5mbG9vcigod2VpZ2h0IC8gdG90YWxXZWlnaHQpICogaG9sZGVyc0Ftb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChhbW91bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgcmVjaXBpZW50cy5wdXNoKHsgYWRkcmVzczogaG9sZGVyLmhvbGRlcl9hZGRyZXNzLCBhbW91bnQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IHRvdGFsSG9sZGVyc0Ftb3VudCA9IHJlY2lwaWVudHMuc2xpY2UoMSkucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuYW1vdW50LCAwKTtcclxuICAgICAgICAgIGlmIChob2xkZXJzQW1vdW50ID4gdG90YWxIb2xkZXJzQW1vdW50KSB7XHJcbiAgICAgICAgICAgIHJlY2lwaWVudHNbMF0uYW1vdW50ICs9IGhvbGRlcnNBbW91bnQgLSB0b3RhbEhvbGRlcnNBbW91bnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGhvbGRlcnNBbW91bnQgPiAwKSB7XHJcbiAgICAgICAgcmVjaXBpZW50c1swXS5hbW91bnQgKz0gaG9sZGVyc0Ftb3VudDtcclxuICAgICAgICBob2xkZXJzQW1vdW50ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkaXN0cmlidXRpb25Db250ZW50ID0gW1xyXG4gICAgICAgIGBcXG5BaXJkcm9wIERpc3RyaWJ1dGlvbiAob24gZGV2bmV0LCAke2ZlZVdhbGxldFBlcmNlbnRhZ2V9JSBmZWUgd2FsbGV0LCAke2hvbGRlcnNQZXJjZW50YWdlfSUgaG9sZGVycyB3aXRoIGxvZ2FyaXRobWljIHdlaWdodGluZylgLFxyXG4gICAgICAgIFwiLVwiLnJlcGVhdCg1MCksXHJcbiAgICAgICAgYEZlZSBXYWxsZXQgKCR7cHJvY2Vzcy5lbnYuRkVFX1dBTExFVF9BRERSRVNTfSk6ICR7KHJlY2lwaWVudHMuZmluZChyID0+IHIuYWRkcmVzcyA9PT0gcHJvY2Vzcy5lbnYuRkVFX1dBTExFVF9BRERSRVNTKT8uYW1vdW50IHx8IDApIC8gTEFNUE9SVFNfUEVSX1NPTH0gU09MYCxcclxuICAgICAgICAuLi5xdWFsaWZpZWRIb2xkZXJzLm1hcChcclxuICAgICAgICAgIChob2xkZXIsIGkpID0+IGBIb2xkZXIgKCR7aG9sZGVyLmhvbGRlcl9hZGRyZXNzfSk6ICR7KHJlY2lwaWVudHMuZmluZChyID0+IHIuYWRkcmVzcyA9PT0gaG9sZGVyLmhvbGRlcl9hZGRyZXNzKT8uYW1vdW50IHx8IDApIC8gTEFNUE9SVFNfUEVSX1NPTH0gU09MIChXZWlnaHQ6ICR7KHdlaWdodHNbaV0gfHwgMCkudG9GaXhlZCg0KX0pYFxyXG4gICAgICAgICksXHJcbiAgICAgIF0uam9pbihcIlxcblwiKTtcclxuICAgICAgYXdhaXQgZnMuYXBwZW5kRmlsZShob2xkZXJzRmlsZVBhdGgsIGRpc3RyaWJ1dGlvbkNvbnRlbnQpO1xyXG4gICAgICBhd2FpdCBsb2dUb0ZpbGUoZGlzdHJpYnV0aW9uQ29udGVudCk7XHJcbiAgICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBhaXJkcm9wcGVkTGFtcG9ydHMgPSBhd2FpdCBzZW5kQWlyZHJvcChjb25uZWN0aW9uLCBrZXlwYWlyLCByZWNpcGllbnRzLCBsb2dUb0ZpbGUpO1xyXG4gICAgICAgIGlmIChhaXJkcm9wcGVkTGFtcG9ydHMgPiAwKSB7XHJcbiAgICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoXCJBaXJkcm9wIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgb24gZGV2bmV0XCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoXCJBaXJkcm9wIGZhaWxlZCBvbiBkZXZuZXQsIHNlZSBsb2dzIGZvciBkZXRhaWxzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhd2FpdCBsb2dUb0ZpbGUoXCJObyB2YWxpZCByZWNpcGllbnRzLCBza2lwcGluZyBhaXJkcm9wIG9uIGRldm5ldFwiKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXdhaXQgbG9nVG9GaWxlKFwiRGV2bmV0IHdhbGxldCBiYWxhbmNlIDw9IDAuMiBTT0wsIHNraXBwaW5nIGFpcmRyb3BcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhaXJkcm9wcGVkU29sID0gYWlyZHJvcHBlZExhbXBvcnRzIC8gTEFNUE9SVFNfUEVSX1NPTDtcclxuICAgIGF3YWl0IGFwcGVuZFRvRXhjZWwobmV3IERhdGUoKSwgY2xhaW1lZFNvbCwgYWlyZHJvcHBlZFNvbCk7XHJcbiAgICAvLyBFbWl0IFB1c2hlciB1cGRhdGVcclxuICAgIGNvbnN0IGRhc2hib2FyZERhdGEgPSBhd2FpdCByZXF1aXJlKFwiLi4vLi4vbGliL2V4Y2VsXCIpLnJlYWRFeGNlbERhdGEoKTtcclxuICAgIGF3YWl0IHB1c2hlci50cmlnZ2VyKFwiYWlyZHJvcC1jaGFubmVsXCIsIFwiZGFzaGJvYXJkLXVwZGF0ZVwiLCBkYXNoYm9hcmREYXRhKTtcclxuICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKHsgbWVzc2FnZTogXCJBaXJkcm9wIGN5Y2xlIGNvbXBsZXRlZFwiLCBjbGFpbWVkU29sLCBhaXJkcm9wcGVkU29sIH0pO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBhd2FpdCBsb2dUb0ZpbGUoYEVycm9yIGluIGFpcmRyb3AgbG9vcDogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogYEVycm9yIGluIGFpcmRyb3AgbG9vcDogJHtlcnJvci5tZXNzYWdlfWAgfSk7XHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbIkNvbm5lY3Rpb24iLCJMQU1QT1JUU19QRVJfU09MIiwicmVxdWlyZSIsImZzIiwicHJvbWlzZXMiLCJwYXRoIiwiUHVzaGVyIiwiaW5pdGlhbGl6ZUtleXBhaXIiLCJjbGFpbUZlZXNGb3JUb2tlbiIsImZldGNoVG9rZW5Ib2xkZXJzIiwidmFsaWRhdGVNYWlubmV0QWRkcmVzcyIsInNlbmRBaXJkcm9wIiwiYXBwZW5kVG9FeGNlbCIsInB1c2hlciIsImFwcElkIiwicHJvY2VzcyIsImVudiIsIlBVU0hFUl9BUFBfSUQiLCJrZXkiLCJQVVNIRVJfS0VZIiwic2VjcmV0IiwiUFVTSEVSX1NFQ1JFVCIsImNsdXN0ZXIiLCJQVVNIRVJfQ0xVU1RFUiIsInVzZVRMUyIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJjb25uZWN0aW9uIiwia2V5cGFpciIsImxvZ1RvRmlsZSIsIm1lc3NhZ2UiLCJsb2dGaWxlIiwiam9pbiIsImN3ZCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJhcHBlbmRGaWxlIiwiZXJyIiwiY29uc29sZSIsImxvZ0ZpbGVQYXRoIiwid3JpdGVGaWxlIiwiaG9sZGVyc1BlcmNlbnRhZ2UiLCJwYXJzZUZsb2F0IiwiSE9MREVSU19QRVJDRU5UQUdFIiwiZmVlV2FsbGV0UGVyY2VudGFnZSIsIkZFRV9XQUxMRVRfUEVSQ0VOVEFHRSIsIlRPS0VOX01JTlRfQUREUkVTUyIsImNsYWltZWRTb2wiLCJob2xkZXJzIiwicXVhbGlmaWVkSG9sZGVycyIsIk1JTklNVU1fVE9LRU5fQkFMQU5DRSIsImhvbGRlciIsImJhbGFuY2UiLCJob2xkZXJfYWRkcmVzcyIsInB1c2giLCJvdXRwdXRDb250ZW50IiwibGVuZ3RoIiwicmVwZWF0IiwibWFwIiwidG9rZW5fYWNjb3VudCIsInNvbWUiLCJxIiwiaG9sZGVyc0ZpbGVQYXRoIiwiZ2V0QmFsYW5jZSIsInB1YmxpY0tleSIsImFpcmRyb3BwZWRMYW1wb3J0cyIsIk1JTklNVU1fQkFMQU5DRSIsImRpc3RyaWJ1dGFibGVMYW1wb3J0cyIsIk1hdGgiLCJmbG9vciIsImZlZVdhbGxldFZhbGlkIiwiRkVFX1dBTExFVF9BRERSRVNTIiwiZmVlQW1vdW50IiwiaG9sZGVyc0Ftb3VudCIsImhvbGRlcnNDb3VudCIsInJlY2lwaWVudHMiLCJ3ZWlnaHRzIiwiYWRkcmVzcyIsImFtb3VudCIsImxvZzEwIiwidG90YWxXZWlnaHQiLCJyZWR1Y2UiLCJzdW0iLCJ3ZWlnaHQiLCJpIiwidG90YWxIb2xkZXJzQW1vdW50Iiwic2xpY2UiLCJyIiwiZGlzdHJpYnV0aW9uQ29udGVudCIsImZpbmQiLCJ0b0ZpeGVkIiwiYWlyZHJvcHBlZFNvbCIsImRhc2hib2FyZERhdGEiLCJyZWFkRXhjZWxEYXRhIiwidHJpZ2dlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/airdrop.js\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fairdrop&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cairdrop.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();