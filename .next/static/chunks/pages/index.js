/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CAdministrator%5CDesktop%5CRewards%5Cpages%5Cindex.js&page=%2F!":
/*!*********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CAdministrator%5CDesktop%5CRewards%5Cpages%5Cindex.js&page=%2F! ***!
  \*********************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.js */ \"./pages/index.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1DJTNBJTVDVXNlcnMlNUNBZG1pbmlzdHJhdG9yJTVDRGVza3RvcCU1Q1Jld2FyZHMlNUNwYWdlcyU1Q2luZGV4LmpzJnBhZ2U9JTJGISIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDBDQUFrQjtBQUN6QztBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/ZTkwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vcGFnZXMvaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CAdministrator%5CDesktop%5CRewards%5Cpages%5Cindex.js&page=%2F!\n"));

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var pusher_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pusher-js */ \"./node_modules/pusher-js/dist/web/pusher.js\");\n/* harmony import */ var pusher_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pusher_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _s = $RefreshSig$();\n\n\n\nfunction Home() {\n    _s();\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        data: [],\n        totalClaimed: 0,\n        totalAirdropped: 0,\n        lastUpdated: null\n    });\n    const [isDarkMode, setIsDarkMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Initialize Pusher with error handling\n        let pusher;\n        try {\n            if (false) {}\n            pusher = new (pusher_js__WEBPACK_IMPORTED_MODULE_2___default())(\"40c274c74b2cedb4d794\", {\n                cluster: \"ap1\",\n                useTLS: true\n            });\n            const channel = pusher.subscribe(\"airdrop-channel\");\n            channel.bind(\"dashboard-update\", (newData)=>{\n                setData(newData);\n                setError(null);\n            });\n            channel.bind(\"pusher:subscription_error\", (err)=>{\n                console.error(\"Pusher subscription error:\", err);\n                setError(\"Failed to subscribe to real-time updates\");\n            });\n        } catch (err) {\n            console.error(\"Pusher initialization error:\", err.message);\n            setError(\"Real-time updates unavailable\");\n        }\n        // Load dark mode preference from localStorage\n        const savedTheme = localStorage.getItem(\"theme\");\n        console.log(\"Loaded theme from localStorage:\", savedTheme);\n        if (savedTheme === \"dark\") {\n            setIsDarkMode(true);\n            document.documentElement.classList.add(\"dark\");\n            console.log(\"Applied dark mode on mount\");\n        }\n        // Fetch initial data\n        fetch(\"/api/dashboard\").then((res)=>res.json()).then(setData).catch((error)=>{\n            console.error(\"Error fetching dashboard data:\", error);\n            setError(\"Failed to load dashboard data\");\n        });\n        return ()=>{\n            if (pusher) {\n                pusher.unsubscribe(\"airdrop-channel\");\n                pusher.disconnect();\n            }\n        };\n    }, []);\n    const toggleDarkMode = ()=>{\n        setIsDarkMode((prev)=>{\n            const newMode = !prev;\n            console.log(\"Toggling dark mode to:\", newMode ? \"dark\" : \"light\");\n            if (newMode) {\n                document.documentElement.classList.add(\"dark\");\n                localStorage.setItem(\"theme\", \"dark\");\n            } else {\n                document.documentElement.classList.remove(\"dark\");\n                localStorage.setItem(\"theme\", \"light\");\n            }\n            return newMode;\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 flex flex-col items-center justify-center p-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_3___default()), {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                    children: \"Airdrop Dashboard\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                    lineNumber: 79,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                lineNumber: 78,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full max-w-4xl bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex justify-between items-center mb-6\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                className: \"text-2xl font-bold\",\n                                children: \"Airdrop Dashboard\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                lineNumber: 83,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: toggleDarkMode,\n                                className: \"px-4 py-2 bg-blue-500 dark:bg-blue-700 text-white rounded hover:bg-blue-600 dark:hover:bg-blue-800 transition\",\n                                children: isDarkMode ? \"Light Mode\" : \"Dark Mode\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                lineNumber: 84,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                        lineNumber: 82,\n                        columnNumber: 9\n                    }, this),\n                    error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mb-6 p-4 bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-200 rounded\",\n                        children: error\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                        lineNumber: 92,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid grid-cols-1 md:grid-cols-2 gap-4 mb-6\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"p-4 bg-gray-200 dark:bg-gray-700 rounded\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-lg font-semibold\",\n                                        children: \"Total Fees Claimed (SOL)\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                        lineNumber: 98,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-2xl\",\n                                        children: data.totalClaimed.toFixed(6)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                        lineNumber: 99,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                lineNumber: 97,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"p-4 bg-gray-200 dark:bg-gray-700 rounded\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-lg font-semibold\",\n                                        children: \"Total Airdrops Sent (SOL)\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                        lineNumber: 102,\n                                        columnNumber: 13\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-2xl\",\n                                        children: data.totalAirdropped.toFixed(6)\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                        lineNumber: 103,\n                                        columnNumber: 13\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                lineNumber: 101,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                        lineNumber: 96,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mb-6\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                className: \"text-lg font-semibold\",\n                                children: \"Last Updated\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                lineNumber: 107,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                children: data.lastUpdated ? new Date(data.lastUpdated).toLocaleString() : \"No data yet\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                lineNumber: 108,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                        lineNumber: 106,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                className: \"text-lg font-semibold mb-2\",\n                                children: \"Airdrop History\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                lineNumber: 111,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"overflow-x-auto\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n                                    className: \"w-full border-collapse\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"thead\", {\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                                className: \"bg-gray-300 dark:bg-gray-600\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                                        className: \"border p-2\",\n                                                        children: \"Date\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                                        lineNumber: 116,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                                        className: \"border p-2\",\n                                                        children: \"Fees Claimed (SOL)\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                                        lineNumber: 117,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                                        className: \"border p-2\",\n                                                        children: \"Airdrops Sent (SOL)\"\n                                                    }, void 0, false, {\n                                                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                                        lineNumber: 118,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                                lineNumber: 115,\n                                                columnNumber: 17\n                                            }, this)\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                            lineNumber: 114,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tbody\", {\n                                            children: data.data.map((row, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                                    className: \"odd:bg-white even:bg-gray-100 dark:odd:bg-gray-800 dark:even:bg-gray-700\",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                                            className: \"border p-2\",\n                                                            children: new Date(row.Date).toLocaleString()\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                                            lineNumber: 124,\n                                                            columnNumber: 21\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                                            className: \"border p-2\",\n                                                            children: row[\"Fees Claimed (SOL)\"].toFixed(6)\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                                            lineNumber: 125,\n                                                            columnNumber: 21\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                                            className: \"border p-2\",\n                                                            children: row[\"Airdrops Sent (SOL)\"].toFixed(6)\n                                                        }, void 0, false, {\n                                                            fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                                            lineNumber: 126,\n                                                            columnNumber: 21\n                                                        }, this)\n                                                    ]\n                                                }, index, true, {\n                                                    fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                                    lineNumber: 123,\n                                                    columnNumber: 19\n                                                }, this))\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                            lineNumber: 121,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                    lineNumber: 113,\n                                    columnNumber: 13\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                                lineNumber: 112,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                        lineNumber: 110,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n                lineNumber: 81,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Rewards\\\\pages\\\\index.js\",\n        lineNumber: 77,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"WHwv4OX0Hfnkn5rHBue6HIhIJKo=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs7c0VBQzlELDhEQUFDVzs0REFBR2xCLFdBQVU7c0VBQWNnQixHQUFHLENBQUMsc0JBQXNCLENBQUNULE9BQU8sQ0FBQzs7Ozs7OzttREFIeERVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFhM0I7R0FuSXdCL0Q7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXguanM/YmVlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCBQdXNoZXIgZnJvbSBcInB1c2hlci1qc1wiO1xyXG5pbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xyXG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IHVzZVN0YXRlKHsgZGF0YTogW10sIHRvdGFsQ2xhaW1lZDogMCwgdG90YWxBaXJkcm9wcGVkOiAwLCBsYXN0VXBkYXRlZDogbnVsbCB9KTtcclxuICBjb25zdCBbaXNEYXJrTW9kZSwgc2V0SXNEYXJrTW9kZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIEluaXRpYWxpemUgUHVzaGVyIHdpdGggZXJyb3IgaGFuZGxpbmdcclxuICAgIGxldCBwdXNoZXI7XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1BVU0hFUl9LRVkgfHwgIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1BVU0hFUl9DTFVTVEVSKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHVzaGVyIGNvbmZpZ3VyYXRpb24gbWlzc2luZ1wiKTtcclxuICAgICAgfVxyXG4gICAgICBwdXNoZXIgPSBuZXcgUHVzaGVyKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1BVU0hFUl9LRVksIHtcclxuICAgICAgICBjbHVzdGVyOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19QVVNIRVJfQ0xVU1RFUixcclxuICAgICAgICB1c2VUTFM6IHRydWUsXHJcbiAgICAgIH0pO1xyXG4gICAgICBjb25zdCBjaGFubmVsID0gcHVzaGVyLnN1YnNjcmliZShcImFpcmRyb3AtY2hhbm5lbFwiKTtcclxuICAgICAgY2hhbm5lbC5iaW5kKFwiZGFzaGJvYXJkLXVwZGF0ZVwiLCAobmV3RGF0YSkgPT4ge1xyXG4gICAgICAgIHNldERhdGEobmV3RGF0YSk7XHJcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBjaGFubmVsLmJpbmQoXCJwdXNoZXI6c3Vic2NyaXB0aW9uX2Vycm9yXCIsIChlcnIpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiUHVzaGVyIHN1YnNjcmlwdGlvbiBlcnJvcjpcIiwgZXJyKTtcclxuICAgICAgICBzZXRFcnJvcihcIkZhaWxlZCB0byBzdWJzY3JpYmUgdG8gcmVhbC10aW1lIHVwZGF0ZXNcIik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJQdXNoZXIgaW5pdGlhbGl6YXRpb24gZXJyb3I6XCIsIGVyci5tZXNzYWdlKTtcclxuICAgICAgc2V0RXJyb3IoXCJSZWFsLXRpbWUgdXBkYXRlcyB1bmF2YWlsYWJsZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMb2FkIGRhcmsgbW9kZSBwcmVmZXJlbmNlIGZyb20gbG9jYWxTdG9yYWdlXHJcbiAgICBjb25zdCBzYXZlZFRoZW1lID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0aGVtZVwiKTtcclxuICAgIGNvbnNvbGUubG9nKFwiTG9hZGVkIHRoZW1lIGZyb20gbG9jYWxTdG9yYWdlOlwiLCBzYXZlZFRoZW1lKTtcclxuICAgIGlmIChzYXZlZFRoZW1lID09PSBcImRhcmtcIikge1xyXG4gICAgICBzZXRJc0RhcmtNb2RlKHRydWUpO1xyXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRhcmtcIik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiQXBwbGllZCBkYXJrIG1vZGUgb24gbW91bnRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmV0Y2ggaW5pdGlhbCBkYXRhXHJcbiAgICBmZXRjaChcIi9hcGkvZGFzaGJvYXJkXCIpXHJcbiAgICAgIC50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpXHJcbiAgICAgIC50aGVuKHNldERhdGEpXHJcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgZGFzaGJvYXJkIGRhdGE6XCIsIGVycm9yKTtcclxuICAgICAgICBzZXRFcnJvcihcIkZhaWxlZCB0byBsb2FkIGRhc2hib2FyZCBkYXRhXCIpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpZiAocHVzaGVyKSB7XHJcbiAgICAgICAgcHVzaGVyLnVuc3Vic2NyaWJlKFwiYWlyZHJvcC1jaGFubmVsXCIpO1xyXG4gICAgICAgIHB1c2hlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCB0b2dnbGVEYXJrTW9kZSA9ICgpID0+IHtcclxuICAgIHNldElzRGFya01vZGUoKHByZXYpID0+IHtcclxuICAgICAgY29uc3QgbmV3TW9kZSA9ICFwcmV2O1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlRvZ2dsaW5nIGRhcmsgbW9kZSB0bzpcIiwgbmV3TW9kZSA/IFwiZGFya1wiIDogXCJsaWdodFwiKTtcclxuICAgICAgaWYgKG5ld01vZGUpIHtcclxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRhcmtcIik7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ0aGVtZVwiLCBcImRhcmtcIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkYXJrXCIpO1xyXG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidGhlbWVcIiwgXCJsaWdodFwiKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3TW9kZTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBiZy1ncmF5LTEwMCBkYXJrOmJnLWdyYXktOTAwIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LWdyYXktMTAwIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHAtNFwiPlxyXG4gICAgICA8SGVhZD5cclxuICAgICAgICA8dGl0bGU+QWlyZHJvcCBEYXNoYm9hcmQ8L3RpdGxlPlxyXG4gICAgICA8L0hlYWQ+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1heC13LTR4bCBiZy13aGl0ZSBkYXJrOmJnLWdyYXktODAwIHNoYWRvdy1sZyByb3VuZGVkLWxnIHAtNlwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIG1iLTZcIj5cclxuICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGRcIj5BaXJkcm9wIERhc2hib2FyZDwvaDE+XHJcbiAgICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICAgIG9uQ2xpY2s9e3RvZ2dsZURhcmtNb2RlfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgYmctYmx1ZS01MDAgZGFyazpiZy1ibHVlLTcwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgaG92ZXI6YmctYmx1ZS02MDAgZGFyazpob3ZlcjpiZy1ibHVlLTgwMCB0cmFuc2l0aW9uXCJcclxuICAgICAgICAgID5cclxuICAgICAgICAgICAge2lzRGFya01vZGUgPyBcIkxpZ2h0IE1vZGVcIiA6IFwiRGFyayBNb2RlXCJ9XHJcbiAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICB7ZXJyb3IgJiYgKFxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi02IHAtNCBiZy1yZWQtMTAwIGRhcms6YmctcmVkLTkwMCB0ZXh0LXJlZC03MDAgZGFyazp0ZXh0LXJlZC0yMDAgcm91bmRlZFwiPlxyXG4gICAgICAgICAgICB7ZXJyb3J9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApfVxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMSBtZDpncmlkLWNvbHMtMiBnYXAtNCBtYi02XCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNCBiZy1ncmF5LTIwMCBkYXJrOmJnLWdyYXktNzAwIHJvdW5kZWRcIj5cclxuICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZFwiPlRvdGFsIEZlZXMgQ2xhaW1lZCAoU09MKTwvaDI+XHJcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtMnhsXCI+e2RhdGEudG90YWxDbGFpbWVkLnRvRml4ZWQoNil9PC9wPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNCBiZy1ncmF5LTIwMCBkYXJrOmJnLWdyYXktNzAwIHJvdW5kZWRcIj5cclxuICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZFwiPlRvdGFsIEFpcmRyb3BzIFNlbnQgKFNPTCk8L2gyPlxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LTJ4bFwiPntkYXRhLnRvdGFsQWlyZHJvcHBlZC50b0ZpeGVkKDYpfTwvcD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNlwiPlxyXG4gICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1zZW1pYm9sZFwiPkxhc3QgVXBkYXRlZDwvaDI+XHJcbiAgICAgICAgICA8cD57ZGF0YS5sYXN0VXBkYXRlZCA/IG5ldyBEYXRlKGRhdGEubGFzdFVwZGF0ZWQpLnRvTG9jYWxlU3RyaW5nKCkgOiBcIk5vIGRhdGEgeWV0XCJ9PC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIG1iLTJcIj5BaXJkcm9wIEhpc3Rvcnk8L2gyPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJvdmVyZmxvdy14LWF1dG9cIj5cclxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInctZnVsbCBib3JkZXItY29sbGFwc2VcIj5cclxuICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICA8dHIgY2xhc3NOYW1lPVwiYmctZ3JheS0zMDAgZGFyazpiZy1ncmF5LTYwMFwiPlxyXG4gICAgICAgICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwiYm9yZGVyIHAtMlwiPkRhdGU8L3RoPlxyXG4gICAgICAgICAgICAgICAgICA8dGggY2xhc3NOYW1lPVwiYm9yZGVyIHAtMlwiPkZlZXMgQ2xhaW1lZCAoU09MKTwvdGg+XHJcbiAgICAgICAgICAgICAgICAgIDx0aCBjbGFzc05hbWU9XCJib3JkZXIgcC0yXCI+QWlyZHJvcHMgU2VudCAoU09MKTwvdGg+XHJcbiAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAge2RhdGEuZGF0YS5tYXAoKHJvdywgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgICAgICAgPHRyIGtleT17aW5kZXh9IGNsYXNzTmFtZT1cIm9kZDpiZy13aGl0ZSBldmVuOmJnLWdyYXktMTAwIGRhcms6b2RkOmJnLWdyYXktODAwIGRhcms6ZXZlbjpiZy1ncmF5LTcwMFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzc05hbWU9XCJib3JkZXIgcC0yXCI+e25ldyBEYXRlKHJvdy5EYXRlKS50b0xvY2FsZVN0cmluZygpfTwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cImJvcmRlciBwLTJcIj57cm93W1wiRmVlcyBDbGFpbWVkIChTT0wpXCJdLnRvRml4ZWQoNil9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3NOYW1lPVwiYm9yZGVyIHAtMlwiPntyb3dbXCJBaXJkcm9wcyBTZW50IChTT0wpXCJdLnRvRml4ZWQoNil9PC90ZD5cclxuICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICApO1xyXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiUHVzaGVyIiwiSGVhZCIsIkhvbWUiLCJkYXRhIiwic2V0RGF0YSIsInRvdGFsQ2xhaW1lZCIsInRvdGFsQWlyZHJvcHBlZCIsImxhc3RVcGRhdGVkIiwiaXNEYXJrTW9kZSIsInNldElzRGFya01vZGUiLCJlcnJvciIsInNldEVycm9yIiwicHVzaGVyIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1BVU0hFUl9LRVkiLCJORVhUX1BVQkxJQ19QVVNIRVJfQ0xVU1RFUiIsIkVycm9yIiwiY2x1c3RlciIsInVzZVRMUyIsImNoYW5uZWwiLCJzdWJzY3JpYmUiLCJiaW5kIiwibmV3RGF0YSIsImVyciIsImNvbnNvbGUiLCJtZXNzYWdlIiwic2F2ZWRUaGVtZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJsb2ciLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImZldGNoIiwidGhlbiIsInJlcyIsImpzb24iLCJjYXRjaCIsInVuc3Vic2NyaWJlIiwiZGlzY29ubmVjdCIsInRvZ2dsZURhcmtNb2RlIiwicHJldiIsIm5ld01vZGUiLCJzZXRJdGVtIiwicmVtb3ZlIiwiZGl2IiwiY2xhc3NOYW1lIiwidGl0bGUiLCJoMSIsImJ1dHRvbiIsIm9uQ2xpY2siLCJoMiIsInAiLCJ0b0ZpeGVkIiwiRGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwidGFibGUiLCJ0aGVhZCIsInRyIiwidGgiLCJ0Ym9keSIsIm1hcCIsInJvdyIsImluZGV4IiwidGQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/pusher-js/dist/web/pusher.js":
/*!***************************************************!*\
  !*** ./node_modules/pusher-js/dist/web/pusher.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*!\n * Pusher JavaScript Library v8.4.0\n * https://pusher.com/\n *\n * Copyright 2020, Pusher\n * Released under the MIT licence.\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_669__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_669__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_669__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_669__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_669__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_669__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_669__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_669__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_669__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_669__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_669__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_669__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_669__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_669__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_669__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_669__(__nested_webpack_require_669__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package base64 implements Base64 encoding and decoding.\n */\n// Invalid character used in decoding to indicate\n// that the character to decode is out of range of\n// alphabet and cannot be decoded.\nvar INVALID_BYTE = 256;\n/**\n * Implements standard Base64 encoding.\n *\n * Operates in constant time.\n */\nvar Coder = /** @class */ (function () {\n    // TODO(dchest): methods to encode chunk-by-chunk.\n    function Coder(_paddingCharacter) {\n        if (_paddingCharacter === void 0) { _paddingCharacter = \"=\"; }\n        this._paddingCharacter = _paddingCharacter;\n    }\n    Coder.prototype.encodedLength = function (length) {\n        if (!this._paddingCharacter) {\n            return (length * 8 + 5) / 6 | 0;\n        }\n        return (length + 2) / 3 * 4 | 0;\n    };\n    Coder.prototype.encode = function (data) {\n        var out = \"\";\n        var i = 0;\n        for (; i < data.length - 2; i += 3) {\n            var c = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            out += this._encodeByte((c >>> 1 * 6) & 63);\n            out += this._encodeByte((c >>> 0 * 6) & 63);\n        }\n        var left = data.length - i;\n        if (left > 0) {\n            var c = (data[i] << 16) | (left === 2 ? data[i + 1] << 8 : 0);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            if (left === 2) {\n                out += this._encodeByte((c >>> 1 * 6) & 63);\n            }\n            else {\n                out += this._paddingCharacter || \"\";\n            }\n            out += this._paddingCharacter || \"\";\n        }\n        return out;\n    };\n    Coder.prototype.maxDecodedLength = function (length) {\n        if (!this._paddingCharacter) {\n            return (length * 6 + 7) / 8 | 0;\n        }\n        return length / 4 * 3 | 0;\n    };\n    Coder.prototype.decodedLength = function (s) {\n        return this.maxDecodedLength(s.length - this._getPaddingLength(s));\n    };\n    Coder.prototype.decode = function (s) {\n        if (s.length === 0) {\n            return new Uint8Array(0);\n        }\n        var paddingLength = this._getPaddingLength(s);\n        var length = s.length - paddingLength;\n        var out = new Uint8Array(this.maxDecodedLength(length));\n        var op = 0;\n        var i = 0;\n        var haveBad = 0;\n        var v0 = 0, v1 = 0, v2 = 0, v3 = 0;\n        for (; i < length - 4; i += 4) {\n            v0 = this._decodeChar(s.charCodeAt(i + 0));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n            haveBad |= v2 & INVALID_BYTE;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (i < length - 1) {\n            v0 = this._decodeChar(s.charCodeAt(i));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n        }\n        if (i < length - 2) {\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            haveBad |= v2 & INVALID_BYTE;\n        }\n        if (i < length - 3) {\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (haveBad !== 0) {\n            throw new Error(\"Base64Coder: incorrect characters for decoding\");\n        }\n        return out;\n    };\n    // Standard encoding have the following encoded/decoded ranges,\n    // which we need to convert between.\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   43  47\n    //\n    // Encode 6 bits in b into a new character.\n    Coder.prototype._encodeByte = function (b) {\n        // Encoding uses constant time operations as follows:\n        //\n        // 1. Define comparison of A with B using (A - B) >>> 8:\n        //          if A > B, then result is positive integer\n        //          if A <= B, then result is 0\n        //\n        // 2. Define selection of C or 0 using bitwise AND: X & C:\n        //          if X == 0, then result is 0\n        //          if X != 0, then result is C\n        //\n        // 3. Start with the smallest comparison (b >= 0), which is always\n        //    true, so set the result to the starting ASCII value (65).\n        //\n        // 4. Continue comparing b to higher ASCII values, and selecting\n        //    zero if comparison isn't true, otherwise selecting a value\n        //    to add to result, which:\n        //\n        //          a) undoes the previous addition\n        //          b) provides new value to add\n        //\n        var result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 43);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 43) - 63 + 47);\n        return String.fromCharCode(result);\n    };\n    // Decode a character code into a byte.\n    // Must return 256 if character is out of alphabet range.\n    Coder.prototype._decodeChar = function (c) {\n        // Decoding works similar to encoding: using the same comparison\n        // function, but now it works on ranges: result is always incremented\n        // by value, but this value becomes zero if the range is not\n        // satisfied.\n        //\n        // Decoding starts with invalid value, 256, which is then\n        // subtracted when the range is satisfied. If none of the ranges\n        // apply, the function returns 256, which is then checked by\n        // the caller to throw error.\n        var result = INVALID_BYTE; // start with invalid character\n        // c == 43 (c > 42 and c < 44)\n        result += (((42 - c) & (c - 44)) >>> 8) & (-INVALID_BYTE + c - 43 + 62);\n        // c == 47 (c > 46 and c < 48)\n        result += (((46 - c) & (c - 48)) >>> 8) & (-INVALID_BYTE + c - 47 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n        return result;\n    };\n    Coder.prototype._getPaddingLength = function (s) {\n        var paddingLength = 0;\n        if (this._paddingCharacter) {\n            for (var i = s.length - 1; i >= 0; i--) {\n                if (s[i] !== this._paddingCharacter) {\n                    break;\n                }\n                paddingLength++;\n            }\n            if (s.length < 4 || paddingLength > 2) {\n                throw new Error(\"Base64Coder: incorrect padding\");\n            }\n        }\n        return paddingLength;\n    };\n    return Coder;\n}());\nexports.Coder = Coder;\nvar stdCoder = new Coder();\nfunction encode(data) {\n    return stdCoder.encode(data);\n}\nexports.encode = encode;\nfunction decode(s) {\n    return stdCoder.decode(s);\n}\nexports.decode = decode;\n/**\n * Implements URL-safe Base64 encoding.\n * (Same as Base64, but '+' is replaced with '-', and '/' with '_').\n *\n * Operates in constant time.\n */\nvar URLSafeCoder = /** @class */ (function (_super) {\n    __extends(URLSafeCoder, _super);\n    function URLSafeCoder() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // URL-safe encoding have the following encoded/decoded ranges:\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   45  95\n    //\n    URLSafeCoder.prototype._encodeByte = function (b) {\n        var result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 45);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 45) - 63 + 95);\n        return String.fromCharCode(result);\n    };\n    URLSafeCoder.prototype._decodeChar = function (c) {\n        var result = INVALID_BYTE;\n        // c == 45 (c > 44 and c < 46)\n        result += (((44 - c) & (c - 46)) >>> 8) & (-INVALID_BYTE + c - 45 + 62);\n        // c == 95 (c > 94 and c < 96)\n        result += (((94 - c) & (c - 96)) >>> 8) & (-INVALID_BYTE + c - 95 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n        return result;\n    };\n    return URLSafeCoder;\n}(Coder));\nexports.URLSafeCoder = URLSafeCoder;\nvar urlSafeCoder = new URLSafeCoder();\nfunction encodeURLSafe(data) {\n    return urlSafeCoder.encode(data);\n}\nexports.encodeURLSafe = encodeURLSafe;\nfunction decodeURLSafe(s) {\n    return urlSafeCoder.decode(s);\n}\nexports.decodeURLSafe = decodeURLSafe;\nexports.encodedLength = function (length) {\n    return stdCoder.encodedLength(length);\n};\nexports.maxDecodedLength = function (length) {\n    return stdCoder.maxDecodedLength(length);\n};\nexports.decodedLength = function (s) {\n    return stdCoder.decodedLength(s);\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package utf8 implements UTF-8 encoding and decoding.\n */\nvar INVALID_UTF16 = \"utf8: invalid string\";\nvar INVALID_UTF8 = \"utf8: invalid source encoding\";\n/**\n * Encodes the given string into UTF-8 byte array.\n * Throws if the source string has invalid UTF-16 encoding.\n */\nfunction encode(s) {\n    // Calculate result length and allocate output array.\n    // encodedLength() also validates string and throws errors,\n    // so we don't need repeat validation here.\n    var arr = new Uint8Array(encodedLength(s));\n    var pos = 0;\n    for (var i = 0; i < s.length; i++) {\n        var c = s.charCodeAt(i);\n        if (c < 0x80) {\n            arr[pos++] = c;\n        }\n        else if (c < 0x800) {\n            arr[pos++] = 0xc0 | c >> 6;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n        else if (c < 0xd800) {\n            arr[pos++] = 0xe0 | c >> 12;\n            arr[pos++] = 0x80 | (c >> 6) & 0x3f;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n        else {\n            i++; // get one more character\n            c = (c & 0x3ff) << 10;\n            c |= s.charCodeAt(i) & 0x3ff;\n            c += 0x10000;\n            arr[pos++] = 0xf0 | c >> 18;\n            arr[pos++] = 0x80 | (c >> 12) & 0x3f;\n            arr[pos++] = 0x80 | (c >> 6) & 0x3f;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n    }\n    return arr;\n}\nexports.encode = encode;\n/**\n * Returns the number of bytes required to encode the given string into UTF-8.\n * Throws if the source string has invalid UTF-16 encoding.\n */\nfunction encodedLength(s) {\n    var result = 0;\n    for (var i = 0; i < s.length; i++) {\n        var c = s.charCodeAt(i);\n        if (c < 0x80) {\n            result += 1;\n        }\n        else if (c < 0x800) {\n            result += 2;\n        }\n        else if (c < 0xd800) {\n            result += 3;\n        }\n        else if (c <= 0xdfff) {\n            if (i >= s.length - 1) {\n                throw new Error(INVALID_UTF16);\n            }\n            i++; // \"eat\" next character\n            result += 4;\n        }\n        else {\n            throw new Error(INVALID_UTF16);\n        }\n    }\n    return result;\n}\nexports.encodedLength = encodedLength;\n/**\n * Decodes the given byte array from UTF-8 into a string.\n * Throws if encoding is invalid.\n */\nfunction decode(arr) {\n    var chars = [];\n    for (var i = 0; i < arr.length; i++) {\n        var b = arr[i];\n        if (b & 0x80) {\n            var min = void 0;\n            if (b < 0xe0) {\n                // Need 1 more byte.\n                if (i >= arr.length) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x1f) << 6 | (n1 & 0x3f);\n                min = 0x80;\n            }\n            else if (b < 0xf0) {\n                // Need 2 more bytes.\n                if (i >= arr.length - 1) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                var n2 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | (n2 & 0x3f);\n                min = 0x800;\n            }\n            else if (b < 0xf8) {\n                // Need 3 more bytes.\n                if (i >= arr.length - 2) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                var n2 = arr[++i];\n                var n3 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | (n3 & 0x3f);\n                min = 0x10000;\n            }\n            else {\n                throw new Error(INVALID_UTF8);\n            }\n            if (b < min || (b >= 0xd800 && b <= 0xdfff)) {\n                throw new Error(INVALID_UTF8);\n            }\n            if (b >= 0x10000) {\n                // Surrogate pair.\n                if (b > 0x10ffff) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b -= 0x10000;\n                chars.push(String.fromCharCode(0xd800 | (b >> 10)));\n                b = 0xdc00 | (b & 0x3ff);\n            }\n        }\n        chars.push(String.fromCharCode(b));\n    }\n    return chars.join(\"\");\n}\nexports.decode = decode;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_19901__) {\n\n// required so we don't have to do require('pusher').default etc.\nmodule.exports = __nested_webpack_require_19901__(3).default;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __nested_webpack_exports__, __nested_webpack_require_20105__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__nested_webpack_require_20105__.r(__nested_webpack_exports__);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/script_receiver_factory.ts\nclass ScriptReceiverFactory {\n    constructor(prefix, name) {\n        this.lastId = 0;\n        this.prefix = prefix;\n        this.name = name;\n    }\n    create(callback) {\n        this.lastId++;\n        var number = this.lastId;\n        var id = this.prefix + number;\n        var name = this.name + '[' + number + ']';\n        var called = false;\n        var callbackWrapper = function () {\n            if (!called) {\n                callback.apply(null, arguments);\n                called = true;\n            }\n        };\n        this[number] = callbackWrapper;\n        return { number: number, id: id, name: name, callback: callbackWrapper };\n    }\n    remove(receiver) {\n        delete this[receiver.number];\n    }\n}\nvar ScriptReceivers = new ScriptReceiverFactory('_pusher_script_', 'Pusher.ScriptReceivers');\n\n// CONCATENATED MODULE: ./src/core/defaults.ts\nvar Defaults = {\n    VERSION: \"8.4.0\",\n    PROTOCOL: 7,\n    wsPort: 80,\n    wssPort: 443,\n    wsPath: '',\n    httpHost: 'sockjs.pusher.com',\n    httpPort: 80,\n    httpsPort: 443,\n    httpPath: '/pusher',\n    stats_host: 'stats.pusher.com',\n    authEndpoint: '/pusher/auth',\n    authTransport: 'ajax',\n    activityTimeout: 120000,\n    pongTimeout: 30000,\n    unavailableTimeout: 10000,\n    userAuthentication: {\n        endpoint: '/pusher/user-auth',\n        transport: 'ajax',\n    },\n    channelAuthorization: {\n        endpoint: '/pusher/auth',\n        transport: 'ajax',\n    },\n    cdn_http: \"http://js.pusher.com\",\n    cdn_https: \"https://js.pusher.com\",\n    dependency_suffix: \"\",\n};\n/* harmony default export */ var defaults = (Defaults);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/dependency_loader.ts\n\n\nclass dependency_loader_DependencyLoader {\n    constructor(options) {\n        this.options = options;\n        this.receivers = options.receivers || ScriptReceivers;\n        this.loading = {};\n    }\n    load(name, options, callback) {\n        var self = this;\n        if (self.loading[name] && self.loading[name].length > 0) {\n            self.loading[name].push(callback);\n        }\n        else {\n            self.loading[name] = [callback];\n            var request = runtime.createScriptRequest(self.getPath(name, options));\n            var receiver = self.receivers.create(function (error) {\n                self.receivers.remove(receiver);\n                if (self.loading[name]) {\n                    var callbacks = self.loading[name];\n                    delete self.loading[name];\n                    var successCallback = function (wasSuccessful) {\n                        if (!wasSuccessful) {\n                            request.cleanup();\n                        }\n                    };\n                    for (var i = 0; i < callbacks.length; i++) {\n                        callbacks[i](error, successCallback);\n                    }\n                }\n            });\n            request.send(receiver);\n        }\n    }\n    getRoot(options) {\n        var cdn;\n        var protocol = runtime.getDocument().location.protocol;\n        if ((options && options.useTLS) || protocol === 'https:') {\n            cdn = this.options.cdn_https;\n        }\n        else {\n            cdn = this.options.cdn_http;\n        }\n        return cdn.replace(/\\/*$/, '') + '/' + this.options.version;\n    }\n    getPath(name, options) {\n        return this.getRoot(options) + '/' + name + this.options.suffix + '.js';\n    }\n}\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/dependencies.ts\n\n\n\nvar DependenciesReceivers = new ScriptReceiverFactory('_pusher_dependencies', 'Pusher.DependenciesReceivers');\nvar Dependencies = new dependency_loader_DependencyLoader({\n    cdn_http: defaults.cdn_http,\n    cdn_https: defaults.cdn_https,\n    version: defaults.VERSION,\n    suffix: defaults.dependency_suffix,\n    receivers: DependenciesReceivers,\n});\n\n// CONCATENATED MODULE: ./src/core/utils/url_store.ts\nconst urlStore = {\n    baseUrl: 'https://pusher.com',\n    urls: {\n        authenticationEndpoint: {\n            path: '/docs/channels/server_api/authenticating_users',\n        },\n        authorizationEndpoint: {\n            path: '/docs/channels/server_api/authorizing-users/',\n        },\n        javascriptQuickStart: {\n            path: '/docs/javascript_quick_start',\n        },\n        triggeringClientEvents: {\n            path: '/docs/client_api_guide/client_events#trigger-events',\n        },\n        encryptedChannelSupport: {\n            fullUrl: 'https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support',\n        },\n    },\n};\nconst buildLogSuffix = function (key) {\n    const urlPrefix = 'See:';\n    const urlObj = urlStore.urls[key];\n    if (!urlObj)\n        return '';\n    let url;\n    if (urlObj.fullUrl) {\n        url = urlObj.fullUrl;\n    }\n    else if (urlObj.path) {\n        url = urlStore.baseUrl + urlObj.path;\n    }\n    if (!url)\n        return '';\n    return `${urlPrefix} ${url}`;\n};\n/* harmony default export */ var url_store = ({ buildLogSuffix });\n\n// CONCATENATED MODULE: ./src/core/auth/options.ts\nvar AuthRequestType;\n(function (AuthRequestType) {\n    AuthRequestType[\"UserAuthentication\"] = \"user-authentication\";\n    AuthRequestType[\"ChannelAuthorization\"] = \"channel-authorization\";\n})(AuthRequestType || (AuthRequestType = {}));\n\n// CONCATENATED MODULE: ./src/core/errors.ts\nclass BadEventName extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass BadChannelName extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass RequestTimedOut extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass TransportPriorityTooLow extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass TransportClosed extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass UnsupportedFeature extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass UnsupportedTransport extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass UnsupportedStrategy extends Error {\n    constructor(msg) {\n        super(msg);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nclass HTTPAuthError extends Error {\n    constructor(status, msg) {\n        super(msg);\n        this.status = status;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/auth/xhr_auth.ts\n\n\n\n\nconst ajax = function (context, query, authOptions, authRequestType, callback) {\n    const xhr = runtime.createXHR();\n    xhr.open('POST', authOptions.endpoint, true);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    for (var headerName in authOptions.headers) {\n        xhr.setRequestHeader(headerName, authOptions.headers[headerName]);\n    }\n    if (authOptions.headersProvider != null) {\n        let dynamicHeaders = authOptions.headersProvider();\n        for (var headerName in dynamicHeaders) {\n            xhr.setRequestHeader(headerName, dynamicHeaders[headerName]);\n        }\n    }\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                let data;\n                let parsed = false;\n                try {\n                    data = JSON.parse(xhr.responseText);\n                    parsed = true;\n                }\n                catch (e) {\n                    callback(new HTTPAuthError(200, `JSON returned from ${authRequestType.toString()} endpoint was invalid, yet status code was 200. Data was: ${xhr.responseText}`), null);\n                }\n                if (parsed) {\n                    callback(null, data);\n                }\n            }\n            else {\n                let suffix = '';\n                switch (authRequestType) {\n                    case AuthRequestType.UserAuthentication:\n                        suffix = url_store.buildLogSuffix('authenticationEndpoint');\n                        break;\n                    case AuthRequestType.ChannelAuthorization:\n                        suffix = `Clients must be authorized to join private or presence channels. ${url_store.buildLogSuffix('authorizationEndpoint')}`;\n                        break;\n                }\n                callback(new HTTPAuthError(xhr.status, `Unable to retrieve auth string from ${authRequestType.toString()} endpoint - ` +\n                    `received status: ${xhr.status} from ${authOptions.endpoint}. ${suffix}`), null);\n            }\n        }\n    };\n    xhr.send(query);\n    return xhr;\n};\n/* harmony default export */ var xhr_auth = (ajax);\n\n// CONCATENATED MODULE: ./src/core/base64.ts\nfunction encode(s) {\n    return btoa(utob(s));\n}\nvar fromCharCode = String.fromCharCode;\nvar b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nvar b64tab = {};\nfor (var base64_i = 0, l = b64chars.length; base64_i < l; base64_i++) {\n    b64tab[b64chars.charAt(base64_i)] = base64_i;\n}\nvar cb_utob = function (c) {\n    var cc = c.charCodeAt(0);\n    return cc < 0x80\n        ? c\n        : cc < 0x800\n            ? fromCharCode(0xc0 | (cc >>> 6)) + fromCharCode(0x80 | (cc & 0x3f))\n            : fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) +\n                fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) +\n                fromCharCode(0x80 | (cc & 0x3f));\n};\nvar utob = function (u) {\n    return u.replace(/[^\\x00-\\x7F]/g, cb_utob);\n};\nvar cb_encode = function (ccc) {\n    var padlen = [0, 2, 1][ccc.length % 3];\n    var ord = (ccc.charCodeAt(0) << 16) |\n        ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) |\n        (ccc.length > 2 ? ccc.charCodeAt(2) : 0);\n    var chars = [\n        b64chars.charAt(ord >>> 18),\n        b64chars.charAt((ord >>> 12) & 63),\n        padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n        padlen >= 1 ? '=' : b64chars.charAt(ord & 63),\n    ];\n    return chars.join('');\n};\nvar btoa = window.btoa ||\n    function (b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n\n// CONCATENATED MODULE: ./src/core/utils/timers/abstract_timer.ts\nclass Timer {\n    constructor(set, clear, delay, callback) {\n        this.clear = clear;\n        this.timer = set(() => {\n            if (this.timer) {\n                this.timer = callback(this.timer);\n            }\n        }, delay);\n    }\n    isRunning() {\n        return this.timer !== null;\n    }\n    ensureAborted() {\n        if (this.timer) {\n            this.clear(this.timer);\n            this.timer = null;\n        }\n    }\n}\n/* harmony default export */ var abstract_timer = (Timer);\n\n// CONCATENATED MODULE: ./src/core/utils/timers/index.ts\n\nfunction timers_clearTimeout(timer) {\n    window.clearTimeout(timer);\n}\nfunction timers_clearInterval(timer) {\n    window.clearInterval(timer);\n}\nclass timers_OneOffTimer extends abstract_timer {\n    constructor(delay, callback) {\n        super(setTimeout, timers_clearTimeout, delay, function (timer) {\n            callback();\n            return null;\n        });\n    }\n}\nclass timers_PeriodicTimer extends abstract_timer {\n    constructor(delay, callback) {\n        super(setInterval, timers_clearInterval, delay, function (timer) {\n            callback();\n            return timer;\n        });\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/util.ts\n\nvar Util = {\n    now() {\n        if (Date.now) {\n            return Date.now();\n        }\n        else {\n            return new Date().valueOf();\n        }\n    },\n    defer(callback) {\n        return new timers_OneOffTimer(0, callback);\n    },\n    method(name, ...args) {\n        var boundArguments = Array.prototype.slice.call(arguments, 1);\n        return function (object) {\n            return object[name].apply(object, boundArguments.concat(arguments));\n        };\n    },\n};\n/* harmony default export */ var util = (Util);\n\n// CONCATENATED MODULE: ./src/core/utils/collections.ts\n\n\nfunction extend(target, ...sources) {\n    for (var i = 0; i < sources.length; i++) {\n        var extensions = sources[i];\n        for (var property in extensions) {\n            if (extensions[property] &&\n                extensions[property].constructor &&\n                extensions[property].constructor === Object) {\n                target[property] = extend(target[property] || {}, extensions[property]);\n            }\n            else {\n                target[property] = extensions[property];\n            }\n        }\n    }\n    return target;\n}\nfunction stringify() {\n    var m = ['Pusher'];\n    for (var i = 0; i < arguments.length; i++) {\n        if (typeof arguments[i] === 'string') {\n            m.push(arguments[i]);\n        }\n        else {\n            m.push(safeJSONStringify(arguments[i]));\n        }\n    }\n    return m.join(' : ');\n}\nfunction arrayIndexOf(array, item) {\n    var nativeIndexOf = Array.prototype.indexOf;\n    if (array === null) {\n        return -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) {\n        return array.indexOf(item);\n    }\n    for (var i = 0, l = array.length; i < l; i++) {\n        if (array[i] === item) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction objectApply(object, f) {\n    for (var key in object) {\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            f(object[key], key, object);\n        }\n    }\n}\nfunction keys(object) {\n    var keys = [];\n    objectApply(object, function (_, key) {\n        keys.push(key);\n    });\n    return keys;\n}\nfunction values(object) {\n    var values = [];\n    objectApply(object, function (value) {\n        values.push(value);\n    });\n    return values;\n}\nfunction apply(array, f, context) {\n    for (var i = 0; i < array.length; i++) {\n        f.call(context || window, array[i], i, array);\n    }\n}\nfunction map(array, f) {\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n        result.push(f(array[i], i, array, result));\n    }\n    return result;\n}\nfunction mapObject(object, f) {\n    var result = {};\n    objectApply(object, function (value, key) {\n        result[key] = f(value);\n    });\n    return result;\n}\nfunction filter(array, test) {\n    test =\n        test ||\n            function (value) {\n                return !!value;\n            };\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array, result)) {\n            result.push(array[i]);\n        }\n    }\n    return result;\n}\nfunction filterObject(object, test) {\n    var result = {};\n    objectApply(object, function (value, key) {\n        if ((test && test(value, key, object, result)) || Boolean(value)) {\n            result[key] = value;\n        }\n    });\n    return result;\n}\nfunction flatten(object) {\n    var result = [];\n    objectApply(object, function (value, key) {\n        result.push([key, value]);\n    });\n    return result;\n}\nfunction any(array, test) {\n    for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction collections_all(array, test) {\n    for (var i = 0; i < array.length; i++) {\n        if (!test(array[i], i, array)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction encodeParamsObject(data) {\n    return mapObject(data, function (value) {\n        if (typeof value === 'object') {\n            value = safeJSONStringify(value);\n        }\n        return encodeURIComponent(encode(value.toString()));\n    });\n}\nfunction buildQueryString(data) {\n    var params = filterObject(data, function (value) {\n        return value !== undefined;\n    });\n    var query = map(flatten(encodeParamsObject(params)), util.method('join', '=')).join('&');\n    return query;\n}\nfunction decycleObject(object) {\n    var objects = [], paths = [];\n    return (function derez(value, path) {\n        var i, name, nu;\n        switch (typeof value) {\n            case 'object':\n                if (!value) {\n                    return null;\n                }\n                for (i = 0; i < objects.length; i += 1) {\n                    if (objects[i] === value) {\n                        return { $ref: paths[i] };\n                    }\n                }\n                objects.push(value);\n                paths.push(path);\n                if (Object.prototype.toString.apply(value) === '[object Array]') {\n                    nu = [];\n                    for (i = 0; i < value.length; i += 1) {\n                        nu[i] = derez(value[i], path + '[' + i + ']');\n                    }\n                }\n                else {\n                    nu = {};\n                    for (name in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, name)) {\n                            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n                        }\n                    }\n                }\n                return nu;\n            case 'number':\n            case 'string':\n            case 'boolean':\n                return value;\n        }\n    })(object, '$');\n}\nfunction safeJSONStringify(source) {\n    try {\n        return JSON.stringify(source);\n    }\n    catch (e) {\n        return JSON.stringify(decycleObject(source));\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/logger.ts\n\n\nclass logger_Logger {\n    constructor() {\n        this.globalLog = (message) => {\n            if (window.console && window.console.log) {\n                window.console.log(message);\n            }\n        };\n    }\n    debug(...args) {\n        this.log(this.globalLog, args);\n    }\n    warn(...args) {\n        this.log(this.globalLogWarn, args);\n    }\n    error(...args) {\n        this.log(this.globalLogError, args);\n    }\n    globalLogWarn(message) {\n        if (window.console && window.console.warn) {\n            window.console.warn(message);\n        }\n        else {\n            this.globalLog(message);\n        }\n    }\n    globalLogError(message) {\n        if (window.console && window.console.error) {\n            window.console.error(message);\n        }\n        else {\n            this.globalLogWarn(message);\n        }\n    }\n    log(defaultLoggingFunction, ...args) {\n        var message = stringify.apply(this, arguments);\n        if (core_pusher.log) {\n            core_pusher.log(message);\n        }\n        else if (core_pusher.logToConsole) {\n            const log = defaultLoggingFunction.bind(this);\n            log(message);\n        }\n    }\n}\n/* harmony default export */ var logger = (new logger_Logger());\n\n// CONCATENATED MODULE: ./src/runtimes/web/auth/jsonp_auth.ts\n\nvar jsonp = function (context, query, authOptions, authRequestType, callback) {\n    if (authOptions.headers !== undefined ||\n        authOptions.headersProvider != null) {\n        logger.warn(`To send headers with the ${authRequestType.toString()} request, you must use AJAX, rather than JSONP.`);\n    }\n    var callbackName = context.nextAuthCallbackID.toString();\n    context.nextAuthCallbackID++;\n    var document = context.getDocument();\n    var script = document.createElement('script');\n    context.auth_callbacks[callbackName] = function (data) {\n        callback(null, data);\n    };\n    var callback_name = \"Pusher.auth_callbacks['\" + callbackName + \"']\";\n    script.src =\n        authOptions.endpoint +\n            '?callback=' +\n            encodeURIComponent(callback_name) +\n            '&' +\n            query;\n    var head = document.getElementsByTagName('head')[0] || document.documentElement;\n    head.insertBefore(script, head.firstChild);\n};\n/* harmony default export */ var jsonp_auth = (jsonp);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/script_request.ts\nclass ScriptRequest {\n    constructor(src) {\n        this.src = src;\n    }\n    send(receiver) {\n        var self = this;\n        var errorString = 'Error loading ' + self.src;\n        self.script = document.createElement('script');\n        self.script.id = receiver.id;\n        self.script.src = self.src;\n        self.script.type = 'text/javascript';\n        self.script.charset = 'UTF-8';\n        if (self.script.addEventListener) {\n            self.script.onerror = function () {\n                receiver.callback(errorString);\n            };\n            self.script.onload = function () {\n                receiver.callback(null);\n            };\n        }\n        else {\n            self.script.onreadystatechange = function () {\n                if (self.script.readyState === 'loaded' ||\n                    self.script.readyState === 'complete') {\n                    receiver.callback(null);\n                }\n            };\n        }\n        if (self.script.async === undefined &&\n            document.attachEvent &&\n            /opera/i.test(navigator.userAgent)) {\n            self.errorScript = document.createElement('script');\n            self.errorScript.id = receiver.id + '_error';\n            self.errorScript.text = receiver.name + \"('\" + errorString + \"');\";\n            self.script.async = self.errorScript.async = false;\n        }\n        else {\n            self.script.async = true;\n        }\n        var head = document.getElementsByTagName('head')[0];\n        head.insertBefore(self.script, head.firstChild);\n        if (self.errorScript) {\n            head.insertBefore(self.errorScript, self.script.nextSibling);\n        }\n    }\n    cleanup() {\n        if (this.script) {\n            this.script.onload = this.script.onerror = null;\n            this.script.onreadystatechange = null;\n        }\n        if (this.script && this.script.parentNode) {\n            this.script.parentNode.removeChild(this.script);\n        }\n        if (this.errorScript && this.errorScript.parentNode) {\n            this.errorScript.parentNode.removeChild(this.errorScript);\n        }\n        this.script = null;\n        this.errorScript = null;\n    }\n}\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/jsonp_request.ts\n\n\nclass jsonp_request_JSONPRequest {\n    constructor(url, data) {\n        this.url = url;\n        this.data = data;\n    }\n    send(receiver) {\n        if (this.request) {\n            return;\n        }\n        var query = buildQueryString(this.data);\n        var url = this.url + '/' + receiver.number + '?' + query;\n        this.request = runtime.createScriptRequest(url);\n        this.request.send(receiver);\n    }\n    cleanup() {\n        if (this.request) {\n            this.request.cleanup();\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/runtimes/web/timeline/jsonp_timeline.ts\n\n\nvar getAgent = function (sender, useTLS) {\n    return function (data, callback) {\n        var scheme = 'http' + (useTLS ? 's' : '') + '://';\n        var url = scheme + (sender.host || sender.options.host) + sender.options.path;\n        var request = runtime.createJSONPRequest(url, data);\n        var receiver = runtime.ScriptReceivers.create(function (error, result) {\n            ScriptReceivers.remove(receiver);\n            request.cleanup();\n            if (result && result.host) {\n                sender.host = result.host;\n            }\n            if (callback) {\n                callback(error, result);\n            }\n        });\n        request.send(receiver);\n    };\n};\nvar jsonp_timeline_jsonp = {\n    name: 'jsonp',\n    getAgent,\n};\n/* harmony default export */ var jsonp_timeline = (jsonp_timeline_jsonp);\n\n// CONCATENATED MODULE: ./src/core/transports/url_schemes.ts\n\nfunction getGenericURL(baseScheme, params, path) {\n    var scheme = baseScheme + (params.useTLS ? 's' : '');\n    var host = params.useTLS ? params.hostTLS : params.hostNonTLS;\n    return scheme + '://' + host + path;\n}\nfunction getGenericPath(key, queryString) {\n    var path = '/app/' + key;\n    var query = '?protocol=' +\n        defaults.PROTOCOL +\n        '&client=js' +\n        '&version=' +\n        defaults.VERSION +\n        (queryString ? '&' + queryString : '');\n    return path + query;\n}\nvar ws = {\n    getInitial: function (key, params) {\n        var path = (params.httpPath || '') + getGenericPath(key, 'flash=false');\n        return getGenericURL('ws', params, path);\n    },\n};\nvar http = {\n    getInitial: function (key, params) {\n        var path = (params.httpPath || '/pusher') + getGenericPath(key);\n        return getGenericURL('http', params, path);\n    },\n};\nvar sockjs = {\n    getInitial: function (key, params) {\n        return getGenericURL('http', params, params.httpPath || '/pusher');\n    },\n    getPath: function (key, params) {\n        return getGenericPath(key);\n    },\n};\n\n// CONCATENATED MODULE: ./src/core/events/callback_registry.ts\n\nclass callback_registry_CallbackRegistry {\n    constructor() {\n        this._callbacks = {};\n    }\n    get(name) {\n        return this._callbacks[prefix(name)];\n    }\n    add(name, callback, context) {\n        var prefixedEventName = prefix(name);\n        this._callbacks[prefixedEventName] =\n            this._callbacks[prefixedEventName] || [];\n        this._callbacks[prefixedEventName].push({\n            fn: callback,\n            context: context,\n        });\n    }\n    remove(name, callback, context) {\n        if (!name && !callback && !context) {\n            this._callbacks = {};\n            return;\n        }\n        var names = name ? [prefix(name)] : keys(this._callbacks);\n        if (callback || context) {\n            this.removeCallback(names, callback, context);\n        }\n        else {\n            this.removeAllCallbacks(names);\n        }\n    }\n    removeCallback(names, callback, context) {\n        apply(names, function (name) {\n            this._callbacks[name] = filter(this._callbacks[name] || [], function (binding) {\n                return ((callback && callback !== binding.fn) ||\n                    (context && context !== binding.context));\n            });\n            if (this._callbacks[name].length === 0) {\n                delete this._callbacks[name];\n            }\n        }, this);\n    }\n    removeAllCallbacks(names) {\n        apply(names, function (name) {\n            delete this._callbacks[name];\n        }, this);\n    }\n}\nfunction prefix(name) {\n    return '_' + name;\n}\n\n// CONCATENATED MODULE: ./src/core/events/dispatcher.ts\n\n\nclass dispatcher_Dispatcher {\n    constructor(failThrough) {\n        this.callbacks = new callback_registry_CallbackRegistry();\n        this.global_callbacks = [];\n        this.failThrough = failThrough;\n    }\n    bind(eventName, callback, context) {\n        this.callbacks.add(eventName, callback, context);\n        return this;\n    }\n    bind_global(callback) {\n        this.global_callbacks.push(callback);\n        return this;\n    }\n    unbind(eventName, callback, context) {\n        this.callbacks.remove(eventName, callback, context);\n        return this;\n    }\n    unbind_global(callback) {\n        if (!callback) {\n            this.global_callbacks = [];\n            return this;\n        }\n        this.global_callbacks = filter(this.global_callbacks || [], (c) => c !== callback);\n        return this;\n    }\n    unbind_all() {\n        this.unbind();\n        this.unbind_global();\n        return this;\n    }\n    emit(eventName, data, metadata) {\n        for (var i = 0; i < this.global_callbacks.length; i++) {\n            this.global_callbacks[i](eventName, data);\n        }\n        var callbacks = this.callbacks.get(eventName);\n        var args = [];\n        if (metadata) {\n            args.push(data, metadata);\n        }\n        else if (data) {\n            args.push(data);\n        }\n        if (callbacks && callbacks.length > 0) {\n            for (var i = 0; i < callbacks.length; i++) {\n                callbacks[i].fn.apply(callbacks[i].context || window, args);\n            }\n        }\n        else if (this.failThrough) {\n            this.failThrough(eventName, data);\n        }\n        return this;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/transports/transport_connection.ts\n\n\n\n\n\nclass transport_connection_TransportConnection extends dispatcher_Dispatcher {\n    constructor(hooks, name, priority, key, options) {\n        super();\n        this.initialize = runtime.transportConnectionInitializer;\n        this.hooks = hooks;\n        this.name = name;\n        this.priority = priority;\n        this.key = key;\n        this.options = options;\n        this.state = 'new';\n        this.timeline = options.timeline;\n        this.activityTimeout = options.activityTimeout;\n        this.id = this.timeline.generateUniqueID();\n    }\n    handlesActivityChecks() {\n        return Boolean(this.hooks.handlesActivityChecks);\n    }\n    supportsPing() {\n        return Boolean(this.hooks.supportsPing);\n    }\n    connect() {\n        if (this.socket || this.state !== 'initialized') {\n            return false;\n        }\n        var url = this.hooks.urls.getInitial(this.key, this.options);\n        try {\n            this.socket = this.hooks.getSocket(url, this.options);\n        }\n        catch (e) {\n            util.defer(() => {\n                this.onError(e);\n                this.changeState('closed');\n            });\n            return false;\n        }\n        this.bindListeners();\n        logger.debug('Connecting', { transport: this.name, url });\n        this.changeState('connecting');\n        return true;\n    }\n    close() {\n        if (this.socket) {\n            this.socket.close();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    send(data) {\n        if (this.state === 'open') {\n            util.defer(() => {\n                if (this.socket) {\n                    this.socket.send(data);\n                }\n            });\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    ping() {\n        if (this.state === 'open' && this.supportsPing()) {\n            this.socket.ping();\n        }\n    }\n    onOpen() {\n        if (this.hooks.beforeOpen) {\n            this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));\n        }\n        this.changeState('open');\n        this.socket.onopen = undefined;\n    }\n    onError(error) {\n        this.emit('error', { type: 'WebSocketError', error: error });\n        this.timeline.error(this.buildTimelineMessage({ error: error.toString() }));\n    }\n    onClose(closeEvent) {\n        if (closeEvent) {\n            this.changeState('closed', {\n                code: closeEvent.code,\n                reason: closeEvent.reason,\n                wasClean: closeEvent.wasClean,\n            });\n        }\n        else {\n            this.changeState('closed');\n        }\n        this.unbindListeners();\n        this.socket = undefined;\n    }\n    onMessage(message) {\n        this.emit('message', message);\n    }\n    onActivity() {\n        this.emit('activity');\n    }\n    bindListeners() {\n        this.socket.onopen = () => {\n            this.onOpen();\n        };\n        this.socket.onerror = (error) => {\n            this.onError(error);\n        };\n        this.socket.onclose = (closeEvent) => {\n            this.onClose(closeEvent);\n        };\n        this.socket.onmessage = (message) => {\n            this.onMessage(message);\n        };\n        if (this.supportsPing()) {\n            this.socket.onactivity = () => {\n                this.onActivity();\n            };\n        }\n    }\n    unbindListeners() {\n        if (this.socket) {\n            this.socket.onopen = undefined;\n            this.socket.onerror = undefined;\n            this.socket.onclose = undefined;\n            this.socket.onmessage = undefined;\n            if (this.supportsPing()) {\n                this.socket.onactivity = undefined;\n            }\n        }\n    }\n    changeState(state, params) {\n        this.state = state;\n        this.timeline.info(this.buildTimelineMessage({\n            state: state,\n            params: params,\n        }));\n        this.emit(state, params);\n    }\n    buildTimelineMessage(message) {\n        return extend({ cid: this.id }, message);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/transports/transport.ts\n\nclass transport_Transport {\n    constructor(hooks) {\n        this.hooks = hooks;\n    }\n    isSupported(environment) {\n        return this.hooks.isSupported(environment);\n    }\n    createConnection(name, priority, key, options) {\n        return new transport_connection_TransportConnection(this.hooks, name, priority, key, options);\n    }\n}\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transports.ts\n\n\n\n\nvar WSTransport = new transport_Transport({\n    urls: ws,\n    handlesActivityChecks: false,\n    supportsPing: false,\n    isInitialized: function () {\n        return Boolean(runtime.getWebSocketAPI());\n    },\n    isSupported: function () {\n        return Boolean(runtime.getWebSocketAPI());\n    },\n    getSocket: function (url) {\n        return runtime.createWebSocket(url);\n    },\n});\nvar httpConfiguration = {\n    urls: http,\n    handlesActivityChecks: false,\n    supportsPing: true,\n    isInitialized: function () {\n        return true;\n    },\n};\nvar streamingConfiguration = extend({\n    getSocket: function (url) {\n        return runtime.HTTPFactory.createStreamingSocket(url);\n    },\n}, httpConfiguration);\nvar pollingConfiguration = extend({\n    getSocket: function (url) {\n        return runtime.HTTPFactory.createPollingSocket(url);\n    },\n}, httpConfiguration);\nvar xhrConfiguration = {\n    isSupported: function () {\n        return runtime.isXHRSupported();\n    },\n};\nvar XHRStreamingTransport = new transport_Transport((extend({}, streamingConfiguration, xhrConfiguration)));\nvar XHRPollingTransport = new transport_Transport((extend({}, pollingConfiguration, xhrConfiguration)));\nvar Transports = {\n    ws: WSTransport,\n    xhr_streaming: XHRStreamingTransport,\n    xhr_polling: XHRPollingTransport,\n};\n/* harmony default export */ var transports = (Transports);\n\n// CONCATENATED MODULE: ./src/runtimes/web/transports/transports.ts\n\n\n\n\n\n\nvar SockJSTransport = new transport_Transport({\n    file: 'sockjs',\n    urls: sockjs,\n    handlesActivityChecks: true,\n    supportsPing: false,\n    isSupported: function () {\n        return true;\n    },\n    isInitialized: function () {\n        return window.SockJS !== undefined;\n    },\n    getSocket: function (url, options) {\n        return new window.SockJS(url, null, {\n            js_path: Dependencies.getPath('sockjs', {\n                useTLS: options.useTLS,\n            }),\n            ignore_null_origin: options.ignoreNullOrigin,\n        });\n    },\n    beforeOpen: function (socket, path) {\n        socket.send(JSON.stringify({\n            path: path,\n        }));\n    },\n});\nvar xdrConfiguration = {\n    isSupported: function (environment) {\n        var yes = runtime.isXDRSupported(environment.useTLS);\n        return yes;\n    },\n};\nvar XDRStreamingTransport = new transport_Transport((extend({}, streamingConfiguration, xdrConfiguration)));\nvar XDRPollingTransport = new transport_Transport((extend({}, pollingConfiguration, xdrConfiguration)));\ntransports.xdr_streaming = XDRStreamingTransport;\ntransports.xdr_polling = XDRPollingTransport;\ntransports.sockjs = SockJSTransport;\n/* harmony default export */ var transports_transports = (transports);\n\n// CONCATENATED MODULE: ./src/runtimes/web/net_info.ts\n\nclass net_info_NetInfo extends dispatcher_Dispatcher {\n    constructor() {\n        super();\n        var self = this;\n        if (window.addEventListener !== undefined) {\n            window.addEventListener('online', function () {\n                self.emit('online');\n            }, false);\n            window.addEventListener('offline', function () {\n                self.emit('offline');\n            }, false);\n        }\n    }\n    isOnline() {\n        if (window.navigator.onLine === undefined) {\n            return true;\n        }\n        else {\n            return window.navigator.onLine;\n        }\n    }\n}\nvar net_info_Network = new net_info_NetInfo();\n\n// CONCATENATED MODULE: ./src/core/transports/assistant_to_the_transport_manager.ts\n\n\nclass assistant_to_the_transport_manager_AssistantToTheTransportManager {\n    constructor(manager, transport, options) {\n        this.manager = manager;\n        this.transport = transport;\n        this.minPingDelay = options.minPingDelay;\n        this.maxPingDelay = options.maxPingDelay;\n        this.pingDelay = undefined;\n    }\n    createConnection(name, priority, key, options) {\n        options = extend({}, options, {\n            activityTimeout: this.pingDelay,\n        });\n        var connection = this.transport.createConnection(name, priority, key, options);\n        var openTimestamp = null;\n        var onOpen = function () {\n            connection.unbind('open', onOpen);\n            connection.bind('closed', onClosed);\n            openTimestamp = util.now();\n        };\n        var onClosed = (closeEvent) => {\n            connection.unbind('closed', onClosed);\n            if (closeEvent.code === 1002 || closeEvent.code === 1003) {\n                this.manager.reportDeath();\n            }\n            else if (!closeEvent.wasClean && openTimestamp) {\n                var lifespan = util.now() - openTimestamp;\n                if (lifespan < 2 * this.maxPingDelay) {\n                    this.manager.reportDeath();\n                    this.pingDelay = Math.max(lifespan / 2, this.minPingDelay);\n                }\n            }\n        };\n        connection.bind('open', onOpen);\n        return connection;\n    }\n    isSupported(environment) {\n        return this.manager.isAlive() && this.transport.isSupported(environment);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/connection/protocol/protocol.ts\nconst Protocol = {\n    decodeMessage: function (messageEvent) {\n        try {\n            var messageData = JSON.parse(messageEvent.data);\n            var pusherEventData = messageData.data;\n            if (typeof pusherEventData === 'string') {\n                try {\n                    pusherEventData = JSON.parse(messageData.data);\n                }\n                catch (e) { }\n            }\n            var pusherEvent = {\n                event: messageData.event,\n                channel: messageData.channel,\n                data: pusherEventData,\n            };\n            if (messageData.user_id) {\n                pusherEvent.user_id = messageData.user_id;\n            }\n            return pusherEvent;\n        }\n        catch (e) {\n            throw { type: 'MessageParseError', error: e, data: messageEvent.data };\n        }\n    },\n    encodeMessage: function (event) {\n        return JSON.stringify(event);\n    },\n    processHandshake: function (messageEvent) {\n        var message = Protocol.decodeMessage(messageEvent);\n        if (message.event === 'pusher:connection_established') {\n            if (!message.data.activity_timeout) {\n                throw 'No activity timeout specified in handshake';\n            }\n            return {\n                action: 'connected',\n                id: message.data.socket_id,\n                activityTimeout: message.data.activity_timeout * 1000,\n            };\n        }\n        else if (message.event === 'pusher:error') {\n            return {\n                action: this.getCloseAction(message.data),\n                error: this.getCloseError(message.data),\n            };\n        }\n        else {\n            throw 'Invalid handshake';\n        }\n    },\n    getCloseAction: function (closeEvent) {\n        if (closeEvent.code < 4000) {\n            if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {\n                return 'backoff';\n            }\n            else {\n                return null;\n            }\n        }\n        else if (closeEvent.code === 4000) {\n            return 'tls_only';\n        }\n        else if (closeEvent.code < 4100) {\n            return 'refused';\n        }\n        else if (closeEvent.code < 4200) {\n            return 'backoff';\n        }\n        else if (closeEvent.code < 4300) {\n            return 'retry';\n        }\n        else {\n            return 'refused';\n        }\n    },\n    getCloseError: function (closeEvent) {\n        if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {\n            return {\n                type: 'PusherError',\n                data: {\n                    code: closeEvent.code,\n                    message: closeEvent.reason || closeEvent.message,\n                },\n            };\n        }\n        else {\n            return null;\n        }\n    },\n};\n/* harmony default export */ var protocol_protocol = (Protocol);\n\n// CONCATENATED MODULE: ./src/core/connection/connection.ts\n\n\n\n\nclass connection_Connection extends dispatcher_Dispatcher {\n    constructor(id, transport) {\n        super();\n        this.id = id;\n        this.transport = transport;\n        this.activityTimeout = transport.activityTimeout;\n        this.bindListeners();\n    }\n    handlesActivityChecks() {\n        return this.transport.handlesActivityChecks();\n    }\n    send(data) {\n        return this.transport.send(data);\n    }\n    send_event(name, data, channel) {\n        var event = { event: name, data: data };\n        if (channel) {\n            event.channel = channel;\n        }\n        logger.debug('Event sent', event);\n        return this.send(protocol_protocol.encodeMessage(event));\n    }\n    ping() {\n        if (this.transport.supportsPing()) {\n            this.transport.ping();\n        }\n        else {\n            this.send_event('pusher:ping', {});\n        }\n    }\n    close() {\n        this.transport.close();\n    }\n    bindListeners() {\n        var listeners = {\n            message: (messageEvent) => {\n                var pusherEvent;\n                try {\n                    pusherEvent = protocol_protocol.decodeMessage(messageEvent);\n                }\n                catch (e) {\n                    this.emit('error', {\n                        type: 'MessageParseError',\n                        error: e,\n                        data: messageEvent.data,\n                    });\n                }\n                if (pusherEvent !== undefined) {\n                    logger.debug('Event recd', pusherEvent);\n                    switch (pusherEvent.event) {\n                        case 'pusher:error':\n                            this.emit('error', {\n                                type: 'PusherError',\n                                data: pusherEvent.data,\n                            });\n                            break;\n                        case 'pusher:ping':\n                            this.emit('ping');\n                            break;\n                        case 'pusher:pong':\n                            this.emit('pong');\n                            break;\n                    }\n                    this.emit('message', pusherEvent);\n                }\n            },\n            activity: () => {\n                this.emit('activity');\n            },\n            error: (error) => {\n                this.emit('error', error);\n            },\n            closed: (closeEvent) => {\n                unbindListeners();\n                if (closeEvent && closeEvent.code) {\n                    this.handleCloseEvent(closeEvent);\n                }\n                this.transport = null;\n                this.emit('closed');\n            },\n        };\n        var unbindListeners = () => {\n            objectApply(listeners, (listener, event) => {\n                this.transport.unbind(event, listener);\n            });\n        };\n        objectApply(listeners, (listener, event) => {\n            this.transport.bind(event, listener);\n        });\n    }\n    handleCloseEvent(closeEvent) {\n        var action = protocol_protocol.getCloseAction(closeEvent);\n        var error = protocol_protocol.getCloseError(closeEvent);\n        if (error) {\n            this.emit('error', error);\n        }\n        if (action) {\n            this.emit(action, { action: action, error: error });\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/connection/handshake/index.ts\n\n\n\nclass handshake_Handshake {\n    constructor(transport, callback) {\n        this.transport = transport;\n        this.callback = callback;\n        this.bindListeners();\n    }\n    close() {\n        this.unbindListeners();\n        this.transport.close();\n    }\n    bindListeners() {\n        this.onMessage = (m) => {\n            this.unbindListeners();\n            var result;\n            try {\n                result = protocol_protocol.processHandshake(m);\n            }\n            catch (e) {\n                this.finish('error', { error: e });\n                this.transport.close();\n                return;\n            }\n            if (result.action === 'connected') {\n                this.finish('connected', {\n                    connection: new connection_Connection(result.id, this.transport),\n                    activityTimeout: result.activityTimeout,\n                });\n            }\n            else {\n                this.finish(result.action, { error: result.error });\n                this.transport.close();\n            }\n        };\n        this.onClosed = (closeEvent) => {\n            this.unbindListeners();\n            var action = protocol_protocol.getCloseAction(closeEvent) || 'backoff';\n            var error = protocol_protocol.getCloseError(closeEvent);\n            this.finish(action, { error: error });\n        };\n        this.transport.bind('message', this.onMessage);\n        this.transport.bind('closed', this.onClosed);\n    }\n    unbindListeners() {\n        this.transport.unbind('message', this.onMessage);\n        this.transport.unbind('closed', this.onClosed);\n    }\n    finish(action, params) {\n        this.callback(extend({ transport: this.transport, action: action }, params));\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/timeline/timeline_sender.ts\n\nclass timeline_sender_TimelineSender {\n    constructor(timeline, options) {\n        this.timeline = timeline;\n        this.options = options || {};\n    }\n    send(useTLS, callback) {\n        if (this.timeline.isEmpty()) {\n            return;\n        }\n        this.timeline.send(runtime.TimelineTransport.getAgent(this, useTLS), callback);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/channels/channel.ts\n\n\n\n\n\nclass channel_Channel extends dispatcher_Dispatcher {\n    constructor(name, pusher) {\n        super(function (event, data) {\n            logger.debug('No callbacks on ' + name + ' for ' + event);\n        });\n        this.name = name;\n        this.pusher = pusher;\n        this.subscribed = false;\n        this.subscriptionPending = false;\n        this.subscriptionCancelled = false;\n    }\n    authorize(socketId, callback) {\n        return callback(null, { auth: '' });\n    }\n    trigger(event, data) {\n        if (event.indexOf('client-') !== 0) {\n            throw new BadEventName(\"Event '\" + event + \"' does not start with 'client-'\");\n        }\n        if (!this.subscribed) {\n            var suffix = url_store.buildLogSuffix('triggeringClientEvents');\n            logger.warn(`Client event triggered before channel 'subscription_succeeded' event . ${suffix}`);\n        }\n        return this.pusher.send_event(event, data, this.name);\n    }\n    disconnect() {\n        this.subscribed = false;\n        this.subscriptionPending = false;\n    }\n    handleEvent(event) {\n        var eventName = event.event;\n        var data = event.data;\n        if (eventName === 'pusher_internal:subscription_succeeded') {\n            this.handleSubscriptionSucceededEvent(event);\n        }\n        else if (eventName === 'pusher_internal:subscription_count') {\n            this.handleSubscriptionCountEvent(event);\n        }\n        else if (eventName.indexOf('pusher_internal:') !== 0) {\n            var metadata = {};\n            this.emit(eventName, data, metadata);\n        }\n    }\n    handleSubscriptionSucceededEvent(event) {\n        this.subscriptionPending = false;\n        this.subscribed = true;\n        if (this.subscriptionCancelled) {\n            this.pusher.unsubscribe(this.name);\n        }\n        else {\n            this.emit('pusher:subscription_succeeded', event.data);\n        }\n    }\n    handleSubscriptionCountEvent(event) {\n        if (event.data.subscription_count) {\n            this.subscriptionCount = event.data.subscription_count;\n        }\n        this.emit('pusher:subscription_count', event.data);\n    }\n    subscribe() {\n        if (this.subscribed) {\n            return;\n        }\n        this.subscriptionPending = true;\n        this.subscriptionCancelled = false;\n        this.authorize(this.pusher.connection.socket_id, (error, data) => {\n            if (error) {\n                this.subscriptionPending = false;\n                logger.error(error.toString());\n                this.emit('pusher:subscription_error', Object.assign({}, {\n                    type: 'AuthError',\n                    error: error.message,\n                }, error instanceof HTTPAuthError ? { status: error.status } : {}));\n            }\n            else {\n                this.pusher.send_event('pusher:subscribe', {\n                    auth: data.auth,\n                    channel_data: data.channel_data,\n                    channel: this.name,\n                });\n            }\n        });\n    }\n    unsubscribe() {\n        this.subscribed = false;\n        this.pusher.send_event('pusher:unsubscribe', {\n            channel: this.name,\n        });\n    }\n    cancelSubscription() {\n        this.subscriptionCancelled = true;\n    }\n    reinstateSubscription() {\n        this.subscriptionCancelled = false;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/channels/private_channel.ts\n\nclass private_channel_PrivateChannel extends channel_Channel {\n    authorize(socketId, callback) {\n        return this.pusher.config.channelAuthorizer({\n            channelName: this.name,\n            socketId: socketId,\n        }, callback);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/channels/members.ts\n\nclass members_Members {\n    constructor() {\n        this.reset();\n    }\n    get(id) {\n        if (Object.prototype.hasOwnProperty.call(this.members, id)) {\n            return {\n                id: id,\n                info: this.members[id],\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    each(callback) {\n        objectApply(this.members, (member, id) => {\n            callback(this.get(id));\n        });\n    }\n    setMyID(id) {\n        this.myID = id;\n    }\n    onSubscription(subscriptionData) {\n        this.members = subscriptionData.presence.hash;\n        this.count = subscriptionData.presence.count;\n        this.me = this.get(this.myID);\n    }\n    addMember(memberData) {\n        if (this.get(memberData.user_id) === null) {\n            this.count++;\n        }\n        this.members[memberData.user_id] = memberData.user_info;\n        return this.get(memberData.user_id);\n    }\n    removeMember(memberData) {\n        var member = this.get(memberData.user_id);\n        if (member) {\n            delete this.members[memberData.user_id];\n            this.count--;\n        }\n        return member;\n    }\n    reset() {\n        this.members = {};\n        this.count = 0;\n        this.myID = null;\n        this.me = null;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/channels/presence_channel.ts\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass presence_channel_PresenceChannel extends private_channel_PrivateChannel {\n    constructor(name, pusher) {\n        super(name, pusher);\n        this.members = new members_Members();\n    }\n    authorize(socketId, callback) {\n        super.authorize(socketId, (error, authData) => __awaiter(this, void 0, void 0, function* () {\n            if (!error) {\n                authData = authData;\n                if (authData.channel_data != null) {\n                    var channelData = JSON.parse(authData.channel_data);\n                    this.members.setMyID(channelData.user_id);\n                }\n                else {\n                    yield this.pusher.user.signinDonePromise;\n                    if (this.pusher.user.user_data != null) {\n                        this.members.setMyID(this.pusher.user.user_data.id);\n                    }\n                    else {\n                        let suffix = url_store.buildLogSuffix('authorizationEndpoint');\n                        logger.error(`Invalid auth response for channel '${this.name}', ` +\n                            `expected 'channel_data' field. ${suffix}, ` +\n                            `or the user should be signed in.`);\n                        callback('Invalid auth response');\n                        return;\n                    }\n                }\n            }\n            callback(error, authData);\n        }));\n    }\n    handleEvent(event) {\n        var eventName = event.event;\n        if (eventName.indexOf('pusher_internal:') === 0) {\n            this.handleInternalEvent(event);\n        }\n        else {\n            var data = event.data;\n            var metadata = {};\n            if (event.user_id) {\n                metadata.user_id = event.user_id;\n            }\n            this.emit(eventName, data, metadata);\n        }\n    }\n    handleInternalEvent(event) {\n        var eventName = event.event;\n        var data = event.data;\n        switch (eventName) {\n            case 'pusher_internal:subscription_succeeded':\n                this.handleSubscriptionSucceededEvent(event);\n                break;\n            case 'pusher_internal:subscription_count':\n                this.handleSubscriptionCountEvent(event);\n                break;\n            case 'pusher_internal:member_added':\n                var addedMember = this.members.addMember(data);\n                this.emit('pusher:member_added', addedMember);\n                break;\n            case 'pusher_internal:member_removed':\n                var removedMember = this.members.removeMember(data);\n                if (removedMember) {\n                    this.emit('pusher:member_removed', removedMember);\n                }\n                break;\n        }\n    }\n    handleSubscriptionSucceededEvent(event) {\n        this.subscriptionPending = false;\n        this.subscribed = true;\n        if (this.subscriptionCancelled) {\n            this.pusher.unsubscribe(this.name);\n        }\n        else {\n            this.members.onSubscription(event.data);\n            this.emit('pusher:subscription_succeeded', this.members);\n        }\n    }\n    disconnect() {\n        this.members.reset();\n        super.disconnect();\n    }\n}\n\n// EXTERNAL MODULE: ./node_modules/@stablelib/utf8/lib/utf8.js\nvar utf8 = __nested_webpack_require_20105__(1);\n\n// EXTERNAL MODULE: ./node_modules/@stablelib/base64/lib/base64.js\nvar base64 = __nested_webpack_require_20105__(0);\n\n// CONCATENATED MODULE: ./src/core/channels/encrypted_channel.ts\n\n\n\n\n\nclass encrypted_channel_EncryptedChannel extends private_channel_PrivateChannel {\n    constructor(name, pusher, nacl) {\n        super(name, pusher);\n        this.key = null;\n        this.nacl = nacl;\n    }\n    authorize(socketId, callback) {\n        super.authorize(socketId, (error, authData) => {\n            if (error) {\n                callback(error, authData);\n                return;\n            }\n            let sharedSecret = authData['shared_secret'];\n            if (!sharedSecret) {\n                callback(new Error(`No shared_secret key in auth payload for encrypted channel: ${this.name}`), null);\n                return;\n            }\n            this.key = Object(base64[\"decode\"])(sharedSecret);\n            delete authData['shared_secret'];\n            callback(null, authData);\n        });\n    }\n    trigger(event, data) {\n        throw new UnsupportedFeature('Client events are not currently supported for encrypted channels');\n    }\n    handleEvent(event) {\n        var eventName = event.event;\n        var data = event.data;\n        if (eventName.indexOf('pusher_internal:') === 0 ||\n            eventName.indexOf('pusher:') === 0) {\n            super.handleEvent(event);\n            return;\n        }\n        this.handleEncryptedEvent(eventName, data);\n    }\n    handleEncryptedEvent(event, data) {\n        if (!this.key) {\n            logger.debug('Received encrypted event before key has been retrieved from the authEndpoint');\n            return;\n        }\n        if (!data.ciphertext || !data.nonce) {\n            logger.error('Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: ' +\n                data);\n            return;\n        }\n        let cipherText = Object(base64[\"decode\"])(data.ciphertext);\n        if (cipherText.length < this.nacl.secretbox.overheadLength) {\n            logger.error(`Expected encrypted event ciphertext length to be ${this.nacl.secretbox.overheadLength}, got: ${cipherText.length}`);\n            return;\n        }\n        let nonce = Object(base64[\"decode\"])(data.nonce);\n        if (nonce.length < this.nacl.secretbox.nonceLength) {\n            logger.error(`Expected encrypted event nonce length to be ${this.nacl.secretbox.nonceLength}, got: ${nonce.length}`);\n            return;\n        }\n        let bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n        if (bytes === null) {\n            logger.debug('Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...');\n            this.authorize(this.pusher.connection.socket_id, (error, authData) => {\n                if (error) {\n                    logger.error(`Failed to make a request to the authEndpoint: ${authData}. Unable to fetch new key, so dropping encrypted event`);\n                    return;\n                }\n                bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n                if (bytes === null) {\n                    logger.error(`Failed to decrypt event with new key. Dropping encrypted event`);\n                    return;\n                }\n                this.emit(event, this.getDataToEmit(bytes));\n                return;\n            });\n            return;\n        }\n        this.emit(event, this.getDataToEmit(bytes));\n    }\n    getDataToEmit(bytes) {\n        let raw = Object(utf8[\"decode\"])(bytes);\n        try {\n            return JSON.parse(raw);\n        }\n        catch (_a) {\n            return raw;\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/connection/connection_manager.ts\n\n\n\n\n\nclass connection_manager_ConnectionManager extends dispatcher_Dispatcher {\n    constructor(key, options) {\n        super();\n        this.state = 'initialized';\n        this.connection = null;\n        this.key = key;\n        this.options = options;\n        this.timeline = this.options.timeline;\n        this.usingTLS = this.options.useTLS;\n        this.errorCallbacks = this.buildErrorCallbacks();\n        this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks);\n        this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);\n        var Network = runtime.getNetwork();\n        Network.bind('online', () => {\n            this.timeline.info({ netinfo: 'online' });\n            if (this.state === 'connecting' || this.state === 'unavailable') {\n                this.retryIn(0);\n            }\n        });\n        Network.bind('offline', () => {\n            this.timeline.info({ netinfo: 'offline' });\n            if (this.connection) {\n                this.sendActivityCheck();\n            }\n        });\n        this.updateStrategy();\n    }\n    connect() {\n        if (this.connection || this.runner) {\n            return;\n        }\n        if (!this.strategy.isSupported()) {\n            this.updateState('failed');\n            return;\n        }\n        this.updateState('connecting');\n        this.startConnecting();\n        this.setUnavailableTimer();\n    }\n    send(data) {\n        if (this.connection) {\n            return this.connection.send(data);\n        }\n        else {\n            return false;\n        }\n    }\n    send_event(name, data, channel) {\n        if (this.connection) {\n            return this.connection.send_event(name, data, channel);\n        }\n        else {\n            return false;\n        }\n    }\n    disconnect() {\n        this.disconnectInternally();\n        this.updateState('disconnected');\n    }\n    isUsingTLS() {\n        return this.usingTLS;\n    }\n    startConnecting() {\n        var callback = (error, handshake) => {\n            if (error) {\n                this.runner = this.strategy.connect(0, callback);\n            }\n            else {\n                if (handshake.action === 'error') {\n                    this.emit('error', {\n                        type: 'HandshakeError',\n                        error: handshake.error,\n                    });\n                    this.timeline.error({ handshakeError: handshake.error });\n                }\n                else {\n                    this.abortConnecting();\n                    this.handshakeCallbacks[handshake.action](handshake);\n                }\n            }\n        };\n        this.runner = this.strategy.connect(0, callback);\n    }\n    abortConnecting() {\n        if (this.runner) {\n            this.runner.abort();\n            this.runner = null;\n        }\n    }\n    disconnectInternally() {\n        this.abortConnecting();\n        this.clearRetryTimer();\n        this.clearUnavailableTimer();\n        if (this.connection) {\n            var connection = this.abandonConnection();\n            connection.close();\n        }\n    }\n    updateStrategy() {\n        this.strategy = this.options.getStrategy({\n            key: this.key,\n            timeline: this.timeline,\n            useTLS: this.usingTLS,\n        });\n    }\n    retryIn(delay) {\n        this.timeline.info({ action: 'retry', delay: delay });\n        if (delay > 0) {\n            this.emit('connecting_in', Math.round(delay / 1000));\n        }\n        this.retryTimer = new timers_OneOffTimer(delay || 0, () => {\n            this.disconnectInternally();\n            this.connect();\n        });\n    }\n    clearRetryTimer() {\n        if (this.retryTimer) {\n            this.retryTimer.ensureAborted();\n            this.retryTimer = null;\n        }\n    }\n    setUnavailableTimer() {\n        this.unavailableTimer = new timers_OneOffTimer(this.options.unavailableTimeout, () => {\n            this.updateState('unavailable');\n        });\n    }\n    clearUnavailableTimer() {\n        if (this.unavailableTimer) {\n            this.unavailableTimer.ensureAborted();\n        }\n    }\n    sendActivityCheck() {\n        this.stopActivityCheck();\n        this.connection.ping();\n        this.activityTimer = new timers_OneOffTimer(this.options.pongTimeout, () => {\n            this.timeline.error({ pong_timed_out: this.options.pongTimeout });\n            this.retryIn(0);\n        });\n    }\n    resetActivityCheck() {\n        this.stopActivityCheck();\n        if (this.connection && !this.connection.handlesActivityChecks()) {\n            this.activityTimer = new timers_OneOffTimer(this.activityTimeout, () => {\n                this.sendActivityCheck();\n            });\n        }\n    }\n    stopActivityCheck() {\n        if (this.activityTimer) {\n            this.activityTimer.ensureAborted();\n        }\n    }\n    buildConnectionCallbacks(errorCallbacks) {\n        return extend({}, errorCallbacks, {\n            message: (message) => {\n                this.resetActivityCheck();\n                this.emit('message', message);\n            },\n            ping: () => {\n                this.send_event('pusher:pong', {});\n            },\n            activity: () => {\n                this.resetActivityCheck();\n            },\n            error: (error) => {\n                this.emit('error', error);\n            },\n            closed: () => {\n                this.abandonConnection();\n                if (this.shouldRetry()) {\n                    this.retryIn(1000);\n                }\n            },\n        });\n    }\n    buildHandshakeCallbacks(errorCallbacks) {\n        return extend({}, errorCallbacks, {\n            connected: (handshake) => {\n                this.activityTimeout = Math.min(this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);\n                this.clearUnavailableTimer();\n                this.setConnection(handshake.connection);\n                this.socket_id = this.connection.id;\n                this.updateState('connected', { socket_id: this.socket_id });\n            },\n        });\n    }\n    buildErrorCallbacks() {\n        let withErrorEmitted = (callback) => {\n            return (result) => {\n                if (result.error) {\n                    this.emit('error', { type: 'WebSocketError', error: result.error });\n                }\n                callback(result);\n            };\n        };\n        return {\n            tls_only: withErrorEmitted(() => {\n                this.usingTLS = true;\n                this.updateStrategy();\n                this.retryIn(0);\n            }),\n            refused: withErrorEmitted(() => {\n                this.disconnect();\n            }),\n            backoff: withErrorEmitted(() => {\n                this.retryIn(1000);\n            }),\n            retry: withErrorEmitted(() => {\n                this.retryIn(0);\n            }),\n        };\n    }\n    setConnection(connection) {\n        this.connection = connection;\n        for (var event in this.connectionCallbacks) {\n            this.connection.bind(event, this.connectionCallbacks[event]);\n        }\n        this.resetActivityCheck();\n    }\n    abandonConnection() {\n        if (!this.connection) {\n            return;\n        }\n        this.stopActivityCheck();\n        for (var event in this.connectionCallbacks) {\n            this.connection.unbind(event, this.connectionCallbacks[event]);\n        }\n        var connection = this.connection;\n        this.connection = null;\n        return connection;\n    }\n    updateState(newState, data) {\n        var previousState = this.state;\n        this.state = newState;\n        if (previousState !== newState) {\n            var newStateDescription = newState;\n            if (newStateDescription === 'connected') {\n                newStateDescription += ' with new socket ID ' + data.socket_id;\n            }\n            logger.debug('State changed', previousState + ' -> ' + newStateDescription);\n            this.timeline.info({ state: newState, params: data });\n            this.emit('state_change', { previous: previousState, current: newState });\n            this.emit(newState, data);\n        }\n    }\n    shouldRetry() {\n        return this.state === 'connecting' || this.state === 'connected';\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/channels/channels.ts\n\n\n\n\nclass channels_Channels {\n    constructor() {\n        this.channels = {};\n    }\n    add(name, pusher) {\n        if (!this.channels[name]) {\n            this.channels[name] = createChannel(name, pusher);\n        }\n        return this.channels[name];\n    }\n    all() {\n        return values(this.channels);\n    }\n    find(name) {\n        return this.channels[name];\n    }\n    remove(name) {\n        var channel = this.channels[name];\n        delete this.channels[name];\n        return channel;\n    }\n    disconnect() {\n        objectApply(this.channels, function (channel) {\n            channel.disconnect();\n        });\n    }\n}\nfunction createChannel(name, pusher) {\n    if (name.indexOf('private-encrypted-') === 0) {\n        if (pusher.config.nacl) {\n            return factory.createEncryptedChannel(name, pusher, pusher.config.nacl);\n        }\n        let errMsg = 'Tried to subscribe to a private-encrypted- channel but no nacl implementation available';\n        let suffix = url_store.buildLogSuffix('encryptedChannelSupport');\n        throw new UnsupportedFeature(`${errMsg}. ${suffix}`);\n    }\n    else if (name.indexOf('private-') === 0) {\n        return factory.createPrivateChannel(name, pusher);\n    }\n    else if (name.indexOf('presence-') === 0) {\n        return factory.createPresenceChannel(name, pusher);\n    }\n    else if (name.indexOf('#') === 0) {\n        throw new BadChannelName('Cannot create a channel with name \"' + name + '\".');\n    }\n    else {\n        return factory.createChannel(name, pusher);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/utils/factory.ts\n\n\n\n\n\n\n\n\n\nvar Factory = {\n    createChannels() {\n        return new channels_Channels();\n    },\n    createConnectionManager(key, options) {\n        return new connection_manager_ConnectionManager(key, options);\n    },\n    createChannel(name, pusher) {\n        return new channel_Channel(name, pusher);\n    },\n    createPrivateChannel(name, pusher) {\n        return new private_channel_PrivateChannel(name, pusher);\n    },\n    createPresenceChannel(name, pusher) {\n        return new presence_channel_PresenceChannel(name, pusher);\n    },\n    createEncryptedChannel(name, pusher, nacl) {\n        return new encrypted_channel_EncryptedChannel(name, pusher, nacl);\n    },\n    createTimelineSender(timeline, options) {\n        return new timeline_sender_TimelineSender(timeline, options);\n    },\n    createHandshake(transport, callback) {\n        return new handshake_Handshake(transport, callback);\n    },\n    createAssistantToTheTransportManager(manager, transport, options) {\n        return new assistant_to_the_transport_manager_AssistantToTheTransportManager(manager, transport, options);\n    },\n};\n/* harmony default export */ var factory = (Factory);\n\n// CONCATENATED MODULE: ./src/core/transports/transport_manager.ts\n\nclass transport_manager_TransportManager {\n    constructor(options) {\n        this.options = options || {};\n        this.livesLeft = this.options.lives || Infinity;\n    }\n    getAssistant(transport) {\n        return factory.createAssistantToTheTransportManager(this, transport, {\n            minPingDelay: this.options.minPingDelay,\n            maxPingDelay: this.options.maxPingDelay,\n        });\n    }\n    isAlive() {\n        return this.livesLeft > 0;\n    }\n    reportDeath() {\n        this.livesLeft -= 1;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/sequential_strategy.ts\n\n\n\nclass sequential_strategy_SequentialStrategy {\n    constructor(strategies, options) {\n        this.strategies = strategies;\n        this.loop = Boolean(options.loop);\n        this.failFast = Boolean(options.failFast);\n        this.timeout = options.timeout;\n        this.timeoutLimit = options.timeoutLimit;\n    }\n    isSupported() {\n        return any(this.strategies, util.method('isSupported'));\n    }\n    connect(minPriority, callback) {\n        var strategies = this.strategies;\n        var current = 0;\n        var timeout = this.timeout;\n        var runner = null;\n        var tryNextStrategy = (error, handshake) => {\n            if (handshake) {\n                callback(null, handshake);\n            }\n            else {\n                current = current + 1;\n                if (this.loop) {\n                    current = current % strategies.length;\n                }\n                if (current < strategies.length) {\n                    if (timeout) {\n                        timeout = timeout * 2;\n                        if (this.timeoutLimit) {\n                            timeout = Math.min(timeout, this.timeoutLimit);\n                        }\n                    }\n                    runner = this.tryStrategy(strategies[current], minPriority, { timeout, failFast: this.failFast }, tryNextStrategy);\n                }\n                else {\n                    callback(true);\n                }\n            }\n        };\n        runner = this.tryStrategy(strategies[current], minPriority, { timeout: timeout, failFast: this.failFast }, tryNextStrategy);\n        return {\n            abort: function () {\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            },\n        };\n    }\n    tryStrategy(strategy, minPriority, options, callback) {\n        var timer = null;\n        var runner = null;\n        if (options.timeout > 0) {\n            timer = new timers_OneOffTimer(options.timeout, function () {\n                runner.abort();\n                callback(true);\n            });\n        }\n        runner = strategy.connect(minPriority, function (error, handshake) {\n            if (error && timer && timer.isRunning() && !options.failFast) {\n                return;\n            }\n            if (timer) {\n                timer.ensureAborted();\n            }\n            callback(error, handshake);\n        });\n        return {\n            abort: function () {\n                if (timer) {\n                    timer.ensureAborted();\n                }\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                runner.forceMinPriority(p);\n            },\n        };\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/best_connected_ever_strategy.ts\n\n\nclass best_connected_ever_strategy_BestConnectedEverStrategy {\n    constructor(strategies) {\n        this.strategies = strategies;\n    }\n    isSupported() {\n        return any(this.strategies, util.method('isSupported'));\n    }\n    connect(minPriority, callback) {\n        return connect(this.strategies, minPriority, function (i, runners) {\n            return function (error, handshake) {\n                runners[i].error = error;\n                if (error) {\n                    if (allRunnersFailed(runners)) {\n                        callback(true);\n                    }\n                    return;\n                }\n                apply(runners, function (runner) {\n                    runner.forceMinPriority(handshake.transport.priority);\n                });\n                callback(null, handshake);\n            };\n        });\n    }\n}\nfunction connect(strategies, minPriority, callbackBuilder) {\n    var runners = map(strategies, function (strategy, i, _, rs) {\n        return strategy.connect(minPriority, callbackBuilder(i, rs));\n    });\n    return {\n        abort: function () {\n            apply(runners, abortRunner);\n        },\n        forceMinPriority: function (p) {\n            apply(runners, function (runner) {\n                runner.forceMinPriority(p);\n            });\n        },\n    };\n}\nfunction allRunnersFailed(runners) {\n    return collections_all(runners, function (runner) {\n        return Boolean(runner.error);\n    });\n}\nfunction abortRunner(runner) {\n    if (!runner.error && !runner.aborted) {\n        runner.abort();\n        runner.aborted = true;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/websocket_prioritized_cached_strategy.ts\n\n\n\n\nclass websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy {\n    constructor(strategy, transports, options) {\n        this.strategy = strategy;\n        this.transports = transports;\n        this.ttl = options.ttl || 1800 * 1000;\n        this.usingTLS = options.useTLS;\n        this.timeline = options.timeline;\n    }\n    isSupported() {\n        return this.strategy.isSupported();\n    }\n    connect(minPriority, callback) {\n        var usingTLS = this.usingTLS;\n        var info = fetchTransportCache(usingTLS);\n        var cacheSkipCount = info && info.cacheSkipCount ? info.cacheSkipCount : 0;\n        var strategies = [this.strategy];\n        if (info && info.timestamp + this.ttl >= util.now()) {\n            var transport = this.transports[info.transport];\n            if (transport) {\n                if (['ws', 'wss'].includes(info.transport) || cacheSkipCount > 3) {\n                    this.timeline.info({\n                        cached: true,\n                        transport: info.transport,\n                        latency: info.latency,\n                    });\n                    strategies.push(new sequential_strategy_SequentialStrategy([transport], {\n                        timeout: info.latency * 2 + 1000,\n                        failFast: true,\n                    }));\n                }\n                else {\n                    cacheSkipCount++;\n                }\n            }\n        }\n        var startTimestamp = util.now();\n        var runner = strategies\n            .pop()\n            .connect(minPriority, function cb(error, handshake) {\n            if (error) {\n                flushTransportCache(usingTLS);\n                if (strategies.length > 0) {\n                    startTimestamp = util.now();\n                    runner = strategies.pop().connect(minPriority, cb);\n                }\n                else {\n                    callback(error);\n                }\n            }\n            else {\n                storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp, cacheSkipCount);\n                callback(null, handshake);\n            }\n        });\n        return {\n            abort: function () {\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            },\n        };\n    }\n}\nfunction getTransportCacheKey(usingTLS) {\n    return 'pusherTransport' + (usingTLS ? 'TLS' : 'NonTLS');\n}\nfunction fetchTransportCache(usingTLS) {\n    var storage = runtime.getLocalStorage();\n    if (storage) {\n        try {\n            var serializedCache = storage[getTransportCacheKey(usingTLS)];\n            if (serializedCache) {\n                return JSON.parse(serializedCache);\n            }\n        }\n        catch (e) {\n            flushTransportCache(usingTLS);\n        }\n    }\n    return null;\n}\nfunction storeTransportCache(usingTLS, transport, latency, cacheSkipCount) {\n    var storage = runtime.getLocalStorage();\n    if (storage) {\n        try {\n            storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({\n                timestamp: util.now(),\n                transport: transport,\n                latency: latency,\n                cacheSkipCount: cacheSkipCount,\n            });\n        }\n        catch (e) {\n        }\n    }\n}\nfunction flushTransportCache(usingTLS) {\n    var storage = runtime.getLocalStorage();\n    if (storage) {\n        try {\n            delete storage[getTransportCacheKey(usingTLS)];\n        }\n        catch (e) {\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/delayed_strategy.ts\n\nclass delayed_strategy_DelayedStrategy {\n    constructor(strategy, { delay: number }) {\n        this.strategy = strategy;\n        this.options = { delay: number };\n    }\n    isSupported() {\n        return this.strategy.isSupported();\n    }\n    connect(minPriority, callback) {\n        var strategy = this.strategy;\n        var runner;\n        var timer = new timers_OneOffTimer(this.options.delay, function () {\n            runner = strategy.connect(minPriority, callback);\n        });\n        return {\n            abort: function () {\n                timer.ensureAborted();\n                if (runner) {\n                    runner.abort();\n                }\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            },\n        };\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/if_strategy.ts\nclass IfStrategy {\n    constructor(test, trueBranch, falseBranch) {\n        this.test = test;\n        this.trueBranch = trueBranch;\n        this.falseBranch = falseBranch;\n    }\n    isSupported() {\n        var branch = this.test() ? this.trueBranch : this.falseBranch;\n        return branch.isSupported();\n    }\n    connect(minPriority, callback) {\n        var branch = this.test() ? this.trueBranch : this.falseBranch;\n        return branch.connect(minPriority, callback);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/first_connected_strategy.ts\nclass FirstConnectedStrategy {\n    constructor(strategy) {\n        this.strategy = strategy;\n    }\n    isSupported() {\n        return this.strategy.isSupported();\n    }\n    connect(minPriority, callback) {\n        var runner = this.strategy.connect(minPriority, function (error, handshake) {\n            if (handshake) {\n                runner.abort();\n            }\n            callback(error, handshake);\n        });\n        return runner;\n    }\n}\n\n// CONCATENATED MODULE: ./src/runtimes/web/default_strategy.ts\n\n\n\n\n\n\n\nfunction testSupportsStrategy(strategy) {\n    return function () {\n        return strategy.isSupported();\n    };\n}\nvar getDefaultStrategy = function (config, baseOptions, defineTransport) {\n    var definedTransports = {};\n    function defineTransportStrategy(name, type, priority, options, manager) {\n        var transport = defineTransport(config, name, type, priority, options, manager);\n        definedTransports[name] = transport;\n        return transport;\n    }\n    var ws_options = Object.assign({}, baseOptions, {\n        hostNonTLS: config.wsHost + ':' + config.wsPort,\n        hostTLS: config.wsHost + ':' + config.wssPort,\n        httpPath: config.wsPath,\n    });\n    var wss_options = Object.assign({}, ws_options, {\n        useTLS: true,\n    });\n    var sockjs_options = Object.assign({}, baseOptions, {\n        hostNonTLS: config.httpHost + ':' + config.httpPort,\n        hostTLS: config.httpHost + ':' + config.httpsPort,\n        httpPath: config.httpPath,\n    });\n    var timeouts = {\n        loop: true,\n        timeout: 15000,\n        timeoutLimit: 60000,\n    };\n    var ws_manager = new transport_manager_TransportManager({\n        minPingDelay: 10000,\n        maxPingDelay: config.activityTimeout,\n    });\n    var streaming_manager = new transport_manager_TransportManager({\n        lives: 2,\n        minPingDelay: 10000,\n        maxPingDelay: config.activityTimeout,\n    });\n    var ws_transport = defineTransportStrategy('ws', 'ws', 3, ws_options, ws_manager);\n    var wss_transport = defineTransportStrategy('wss', 'ws', 3, wss_options, ws_manager);\n    var sockjs_transport = defineTransportStrategy('sockjs', 'sockjs', 1, sockjs_options);\n    var xhr_streaming_transport = defineTransportStrategy('xhr_streaming', 'xhr_streaming', 1, sockjs_options, streaming_manager);\n    var xdr_streaming_transport = defineTransportStrategy('xdr_streaming', 'xdr_streaming', 1, sockjs_options, streaming_manager);\n    var xhr_polling_transport = defineTransportStrategy('xhr_polling', 'xhr_polling', 1, sockjs_options);\n    var xdr_polling_transport = defineTransportStrategy('xdr_polling', 'xdr_polling', 1, sockjs_options);\n    var ws_loop = new sequential_strategy_SequentialStrategy([ws_transport], timeouts);\n    var wss_loop = new sequential_strategy_SequentialStrategy([wss_transport], timeouts);\n    var sockjs_loop = new sequential_strategy_SequentialStrategy([sockjs_transport], timeouts);\n    var streaming_loop = new sequential_strategy_SequentialStrategy([\n        new IfStrategy(testSupportsStrategy(xhr_streaming_transport), xhr_streaming_transport, xdr_streaming_transport),\n    ], timeouts);\n    var polling_loop = new sequential_strategy_SequentialStrategy([\n        new IfStrategy(testSupportsStrategy(xhr_polling_transport), xhr_polling_transport, xdr_polling_transport),\n    ], timeouts);\n    var http_loop = new sequential_strategy_SequentialStrategy([\n        new IfStrategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy_BestConnectedEverStrategy([\n            streaming_loop,\n            new delayed_strategy_DelayedStrategy(polling_loop, { delay: 4000 }),\n        ]), polling_loop),\n    ], timeouts);\n    var http_fallback_loop = new IfStrategy(testSupportsStrategy(http_loop), http_loop, sockjs_loop);\n    var wsStrategy;\n    if (baseOptions.useTLS) {\n        wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n            ws_loop,\n            new delayed_strategy_DelayedStrategy(http_fallback_loop, { delay: 2000 }),\n        ]);\n    }\n    else {\n        wsStrategy = new best_connected_ever_strategy_BestConnectedEverStrategy([\n            ws_loop,\n            new delayed_strategy_DelayedStrategy(wss_loop, { delay: 2000 }),\n            new delayed_strategy_DelayedStrategy(http_fallback_loop, { delay: 5000 }),\n        ]);\n    }\n    return new websocket_prioritized_cached_strategy_WebSocketPrioritizedCachedStrategy(new FirstConnectedStrategy(new IfStrategy(testSupportsStrategy(ws_transport), wsStrategy, http_fallback_loop)), definedTransports, {\n        ttl: 1800000,\n        timeline: baseOptions.timeline,\n        useTLS: baseOptions.useTLS,\n    });\n};\n/* harmony default export */ var default_strategy = (getDefaultStrategy);\n\n// CONCATENATED MODULE: ./src/runtimes/web/transports/transport_connection_initializer.ts\n\n/* harmony default export */ var transport_connection_initializer = (function () {\n    var self = this;\n    self.timeline.info(self.buildTimelineMessage({\n        transport: self.name + (self.options.useTLS ? 's' : ''),\n    }));\n    if (self.hooks.isInitialized()) {\n        self.changeState('initialized');\n    }\n    else if (self.hooks.file) {\n        self.changeState('initializing');\n        Dependencies.load(self.hooks.file, { useTLS: self.options.useTLS }, function (error, callback) {\n            if (self.hooks.isInitialized()) {\n                self.changeState('initialized');\n                callback(true);\n            }\n            else {\n                if (error) {\n                    self.onError(error);\n                }\n                self.onClose();\n                callback(false);\n            }\n        });\n    }\n    else {\n        self.onClose();\n    }\n});\n\n// CONCATENATED MODULE: ./src/runtimes/web/http/http_xdomain_request.ts\n\nvar http_xdomain_request_hooks = {\n    getRequest: function (socket) {\n        var xdr = new window.XDomainRequest();\n        xdr.ontimeout = function () {\n            socket.emit('error', new RequestTimedOut());\n            socket.close();\n        };\n        xdr.onerror = function (e) {\n            socket.emit('error', e);\n            socket.close();\n        };\n        xdr.onprogress = function () {\n            if (xdr.responseText && xdr.responseText.length > 0) {\n                socket.onChunk(200, xdr.responseText);\n            }\n        };\n        xdr.onload = function () {\n            if (xdr.responseText && xdr.responseText.length > 0) {\n                socket.onChunk(200, xdr.responseText);\n            }\n            socket.emit('finished', 200);\n            socket.close();\n        };\n        return xdr;\n    },\n    abortRequest: function (xdr) {\n        xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null;\n        xdr.abort();\n    },\n};\n/* harmony default export */ var http_xdomain_request = (http_xdomain_request_hooks);\n\n// CONCATENATED MODULE: ./src/core/http/http_request.ts\n\n\nconst MAX_BUFFER_LENGTH = 256 * 1024;\nclass http_request_HTTPRequest extends dispatcher_Dispatcher {\n    constructor(hooks, method, url) {\n        super();\n        this.hooks = hooks;\n        this.method = method;\n        this.url = url;\n    }\n    start(payload) {\n        this.position = 0;\n        this.xhr = this.hooks.getRequest(this);\n        this.unloader = () => {\n            this.close();\n        };\n        runtime.addUnloadListener(this.unloader);\n        this.xhr.open(this.method, this.url, true);\n        if (this.xhr.setRequestHeader) {\n            this.xhr.setRequestHeader('Content-Type', 'application/json');\n        }\n        this.xhr.send(payload);\n    }\n    close() {\n        if (this.unloader) {\n            runtime.removeUnloadListener(this.unloader);\n            this.unloader = null;\n        }\n        if (this.xhr) {\n            this.hooks.abortRequest(this.xhr);\n            this.xhr = null;\n        }\n    }\n    onChunk(status, data) {\n        while (true) {\n            var chunk = this.advanceBuffer(data);\n            if (chunk) {\n                this.emit('chunk', { status: status, data: chunk });\n            }\n            else {\n                break;\n            }\n        }\n        if (this.isBufferTooLong(data)) {\n            this.emit('buffer_too_long');\n        }\n    }\n    advanceBuffer(buffer) {\n        var unreadData = buffer.slice(this.position);\n        var endOfLinePosition = unreadData.indexOf('\\n');\n        if (endOfLinePosition !== -1) {\n            this.position += endOfLinePosition + 1;\n            return unreadData.slice(0, endOfLinePosition);\n        }\n        else {\n            return null;\n        }\n    }\n    isBufferTooLong(buffer) {\n        return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/http/state.ts\nvar State;\n(function (State) {\n    State[State[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    State[State[\"OPEN\"] = 1] = \"OPEN\";\n    State[State[\"CLOSED\"] = 3] = \"CLOSED\";\n})(State || (State = {}));\n/* harmony default export */ var state = (State);\n\n// CONCATENATED MODULE: ./src/core/http/http_socket.ts\n\n\n\nvar autoIncrement = 1;\nclass http_socket_HTTPSocket {\n    constructor(hooks, url) {\n        this.hooks = hooks;\n        this.session = randomNumber(1000) + '/' + randomString(8);\n        this.location = getLocation(url);\n        this.readyState = state.CONNECTING;\n        this.openStream();\n    }\n    send(payload) {\n        return this.sendRaw(JSON.stringify([payload]));\n    }\n    ping() {\n        this.hooks.sendHeartbeat(this);\n    }\n    close(code, reason) {\n        this.onClose(code, reason, true);\n    }\n    sendRaw(payload) {\n        if (this.readyState === state.OPEN) {\n            try {\n                runtime.createSocketRequest('POST', getUniqueURL(getSendURL(this.location, this.session))).start(payload);\n                return true;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    reconnect() {\n        this.closeStream();\n        this.openStream();\n    }\n    onClose(code, reason, wasClean) {\n        this.closeStream();\n        this.readyState = state.CLOSED;\n        if (this.onclose) {\n            this.onclose({\n                code: code,\n                reason: reason,\n                wasClean: wasClean,\n            });\n        }\n    }\n    onChunk(chunk) {\n        if (chunk.status !== 200) {\n            return;\n        }\n        if (this.readyState === state.OPEN) {\n            this.onActivity();\n        }\n        var payload;\n        var type = chunk.data.slice(0, 1);\n        switch (type) {\n            case 'o':\n                payload = JSON.parse(chunk.data.slice(1) || '{}');\n                this.onOpen(payload);\n                break;\n            case 'a':\n                payload = JSON.parse(chunk.data.slice(1) || '[]');\n                for (var i = 0; i < payload.length; i++) {\n                    this.onEvent(payload[i]);\n                }\n                break;\n            case 'm':\n                payload = JSON.parse(chunk.data.slice(1) || 'null');\n                this.onEvent(payload);\n                break;\n            case 'h':\n                this.hooks.onHeartbeat(this);\n                break;\n            case 'c':\n                payload = JSON.parse(chunk.data.slice(1) || '[]');\n                this.onClose(payload[0], payload[1], true);\n                break;\n        }\n    }\n    onOpen(options) {\n        if (this.readyState === state.CONNECTING) {\n            if (options && options.hostname) {\n                this.location.base = replaceHost(this.location.base, options.hostname);\n            }\n            this.readyState = state.OPEN;\n            if (this.onopen) {\n                this.onopen();\n            }\n        }\n        else {\n            this.onClose(1006, 'Server lost session', true);\n        }\n    }\n    onEvent(event) {\n        if (this.readyState === state.OPEN && this.onmessage) {\n            this.onmessage({ data: event });\n        }\n    }\n    onActivity() {\n        if (this.onactivity) {\n            this.onactivity();\n        }\n    }\n    onError(error) {\n        if (this.onerror) {\n            this.onerror(error);\n        }\n    }\n    openStream() {\n        this.stream = runtime.createSocketRequest('POST', getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));\n        this.stream.bind('chunk', (chunk) => {\n            this.onChunk(chunk);\n        });\n        this.stream.bind('finished', (status) => {\n            this.hooks.onFinished(this, status);\n        });\n        this.stream.bind('buffer_too_long', () => {\n            this.reconnect();\n        });\n        try {\n            this.stream.start();\n        }\n        catch (error) {\n            util.defer(() => {\n                this.onError(error);\n                this.onClose(1006, 'Could not start streaming', false);\n            });\n        }\n    }\n    closeStream() {\n        if (this.stream) {\n            this.stream.unbind_all();\n            this.stream.close();\n            this.stream = null;\n        }\n    }\n}\nfunction getLocation(url) {\n    var parts = /([^\\?]*)\\/*(\\??.*)/.exec(url);\n    return {\n        base: parts[1],\n        queryString: parts[2],\n    };\n}\nfunction getSendURL(url, session) {\n    return url.base + '/' + session + '/xhr_send';\n}\nfunction getUniqueURL(url) {\n    var separator = url.indexOf('?') === -1 ? '?' : '&';\n    return url + separator + 't=' + +new Date() + '&n=' + autoIncrement++;\n}\nfunction replaceHost(url, hostname) {\n    var urlParts = /(https?:\\/\\/)([^\\/:]+)((\\/|:)?.*)/.exec(url);\n    return urlParts[1] + hostname + urlParts[3];\n}\nfunction randomNumber(max) {\n    return runtime.randomInt(max);\n}\nfunction randomString(length) {\n    var result = [];\n    for (var i = 0; i < length; i++) {\n        result.push(randomNumber(32).toString(32));\n    }\n    return result.join('');\n}\n/* harmony default export */ var http_socket = (http_socket_HTTPSocket);\n\n// CONCATENATED MODULE: ./src/core/http/http_streaming_socket.ts\nvar http_streaming_socket_hooks = {\n    getReceiveURL: function (url, session) {\n        return url.base + '/' + session + '/xhr_streaming' + url.queryString;\n    },\n    onHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    sendHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    onFinished: function (socket, status) {\n        socket.onClose(1006, 'Connection interrupted (' + status + ')', false);\n    },\n};\n/* harmony default export */ var http_streaming_socket = (http_streaming_socket_hooks);\n\n// CONCATENATED MODULE: ./src/core/http/http_polling_socket.ts\nvar http_polling_socket_hooks = {\n    getReceiveURL: function (url, session) {\n        return url.base + '/' + session + '/xhr' + url.queryString;\n    },\n    onHeartbeat: function () {\n    },\n    sendHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    onFinished: function (socket, status) {\n        if (status === 200) {\n            socket.reconnect();\n        }\n        else {\n            socket.onClose(1006, 'Connection interrupted (' + status + ')', false);\n        }\n    },\n};\n/* harmony default export */ var http_polling_socket = (http_polling_socket_hooks);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http_xhr_request.ts\n\nvar http_xhr_request_hooks = {\n    getRequest: function (socket) {\n        var Constructor = runtime.getXHRAPI();\n        var xhr = new Constructor();\n        xhr.onreadystatechange = xhr.onprogress = function () {\n            switch (xhr.readyState) {\n                case 3:\n                    if (xhr.responseText && xhr.responseText.length > 0) {\n                        socket.onChunk(xhr.status, xhr.responseText);\n                    }\n                    break;\n                case 4:\n                    if (xhr.responseText && xhr.responseText.length > 0) {\n                        socket.onChunk(xhr.status, xhr.responseText);\n                    }\n                    socket.emit('finished', xhr.status);\n                    socket.close();\n                    break;\n            }\n        };\n        return xhr;\n    },\n    abortRequest: function (xhr) {\n        xhr.onreadystatechange = null;\n        xhr.abort();\n    },\n};\n/* harmony default export */ var http_xhr_request = (http_xhr_request_hooks);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http.ts\n\n\n\n\n\nvar HTTP = {\n    createStreamingSocket(url) {\n        return this.createSocket(http_streaming_socket, url);\n    },\n    createPollingSocket(url) {\n        return this.createSocket(http_polling_socket, url);\n    },\n    createSocket(hooks, url) {\n        return new http_socket(hooks, url);\n    },\n    createXHR(method, url) {\n        return this.createRequest(http_xhr_request, method, url);\n    },\n    createRequest(hooks, method, url) {\n        return new http_request_HTTPRequest(hooks, method, url);\n    },\n};\n/* harmony default export */ var http_http = (HTTP);\n\n// CONCATENATED MODULE: ./src/runtimes/web/http/http.ts\n\n\nhttp_http.createXDR = function (method, url) {\n    return this.createRequest(http_xdomain_request, method, url);\n};\n/* harmony default export */ var web_http_http = (http_http);\n\n// CONCATENATED MODULE: ./src/runtimes/web/runtime.ts\n\n\n\n\n\n\n\n\n\n\n\n\nvar Runtime = {\n    nextAuthCallbackID: 1,\n    auth_callbacks: {},\n    ScriptReceivers: ScriptReceivers,\n    DependenciesReceivers: DependenciesReceivers,\n    getDefaultStrategy: default_strategy,\n    Transports: transports_transports,\n    transportConnectionInitializer: transport_connection_initializer,\n    HTTPFactory: web_http_http,\n    TimelineTransport: jsonp_timeline,\n    getXHRAPI() {\n        return window.XMLHttpRequest;\n    },\n    getWebSocketAPI() {\n        return window.WebSocket || window.MozWebSocket;\n    },\n    setup(PusherClass) {\n        window.Pusher = PusherClass;\n        var initializeOnDocumentBody = () => {\n            this.onDocumentBody(PusherClass.ready);\n        };\n        if (!window.JSON) {\n            Dependencies.load('json2', {}, initializeOnDocumentBody);\n        }\n        else {\n            initializeOnDocumentBody();\n        }\n    },\n    getDocument() {\n        return document;\n    },\n    getProtocol() {\n        return this.getDocument().location.protocol;\n    },\n    getAuthorizers() {\n        return { ajax: xhr_auth, jsonp: jsonp_auth };\n    },\n    onDocumentBody(callback) {\n        if (document.body) {\n            callback();\n        }\n        else {\n            setTimeout(() => {\n                this.onDocumentBody(callback);\n            }, 0);\n        }\n    },\n    createJSONPRequest(url, data) {\n        return new jsonp_request_JSONPRequest(url, data);\n    },\n    createScriptRequest(src) {\n        return new ScriptRequest(src);\n    },\n    getLocalStorage() {\n        try {\n            return window.localStorage;\n        }\n        catch (e) {\n            return undefined;\n        }\n    },\n    createXHR() {\n        if (this.getXHRAPI()) {\n            return this.createXMLHttpRequest();\n        }\n        else {\n            return this.createMicrosoftXHR();\n        }\n    },\n    createXMLHttpRequest() {\n        var Constructor = this.getXHRAPI();\n        return new Constructor();\n    },\n    createMicrosoftXHR() {\n        return new ActiveXObject('Microsoft.XMLHTTP');\n    },\n    getNetwork() {\n        return net_info_Network;\n    },\n    createWebSocket(url) {\n        var Constructor = this.getWebSocketAPI();\n        return new Constructor(url);\n    },\n    createSocketRequest(method, url) {\n        if (this.isXHRSupported()) {\n            return this.HTTPFactory.createXHR(method, url);\n        }\n        else if (this.isXDRSupported(url.indexOf('https:') === 0)) {\n            return this.HTTPFactory.createXDR(method, url);\n        }\n        else {\n            throw 'Cross-origin HTTP requests are not supported';\n        }\n    },\n    isXHRSupported() {\n        var Constructor = this.getXHRAPI();\n        return (Boolean(Constructor) && new Constructor().withCredentials !== undefined);\n    },\n    isXDRSupported(useTLS) {\n        var protocol = useTLS ? 'https:' : 'http:';\n        var documentProtocol = this.getProtocol();\n        return (Boolean(window['XDomainRequest']) && documentProtocol === protocol);\n    },\n    addUnloadListener(listener) {\n        if (window.addEventListener !== undefined) {\n            window.addEventListener('unload', listener, false);\n        }\n        else if (window.attachEvent !== undefined) {\n            window.attachEvent('onunload', listener);\n        }\n    },\n    removeUnloadListener(listener) {\n        if (window.addEventListener !== undefined) {\n            window.removeEventListener('unload', listener, false);\n        }\n        else if (window.detachEvent !== undefined) {\n            window.detachEvent('onunload', listener);\n        }\n    },\n    randomInt(max) {\n        const random = function () {\n            const crypto = window.crypto || window['msCrypto'];\n            const random = crypto.getRandomValues(new Uint32Array(1))[0];\n            return random / Math.pow(2, 32);\n        };\n        return Math.floor(random() * max);\n    },\n};\n/* harmony default export */ var runtime = (Runtime);\n\n// CONCATENATED MODULE: ./src/core/timeline/level.ts\nvar TimelineLevel;\n(function (TimelineLevel) {\n    TimelineLevel[TimelineLevel[\"ERROR\"] = 3] = \"ERROR\";\n    TimelineLevel[TimelineLevel[\"INFO\"] = 6] = \"INFO\";\n    TimelineLevel[TimelineLevel[\"DEBUG\"] = 7] = \"DEBUG\";\n})(TimelineLevel || (TimelineLevel = {}));\n/* harmony default export */ var timeline_level = (TimelineLevel);\n\n// CONCATENATED MODULE: ./src/core/timeline/timeline.ts\n\n\n\nclass timeline_Timeline {\n    constructor(key, session, options) {\n        this.key = key;\n        this.session = session;\n        this.events = [];\n        this.options = options || {};\n        this.sent = 0;\n        this.uniqueID = 0;\n    }\n    log(level, event) {\n        if (level <= this.options.level) {\n            this.events.push(extend({}, event, { timestamp: util.now() }));\n            if (this.options.limit && this.events.length > this.options.limit) {\n                this.events.shift();\n            }\n        }\n    }\n    error(event) {\n        this.log(timeline_level.ERROR, event);\n    }\n    info(event) {\n        this.log(timeline_level.INFO, event);\n    }\n    debug(event) {\n        this.log(timeline_level.DEBUG, event);\n    }\n    isEmpty() {\n        return this.events.length === 0;\n    }\n    send(sendfn, callback) {\n        var data = extend({\n            session: this.session,\n            bundle: this.sent + 1,\n            key: this.key,\n            lib: 'js',\n            version: this.options.version,\n            cluster: this.options.cluster,\n            features: this.options.features,\n            timeline: this.events,\n        }, this.options.params);\n        this.events = [];\n        sendfn(data, (error, result) => {\n            if (!error) {\n                this.sent++;\n            }\n            if (callback) {\n                callback(error, result);\n            }\n        });\n        return true;\n    }\n    generateUniqueID() {\n        this.uniqueID++;\n        return this.uniqueID;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/transport_strategy.ts\n\n\n\n\nclass transport_strategy_TransportStrategy {\n    constructor(name, priority, transport, options) {\n        this.name = name;\n        this.priority = priority;\n        this.transport = transport;\n        this.options = options || {};\n    }\n    isSupported() {\n        return this.transport.isSupported({\n            useTLS: this.options.useTLS,\n        });\n    }\n    connect(minPriority, callback) {\n        if (!this.isSupported()) {\n            return failAttempt(new UnsupportedStrategy(), callback);\n        }\n        else if (this.priority < minPriority) {\n            return failAttempt(new TransportPriorityTooLow(), callback);\n        }\n        var connected = false;\n        var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);\n        var handshake = null;\n        var onInitialized = function () {\n            transport.unbind('initialized', onInitialized);\n            transport.connect();\n        };\n        var onOpen = function () {\n            handshake = factory.createHandshake(transport, function (result) {\n                connected = true;\n                unbindListeners();\n                callback(null, result);\n            });\n        };\n        var onError = function (error) {\n            unbindListeners();\n            callback(error);\n        };\n        var onClosed = function () {\n            unbindListeners();\n            var serializedTransport;\n            serializedTransport = safeJSONStringify(transport);\n            callback(new TransportClosed(serializedTransport));\n        };\n        var unbindListeners = function () {\n            transport.unbind('initialized', onInitialized);\n            transport.unbind('open', onOpen);\n            transport.unbind('error', onError);\n            transport.unbind('closed', onClosed);\n        };\n        transport.bind('initialized', onInitialized);\n        transport.bind('open', onOpen);\n        transport.bind('error', onError);\n        transport.bind('closed', onClosed);\n        transport.initialize();\n        return {\n            abort: () => {\n                if (connected) {\n                    return;\n                }\n                unbindListeners();\n                if (handshake) {\n                    handshake.close();\n                }\n                else {\n                    transport.close();\n                }\n            },\n            forceMinPriority: (p) => {\n                if (connected) {\n                    return;\n                }\n                if (this.priority < p) {\n                    if (handshake) {\n                        handshake.close();\n                    }\n                    else {\n                        transport.close();\n                    }\n                }\n            },\n        };\n    }\n}\nfunction failAttempt(error, callback) {\n    util.defer(function () {\n        callback(error);\n    });\n    return {\n        abort: function () { },\n        forceMinPriority: function () { },\n    };\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/strategy_builder.ts\n\n\n\n\n\nconst { Transports: strategy_builder_Transports } = runtime;\nvar strategy_builder_defineTransport = function (config, name, type, priority, options, manager) {\n    var transportClass = strategy_builder_Transports[type];\n    if (!transportClass) {\n        throw new UnsupportedTransport(type);\n    }\n    var enabled = (!config.enabledTransports ||\n        arrayIndexOf(config.enabledTransports, name) !== -1) &&\n        (!config.disabledTransports ||\n            arrayIndexOf(config.disabledTransports, name) === -1);\n    var transport;\n    if (enabled) {\n        options = Object.assign({ ignoreNullOrigin: config.ignoreNullOrigin }, options);\n        transport = new transport_strategy_TransportStrategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, options);\n    }\n    else {\n        transport = strategy_builder_UnsupportedStrategy;\n    }\n    return transport;\n};\nvar strategy_builder_UnsupportedStrategy = {\n    isSupported: function () {\n        return false;\n    },\n    connect: function (_, callback) {\n        var deferred = util.defer(function () {\n            callback(new UnsupportedStrategy());\n        });\n        return {\n            abort: function () {\n                deferred.ensureAborted();\n            },\n            forceMinPriority: function () { },\n        };\n    },\n};\n\n// CONCATENATED MODULE: ./src/core/options.ts\n\nfunction validateOptions(options) {\n    if (options == null) {\n        throw 'You must pass an options object';\n    }\n    if (options.cluster == null) {\n        throw 'Options object must provide a cluster';\n    }\n    if ('disableStats' in options) {\n        logger.warn('The disableStats option is deprecated in favor of enableStats');\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/auth/user_authenticator.ts\n\n\nconst composeChannelQuery = (params, authOptions) => {\n    var query = 'socket_id=' + encodeURIComponent(params.socketId);\n    for (var key in authOptions.params) {\n        query +=\n            '&' +\n                encodeURIComponent(key) +\n                '=' +\n                encodeURIComponent(authOptions.params[key]);\n    }\n    if (authOptions.paramsProvider != null) {\n        let dynamicParams = authOptions.paramsProvider();\n        for (var key in dynamicParams) {\n            query +=\n                '&' +\n                    encodeURIComponent(key) +\n                    '=' +\n                    encodeURIComponent(dynamicParams[key]);\n        }\n    }\n    return query;\n};\nconst UserAuthenticator = (authOptions) => {\n    if (typeof runtime.getAuthorizers()[authOptions.transport] === 'undefined') {\n        throw `'${authOptions.transport}' is not a recognized auth transport`;\n    }\n    return (params, callback) => {\n        const query = composeChannelQuery(params, authOptions);\n        runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.UserAuthentication, callback);\n    };\n};\n/* harmony default export */ var user_authenticator = (UserAuthenticator);\n\n// CONCATENATED MODULE: ./src/core/auth/channel_authorizer.ts\n\n\nconst channel_authorizer_composeChannelQuery = (params, authOptions) => {\n    var query = 'socket_id=' + encodeURIComponent(params.socketId);\n    query += '&channel_name=' + encodeURIComponent(params.channelName);\n    for (var key in authOptions.params) {\n        query +=\n            '&' +\n                encodeURIComponent(key) +\n                '=' +\n                encodeURIComponent(authOptions.params[key]);\n    }\n    if (authOptions.paramsProvider != null) {\n        let dynamicParams = authOptions.paramsProvider();\n        for (var key in dynamicParams) {\n            query +=\n                '&' +\n                    encodeURIComponent(key) +\n                    '=' +\n                    encodeURIComponent(dynamicParams[key]);\n        }\n    }\n    return query;\n};\nconst ChannelAuthorizer = (authOptions) => {\n    if (typeof runtime.getAuthorizers()[authOptions.transport] === 'undefined') {\n        throw `'${authOptions.transport}' is not a recognized auth transport`;\n    }\n    return (params, callback) => {\n        const query = channel_authorizer_composeChannelQuery(params, authOptions);\n        runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.ChannelAuthorization, callback);\n    };\n};\n/* harmony default export */ var channel_authorizer = (ChannelAuthorizer);\n\n// CONCATENATED MODULE: ./src/core/auth/deprecated_channel_authorizer.ts\nconst ChannelAuthorizerProxy = (pusher, authOptions, channelAuthorizerGenerator) => {\n    const deprecatedAuthorizerOptions = {\n        authTransport: authOptions.transport,\n        authEndpoint: authOptions.endpoint,\n        auth: {\n            params: authOptions.params,\n            headers: authOptions.headers,\n        },\n    };\n    return (params, callback) => {\n        const channel = pusher.channel(params.channelName);\n        const channelAuthorizer = channelAuthorizerGenerator(channel, deprecatedAuthorizerOptions);\n        channelAuthorizer.authorize(params.socketId, callback);\n    };\n};\n\n// CONCATENATED MODULE: ./src/core/config.ts\n\n\n\n\n\nfunction getConfig(opts, pusher) {\n    let config = {\n        activityTimeout: opts.activityTimeout || defaults.activityTimeout,\n        cluster: opts.cluster,\n        httpPath: opts.httpPath || defaults.httpPath,\n        httpPort: opts.httpPort || defaults.httpPort,\n        httpsPort: opts.httpsPort || defaults.httpsPort,\n        pongTimeout: opts.pongTimeout || defaults.pongTimeout,\n        statsHost: opts.statsHost || defaults.stats_host,\n        unavailableTimeout: opts.unavailableTimeout || defaults.unavailableTimeout,\n        wsPath: opts.wsPath || defaults.wsPath,\n        wsPort: opts.wsPort || defaults.wsPort,\n        wssPort: opts.wssPort || defaults.wssPort,\n        enableStats: getEnableStatsConfig(opts),\n        httpHost: getHttpHost(opts),\n        useTLS: shouldUseTLS(opts),\n        wsHost: getWebsocketHost(opts),\n        userAuthenticator: buildUserAuthenticator(opts),\n        channelAuthorizer: buildChannelAuthorizer(opts, pusher),\n    };\n    if ('disabledTransports' in opts)\n        config.disabledTransports = opts.disabledTransports;\n    if ('enabledTransports' in opts)\n        config.enabledTransports = opts.enabledTransports;\n    if ('ignoreNullOrigin' in opts)\n        config.ignoreNullOrigin = opts.ignoreNullOrigin;\n    if ('timelineParams' in opts)\n        config.timelineParams = opts.timelineParams;\n    if ('nacl' in opts) {\n        config.nacl = opts.nacl;\n    }\n    return config;\n}\nfunction getHttpHost(opts) {\n    if (opts.httpHost) {\n        return opts.httpHost;\n    }\n    if (opts.cluster) {\n        return `sockjs-${opts.cluster}.pusher.com`;\n    }\n    return defaults.httpHost;\n}\nfunction getWebsocketHost(opts) {\n    if (opts.wsHost) {\n        return opts.wsHost;\n    }\n    return getWebsocketHostFromCluster(opts.cluster);\n}\nfunction getWebsocketHostFromCluster(cluster) {\n    return `ws-${cluster}.pusher.com`;\n}\nfunction shouldUseTLS(opts) {\n    if (runtime.getProtocol() === 'https:') {\n        return true;\n    }\n    else if (opts.forceTLS === false) {\n        return false;\n    }\n    return true;\n}\nfunction getEnableStatsConfig(opts) {\n    if ('enableStats' in opts) {\n        return opts.enableStats;\n    }\n    if ('disableStats' in opts) {\n        return !opts.disableStats;\n    }\n    return false;\n}\nfunction buildUserAuthenticator(opts) {\n    const userAuthentication = Object.assign(Object.assign({}, defaults.userAuthentication), opts.userAuthentication);\n    if ('customHandler' in userAuthentication &&\n        userAuthentication['customHandler'] != null) {\n        return userAuthentication['customHandler'];\n    }\n    return user_authenticator(userAuthentication);\n}\nfunction buildChannelAuth(opts, pusher) {\n    let channelAuthorization;\n    if ('channelAuthorization' in opts) {\n        channelAuthorization = Object.assign(Object.assign({}, defaults.channelAuthorization), opts.channelAuthorization);\n    }\n    else {\n        channelAuthorization = {\n            transport: opts.authTransport || defaults.authTransport,\n            endpoint: opts.authEndpoint || defaults.authEndpoint,\n        };\n        if ('auth' in opts) {\n            if ('params' in opts.auth)\n                channelAuthorization.params = opts.auth.params;\n            if ('headers' in opts.auth)\n                channelAuthorization.headers = opts.auth.headers;\n        }\n        if ('authorizer' in opts)\n            channelAuthorization.customHandler = ChannelAuthorizerProxy(pusher, channelAuthorization, opts.authorizer);\n    }\n    return channelAuthorization;\n}\nfunction buildChannelAuthorizer(opts, pusher) {\n    const channelAuthorization = buildChannelAuth(opts, pusher);\n    if ('customHandler' in channelAuthorization &&\n        channelAuthorization['customHandler'] != null) {\n        return channelAuthorization['customHandler'];\n    }\n    return channel_authorizer(channelAuthorization);\n}\n\n// CONCATENATED MODULE: ./src/core/watchlist.ts\n\n\nclass watchlist_WatchlistFacade extends dispatcher_Dispatcher {\n    constructor(pusher) {\n        super(function (eventName, data) {\n            logger.debug(`No callbacks on watchlist events for ${eventName}`);\n        });\n        this.pusher = pusher;\n        this.bindWatchlistInternalEvent();\n    }\n    handleEvent(pusherEvent) {\n        pusherEvent.data.events.forEach((watchlistEvent) => {\n            this.emit(watchlistEvent.name, watchlistEvent);\n        });\n    }\n    bindWatchlistInternalEvent() {\n        this.pusher.connection.bind('message', (pusherEvent) => {\n            var eventName = pusherEvent.event;\n            if (eventName === 'pusher_internal:watchlist_events') {\n                this.handleEvent(pusherEvent);\n            }\n        });\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/utils/flat_promise.ts\nfunction flatPromise() {\n    let resolve, reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n/* harmony default export */ var flat_promise = (flatPromise);\n\n// CONCATENATED MODULE: ./src/core/user.ts\n\n\n\n\n\nclass user_UserFacade extends dispatcher_Dispatcher {\n    constructor(pusher) {\n        super(function (eventName, data) {\n            logger.debug('No callbacks on user for ' + eventName);\n        });\n        this.signin_requested = false;\n        this.user_data = null;\n        this.serverToUserChannel = null;\n        this.signinDonePromise = null;\n        this._signinDoneResolve = null;\n        this._onAuthorize = (err, authData) => {\n            if (err) {\n                logger.warn(`Error during signin: ${err}`);\n                this._cleanup();\n                return;\n            }\n            this.pusher.send_event('pusher:signin', {\n                auth: authData.auth,\n                user_data: authData.user_data,\n            });\n        };\n        this.pusher = pusher;\n        this.pusher.connection.bind('state_change', ({ previous, current }) => {\n            if (previous !== 'connected' && current === 'connected') {\n                this._signin();\n            }\n            if (previous === 'connected' && current !== 'connected') {\n                this._cleanup();\n                this._newSigninPromiseIfNeeded();\n            }\n        });\n        this.watchlist = new watchlist_WatchlistFacade(pusher);\n        this.pusher.connection.bind('message', (event) => {\n            var eventName = event.event;\n            if (eventName === 'pusher:signin_success') {\n                this._onSigninSuccess(event.data);\n            }\n            if (this.serverToUserChannel &&\n                this.serverToUserChannel.name === event.channel) {\n                this.serverToUserChannel.handleEvent(event);\n            }\n        });\n    }\n    signin() {\n        if (this.signin_requested) {\n            return;\n        }\n        this.signin_requested = true;\n        this._signin();\n    }\n    _signin() {\n        if (!this.signin_requested) {\n            return;\n        }\n        this._newSigninPromiseIfNeeded();\n        if (this.pusher.connection.state !== 'connected') {\n            return;\n        }\n        this.pusher.config.userAuthenticator({\n            socketId: this.pusher.connection.socket_id,\n        }, this._onAuthorize);\n    }\n    _onSigninSuccess(data) {\n        try {\n            this.user_data = JSON.parse(data.user_data);\n        }\n        catch (e) {\n            logger.error(`Failed parsing user data after signin: ${data.user_data}`);\n            this._cleanup();\n            return;\n        }\n        if (typeof this.user_data.id !== 'string' || this.user_data.id === '') {\n            logger.error(`user_data doesn't contain an id. user_data: ${this.user_data}`);\n            this._cleanup();\n            return;\n        }\n        this._signinDoneResolve();\n        this._subscribeChannels();\n    }\n    _subscribeChannels() {\n        const ensure_subscribed = (channel) => {\n            if (channel.subscriptionPending && channel.subscriptionCancelled) {\n                channel.reinstateSubscription();\n            }\n            else if (!channel.subscriptionPending &&\n                this.pusher.connection.state === 'connected') {\n                channel.subscribe();\n            }\n        };\n        this.serverToUserChannel = new channel_Channel(`#server-to-user-${this.user_data.id}`, this.pusher);\n        this.serverToUserChannel.bind_global((eventName, data) => {\n            if (eventName.indexOf('pusher_internal:') === 0 ||\n                eventName.indexOf('pusher:') === 0) {\n                return;\n            }\n            this.emit(eventName, data);\n        });\n        ensure_subscribed(this.serverToUserChannel);\n    }\n    _cleanup() {\n        this.user_data = null;\n        if (this.serverToUserChannel) {\n            this.serverToUserChannel.unbind_all();\n            this.serverToUserChannel.disconnect();\n            this.serverToUserChannel = null;\n        }\n        if (this.signin_requested) {\n            this._signinDoneResolve();\n        }\n    }\n    _newSigninPromiseIfNeeded() {\n        if (!this.signin_requested) {\n            return;\n        }\n        if (this.signinDonePromise && !this.signinDonePromise.done) {\n            return;\n        }\n        const { promise, resolve, reject: _ } = flat_promise();\n        promise.done = false;\n        const setDone = () => {\n            promise.done = true;\n        };\n        promise.then(setDone).catch(setDone);\n        this.signinDonePromise = promise;\n        this._signinDoneResolve = resolve;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/pusher.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass pusher_Pusher {\n    static ready() {\n        pusher_Pusher.isReady = true;\n        for (var i = 0, l = pusher_Pusher.instances.length; i < l; i++) {\n            pusher_Pusher.instances[i].connect();\n        }\n    }\n    static getClientFeatures() {\n        return keys(filterObject({ ws: runtime.Transports.ws }, function (t) {\n            return t.isSupported({});\n        }));\n    }\n    constructor(app_key, options) {\n        checkAppKey(app_key);\n        validateOptions(options);\n        this.key = app_key;\n        this.config = getConfig(options, this);\n        this.channels = factory.createChannels();\n        this.global_emitter = new dispatcher_Dispatcher();\n        this.sessionID = runtime.randomInt(1000000000);\n        this.timeline = new timeline_Timeline(this.key, this.sessionID, {\n            cluster: this.config.cluster,\n            features: pusher_Pusher.getClientFeatures(),\n            params: this.config.timelineParams || {},\n            limit: 50,\n            level: timeline_level.INFO,\n            version: defaults.VERSION,\n        });\n        if (this.config.enableStats) {\n            this.timelineSender = factory.createTimelineSender(this.timeline, {\n                host: this.config.statsHost,\n                path: '/timeline/v2/' + runtime.TimelineTransport.name,\n            });\n        }\n        var getStrategy = (options) => {\n            return runtime.getDefaultStrategy(this.config, options, strategy_builder_defineTransport);\n        };\n        this.connection = factory.createConnectionManager(this.key, {\n            getStrategy: getStrategy,\n            timeline: this.timeline,\n            activityTimeout: this.config.activityTimeout,\n            pongTimeout: this.config.pongTimeout,\n            unavailableTimeout: this.config.unavailableTimeout,\n            useTLS: Boolean(this.config.useTLS),\n        });\n        this.connection.bind('connected', () => {\n            this.subscribeAll();\n            if (this.timelineSender) {\n                this.timelineSender.send(this.connection.isUsingTLS());\n            }\n        });\n        this.connection.bind('message', (event) => {\n            var eventName = event.event;\n            var internal = eventName.indexOf('pusher_internal:') === 0;\n            if (event.channel) {\n                var channel = this.channel(event.channel);\n                if (channel) {\n                    channel.handleEvent(event);\n                }\n            }\n            if (!internal) {\n                this.global_emitter.emit(event.event, event.data);\n            }\n        });\n        this.connection.bind('connecting', () => {\n            this.channels.disconnect();\n        });\n        this.connection.bind('disconnected', () => {\n            this.channels.disconnect();\n        });\n        this.connection.bind('error', (err) => {\n            logger.warn(err);\n        });\n        pusher_Pusher.instances.push(this);\n        this.timeline.info({ instances: pusher_Pusher.instances.length });\n        this.user = new user_UserFacade(this);\n        if (pusher_Pusher.isReady) {\n            this.connect();\n        }\n    }\n    channel(name) {\n        return this.channels.find(name);\n    }\n    allChannels() {\n        return this.channels.all();\n    }\n    connect() {\n        this.connection.connect();\n        if (this.timelineSender) {\n            if (!this.timelineSenderTimer) {\n                var usingTLS = this.connection.isUsingTLS();\n                var timelineSender = this.timelineSender;\n                this.timelineSenderTimer = new timers_PeriodicTimer(60000, function () {\n                    timelineSender.send(usingTLS);\n                });\n            }\n        }\n    }\n    disconnect() {\n        this.connection.disconnect();\n        if (this.timelineSenderTimer) {\n            this.timelineSenderTimer.ensureAborted();\n            this.timelineSenderTimer = null;\n        }\n    }\n    bind(event_name, callback, context) {\n        this.global_emitter.bind(event_name, callback, context);\n        return this;\n    }\n    unbind(event_name, callback, context) {\n        this.global_emitter.unbind(event_name, callback, context);\n        return this;\n    }\n    bind_global(callback) {\n        this.global_emitter.bind_global(callback);\n        return this;\n    }\n    unbind_global(callback) {\n        this.global_emitter.unbind_global(callback);\n        return this;\n    }\n    unbind_all(callback) {\n        this.global_emitter.unbind_all();\n        return this;\n    }\n    subscribeAll() {\n        var channelName;\n        for (channelName in this.channels.channels) {\n            if (this.channels.channels.hasOwnProperty(channelName)) {\n                this.subscribe(channelName);\n            }\n        }\n    }\n    subscribe(channel_name) {\n        var channel = this.channels.add(channel_name, this);\n        if (channel.subscriptionPending && channel.subscriptionCancelled) {\n            channel.reinstateSubscription();\n        }\n        else if (!channel.subscriptionPending &&\n            this.connection.state === 'connected') {\n            channel.subscribe();\n        }\n        return channel;\n    }\n    unsubscribe(channel_name) {\n        var channel = this.channels.find(channel_name);\n        if (channel && channel.subscriptionPending) {\n            channel.cancelSubscription();\n        }\n        else {\n            channel = this.channels.remove(channel_name);\n            if (channel && channel.subscribed) {\n                channel.unsubscribe();\n            }\n        }\n    }\n    send_event(event_name, data, channel) {\n        return this.connection.send_event(event_name, data, channel);\n    }\n    shouldUseTLS() {\n        return this.config.useTLS;\n    }\n    signin() {\n        this.user.signin();\n    }\n}\npusher_Pusher.instances = [];\npusher_Pusher.isReady = false;\npusher_Pusher.logToConsole = false;\npusher_Pusher.Runtime = runtime;\npusher_Pusher.ScriptReceivers = runtime.ScriptReceivers;\npusher_Pusher.DependenciesReceivers = runtime.DependenciesReceivers;\npusher_Pusher.auth_callbacks = runtime.auth_callbacks;\n/* harmony default export */ var core_pusher = __nested_webpack_exports__[\"default\"] = (pusher_Pusher);\nfunction checkAppKey(key) {\n    if (key === null || key === undefined) {\n        throw 'You must pass your app key when you instantiate Pusher.';\n    }\n}\nruntime.setup(pusher_Pusher);\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=pusher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHVzaGVyLWpzL2Rpc3Qvd2ViL3B1c2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS3VCO0FBQzdCLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEMsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZ0NBQWdDLDhCQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUFtQjtBQUM5QixrREFBa0QsZ0NBQWdDO0FBQ2xGLDBFQUEwRSw4QkFBbUIsNEJBQTRCLG9CQUFvQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUIsQ0FBQyw4QkFBbUI7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOERBQThEO0FBQzlELDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhEQUE4RDtBQUM5RCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0wseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUUsdUVBQXVFLGFBQWE7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZCQUE2QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7QUFDdkI7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXLHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywwQkFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3B1c2hlci1qcy9kaXN0L3dlYi9wdXNoZXIuanM/ZGM4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFB1c2hlciBKYXZhU2NyaXB0IExpYnJhcnkgdjguNC4wXG4gKiBodHRwczovL3B1c2hlci5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMjAsIFB1c2hlclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbmNlLlxuICovXG5cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlB1c2hlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJQdXNoZXJcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTYgRG1pdHJ5IENoZXN0bnlraFxuLy8gTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUGFja2FnZSBiYXNlNjQgaW1wbGVtZW50cyBCYXNlNjQgZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICovXG4vLyBJbnZhbGlkIGNoYXJhY3RlciB1c2VkIGluIGRlY29kaW5nIHRvIGluZGljYXRlXG4vLyB0aGF0IHRoZSBjaGFyYWN0ZXIgdG8gZGVjb2RlIGlzIG91dCBvZiByYW5nZSBvZlxuLy8gYWxwaGFiZXQgYW5kIGNhbm5vdCBiZSBkZWNvZGVkLlxudmFyIElOVkFMSURfQllURSA9IDI1Njtcbi8qKlxuICogSW1wbGVtZW50cyBzdGFuZGFyZCBCYXNlNjQgZW5jb2RpbmcuXG4gKlxuICogT3BlcmF0ZXMgaW4gY29uc3RhbnQgdGltZS5cbiAqL1xudmFyIENvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE8oZGNoZXN0KTogbWV0aG9kcyB0byBlbmNvZGUgY2h1bmstYnktY2h1bmsuXG4gICAgZnVuY3Rpb24gQ29kZXIoX3BhZGRpbmdDaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKF9wYWRkaW5nQ2hhcmFjdGVyID09PSB2b2lkIDApIHsgX3BhZGRpbmdDaGFyYWN0ZXIgPSBcIj1cIjsgfVxuICAgICAgICB0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyID0gX3BhZGRpbmdDaGFyYWN0ZXI7XG4gICAgfVxuICAgIENvZGVyLnByb3RvdHlwZS5lbmNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAobGVuZ3RoICogOCArIDUpIC8gNiB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChsZW5ndGggKyAyKSAvIDMgKiA0IHwgMDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgb3V0ID0gXCJcIjtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGRhdGEubGVuZ3RoIC0gMjsgaSArPSAzKSB7XG4gICAgICAgICAgICB2YXIgYyA9IChkYXRhW2ldIDw8IDE2KSB8IChkYXRhW2kgKyAxXSA8PCA4KSB8IChkYXRhW2kgKyAyXSk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMyAqIDYpICYgNjMpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDIgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAxICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMCAqIDYpICYgNjMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0ID0gZGF0YS5sZW5ndGggLSBpO1xuICAgICAgICBpZiAobGVmdCA+IDApIHtcbiAgICAgICAgICAgIHZhciBjID0gKGRhdGFbaV0gPDwgMTYpIHwgKGxlZnQgPT09IDIgPyBkYXRhW2kgKyAxXSA8PCA4IDogMCk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMyAqIDYpICYgNjMpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDIgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIGlmIChsZWZ0ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDEgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyIHx8IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fcGFkZGluZ0NoYXJhY3RlciB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBDb2Rlci5wcm90b3R5cGUubWF4RGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGxlbmd0aCAqIDYgKyA3KSAvIDggfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW5ndGggLyA0ICogMyB8IDA7XG4gICAgfTtcbiAgICBDb2Rlci5wcm90b3R5cGUuZGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heERlY29kZWRMZW5ndGgocy5sZW5ndGggLSB0aGlzLl9nZXRQYWRkaW5nTGVuZ3RoKHMpKTtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocykge1xuICAgICAgICBpZiAocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFkZGluZ0xlbmd0aCA9IHRoaXMuX2dldFBhZGRpbmdMZW5ndGgocyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBzLmxlbmd0aCAtIHBhZGRpbmdMZW5ndGg7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm1heERlY29kZWRMZW5ndGgobGVuZ3RoKSk7XG4gICAgICAgIHZhciBvcCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGhhdmVCYWQgPSAwO1xuICAgICAgICB2YXIgdjAgPSAwLCB2MSA9IDAsIHYyID0gMCwgdjMgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aCAtIDQ7IGkgKz0gNCkge1xuICAgICAgICAgICAgdjAgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMCkpO1xuICAgICAgICAgICAgdjEgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgdjIgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMikpO1xuICAgICAgICAgICAgdjMgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMykpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYwIDw8IDIpIHwgKHYxID4+PiA0KTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MSA8PCA0KSB8ICh2MiA+Pj4gMik7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjIgPDwgNikgfCB2MztcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjAgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYxICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MiAmIElOVkFMSURfQllURTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjMgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB2MCA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgIHYxID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDEpKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MCA8PCAyKSB8ICh2MSA+Pj4gNCk7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYwICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MSAmIElOVkFMSURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgIHYyID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSArIDIpKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MSA8PCA0KSB8ICh2MiA+Pj4gMik7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYyICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMykge1xuICAgICAgICAgICAgdjMgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMykpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYyIDw8IDYpIHwgdjM7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYzICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXZlQmFkICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXNlNjRDb2RlcjogaW5jb3JyZWN0IGNoYXJhY3RlcnMgZm9yIGRlY29kaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICAvLyBTdGFuZGFyZCBlbmNvZGluZyBoYXZlIHRoZSBmb2xsb3dpbmcgZW5jb2RlZC9kZWNvZGVkIHJhbmdlcyxcbiAgICAvLyB3aGljaCB3ZSBuZWVkIHRvIGNvbnZlcnQgYmV0d2Vlbi5cbiAgICAvL1xuICAgIC8vIEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaIGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6IDAxMjM0NTY3ODkgICsgICAvXG4gICAgLy8gSW5kZXg6ICAgMCAtIDI1ICAgICAgICAgICAgICAgICAgICAyNiAtIDUxICAgICAgICAgICAgICA1MiAtIDYxICAgNjIgIDYzXG4gICAgLy8gQVNDSUk6ICA2NSAtIDkwICAgICAgICAgICAgICAgICAgICA5NyAtIDEyMiAgICAgICAgICAgICA0OCAtIDU3ICAgNDMgIDQ3XG4gICAgLy9cbiAgICAvLyBFbmNvZGUgNiBiaXRzIGluIGIgaW50byBhIG5ldyBjaGFyYWN0ZXIuXG4gICAgQ29kZXIucHJvdG90eXBlLl9lbmNvZGVCeXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgLy8gRW5jb2RpbmcgdXNlcyBjb25zdGFudCB0aW1lIG9wZXJhdGlvbnMgYXMgZm9sbG93czpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMS4gRGVmaW5lIGNvbXBhcmlzb24gb2YgQSB3aXRoIEIgdXNpbmcgKEEgLSBCKSA+Pj4gODpcbiAgICAgICAgLy8gICAgICAgICAgaWYgQSA+IEIsIHRoZW4gcmVzdWx0IGlzIHBvc2l0aXZlIGludGVnZXJcbiAgICAgICAgLy8gICAgICAgICAgaWYgQSA8PSBCLCB0aGVuIHJlc3VsdCBpcyAwXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDIuIERlZmluZSBzZWxlY3Rpb24gb2YgQyBvciAwIHVzaW5nIGJpdHdpc2UgQU5EOiBYICYgQzpcbiAgICAgICAgLy8gICAgICAgICAgaWYgWCA9PSAwLCB0aGVuIHJlc3VsdCBpcyAwXG4gICAgICAgIC8vICAgICAgICAgIGlmIFggIT0gMCwgdGhlbiByZXN1bHQgaXMgQ1xuICAgICAgICAvL1xuICAgICAgICAvLyAzLiBTdGFydCB3aXRoIHRoZSBzbWFsbGVzdCBjb21wYXJpc29uIChiID49IDApLCB3aGljaCBpcyBhbHdheXNcbiAgICAgICAgLy8gICAgdHJ1ZSwgc28gc2V0IHRoZSByZXN1bHQgdG8gdGhlIHN0YXJ0aW5nIEFTQ0lJIHZhbHVlICg2NSkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDQuIENvbnRpbnVlIGNvbXBhcmluZyBiIHRvIGhpZ2hlciBBU0NJSSB2YWx1ZXMsIGFuZCBzZWxlY3RpbmdcbiAgICAgICAgLy8gICAgemVybyBpZiBjb21wYXJpc29uIGlzbid0IHRydWUsIG90aGVyd2lzZSBzZWxlY3RpbmcgYSB2YWx1ZVxuICAgICAgICAvLyAgICB0byBhZGQgdG8gcmVzdWx0LCB3aGljaDpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgICAgYSkgdW5kb2VzIHRoZSBwcmV2aW91cyBhZGRpdGlvblxuICAgICAgICAvLyAgICAgICAgICBiKSBwcm92aWRlcyBuZXcgdmFsdWUgdG8gYWRkXG4gICAgICAgIC8vXG4gICAgICAgIHZhciByZXN1bHQgPSBiO1xuICAgICAgICAvLyBiID49IDBcbiAgICAgICAgcmVzdWx0ICs9IDY1O1xuICAgICAgICAvLyBiID4gMjVcbiAgICAgICAgcmVzdWx0ICs9ICgoMjUgLSBiKSA+Pj4gOCkgJiAoKDAgLSA2NSkgLSAyNiArIDk3KTtcbiAgICAgICAgLy8gYiA+IDUxXG4gICAgICAgIHJlc3VsdCArPSAoKDUxIC0gYikgPj4+IDgpICYgKCgyNiAtIDk3KSAtIDUyICsgNDgpO1xuICAgICAgICAvLyBiID4gNjFcbiAgICAgICAgcmVzdWx0ICs9ICgoNjEgLSBiKSA+Pj4gOCkgJiAoKDUyIC0gNDgpIC0gNjIgKyA0Myk7XG4gICAgICAgIC8vIGIgPiA2MlxuICAgICAgICByZXN1bHQgKz0gKCg2MiAtIGIpID4+PiA4KSAmICgoNjIgLSA0MykgLSA2MyArIDQ3KTtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocmVzdWx0KTtcbiAgICB9O1xuICAgIC8vIERlY29kZSBhIGNoYXJhY3RlciBjb2RlIGludG8gYSBieXRlLlxuICAgIC8vIE11c3QgcmV0dXJuIDI1NiBpZiBjaGFyYWN0ZXIgaXMgb3V0IG9mIGFscGhhYmV0IHJhbmdlLlxuICAgIENvZGVyLnByb3RvdHlwZS5fZGVjb2RlQ2hhciA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIERlY29kaW5nIHdvcmtzIHNpbWlsYXIgdG8gZW5jb2Rpbmc6IHVzaW5nIHRoZSBzYW1lIGNvbXBhcmlzb25cbiAgICAgICAgLy8gZnVuY3Rpb24sIGJ1dCBub3cgaXQgd29ya3Mgb24gcmFuZ2VzOiByZXN1bHQgaXMgYWx3YXlzIGluY3JlbWVudGVkXG4gICAgICAgIC8vIGJ5IHZhbHVlLCBidXQgdGhpcyB2YWx1ZSBiZWNvbWVzIHplcm8gaWYgdGhlIHJhbmdlIGlzIG5vdFxuICAgICAgICAvLyBzYXRpc2ZpZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIERlY29kaW5nIHN0YXJ0cyB3aXRoIGludmFsaWQgdmFsdWUsIDI1Niwgd2hpY2ggaXMgdGhlblxuICAgICAgICAvLyBzdWJ0cmFjdGVkIHdoZW4gdGhlIHJhbmdlIGlzIHNhdGlzZmllZC4gSWYgbm9uZSBvZiB0aGUgcmFuZ2VzXG4gICAgICAgIC8vIGFwcGx5LCB0aGUgZnVuY3Rpb24gcmV0dXJucyAyNTYsIHdoaWNoIGlzIHRoZW4gY2hlY2tlZCBieVxuICAgICAgICAvLyB0aGUgY2FsbGVyIHRvIHRocm93IGVycm9yLlxuICAgICAgICB2YXIgcmVzdWx0ID0gSU5WQUxJRF9CWVRFOyAvLyBzdGFydCB3aXRoIGludmFsaWQgY2hhcmFjdGVyXG4gICAgICAgIC8vIGMgPT0gNDMgKGMgPiA0MiBhbmQgYyA8IDQ0KVxuICAgICAgICByZXN1bHQgKz0gKCgoNDIgLSBjKSAmIChjIC0gNDQpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA0MyArIDYyKTtcbiAgICAgICAgLy8gYyA9PSA0NyAoYyA+IDQ2IGFuZCBjIDwgNDgpXG4gICAgICAgIHJlc3VsdCArPSAoKCg0NiAtIGMpICYgKGMgLSA0OCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ3ICsgNjMpO1xuICAgICAgICAvLyBjID4gNDcgYW5kIGMgPCA1OFxuICAgICAgICByZXN1bHQgKz0gKCgoNDcgLSBjKSAmIChjIC0gNTgpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA0OCArIDUyKTtcbiAgICAgICAgLy8gYyA+IDY0IGFuZCBjIDwgOTFcbiAgICAgICAgcmVzdWx0ICs9ICgoKDY0IC0gYykgJiAoYyAtIDkxKSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNjUgKyAwKTtcbiAgICAgICAgLy8gYyA+IDk2IGFuZCBjIDwgMTIzXG4gICAgICAgIHJlc3VsdCArPSAoKCg5NiAtIGMpICYgKGMgLSAxMjMpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA5NyArIDI2KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5fZ2V0UGFkZGluZ0xlbmd0aCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBwYWRkaW5nTGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNbaV0gIT09IHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzLmxlbmd0aCA8IDQgfHwgcGFkZGluZ0xlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXNlNjRDb2RlcjogaW5jb3JyZWN0IHBhZGRpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZGRpbmdMZW5ndGg7XG4gICAgfTtcbiAgICByZXR1cm4gQ29kZXI7XG59KCkpO1xuZXhwb3J0cy5Db2RlciA9IENvZGVyO1xudmFyIHN0ZENvZGVyID0gbmV3IENvZGVyKCk7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIHJldHVybiBzdGRDb2Rlci5lbmNvZGUoZGF0YSk7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmZ1bmN0aW9uIGRlY29kZShzKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmRlY29kZShzKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqXG4gKiBJbXBsZW1lbnRzIFVSTC1zYWZlIEJhc2U2NCBlbmNvZGluZy5cbiAqIChTYW1lIGFzIEJhc2U2NCwgYnV0ICcrJyBpcyByZXBsYWNlZCB3aXRoICctJywgYW5kICcvJyB3aXRoICdfJykuXG4gKlxuICogT3BlcmF0ZXMgaW4gY29uc3RhbnQgdGltZS5cbiAqL1xudmFyIFVSTFNhZmVDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVVJMU2FmZUNvZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVSTFNhZmVDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvLyBVUkwtc2FmZSBlbmNvZGluZyBoYXZlIHRoZSBmb2xsb3dpbmcgZW5jb2RlZC9kZWNvZGVkIHJhbmdlczpcbiAgICAvL1xuICAgIC8vIEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaIGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6IDAxMjM0NTY3ODkgIC0gICBfXG4gICAgLy8gSW5kZXg6ICAgMCAtIDI1ICAgICAgICAgICAgICAgICAgICAyNiAtIDUxICAgICAgICAgICAgICA1MiAtIDYxICAgNjIgIDYzXG4gICAgLy8gQVNDSUk6ICA2NSAtIDkwICAgICAgICAgICAgICAgICAgICA5NyAtIDEyMiAgICAgICAgICAgICA0OCAtIDU3ICAgNDUgIDk1XG4gICAgLy9cbiAgICBVUkxTYWZlQ29kZXIucHJvdG90eXBlLl9lbmNvZGVCeXRlID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGI7XG4gICAgICAgIC8vIGIgPj0gMFxuICAgICAgICByZXN1bHQgKz0gNjU7XG4gICAgICAgIC8vIGIgPiAyNVxuICAgICAgICByZXN1bHQgKz0gKCgyNSAtIGIpID4+PiA4KSAmICgoMCAtIDY1KSAtIDI2ICsgOTcpO1xuICAgICAgICAvLyBiID4gNTFcbiAgICAgICAgcmVzdWx0ICs9ICgoNTEgLSBiKSA+Pj4gOCkgJiAoKDI2IC0gOTcpIC0gNTIgKyA0OCk7XG4gICAgICAgIC8vIGIgPiA2MVxuICAgICAgICByZXN1bHQgKz0gKCg2MSAtIGIpID4+PiA4KSAmICgoNTIgLSA0OCkgLSA2MiArIDQ1KTtcbiAgICAgICAgLy8gYiA+IDYyXG4gICAgICAgIHJlc3VsdCArPSAoKDYyIC0gYikgPj4+IDgpICYgKCg2MiAtIDQ1KSAtIDYzICsgOTUpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShyZXN1bHQpO1xuICAgIH07XG4gICAgVVJMU2FmZUNvZGVyLnByb3RvdHlwZS5fZGVjb2RlQ2hhciA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBJTlZBTElEX0JZVEU7XG4gICAgICAgIC8vIGMgPT0gNDUgKGMgPiA0NCBhbmQgYyA8IDQ2KVxuICAgICAgICByZXN1bHQgKz0gKCgoNDQgLSBjKSAmIChjIC0gNDYpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA0NSArIDYyKTtcbiAgICAgICAgLy8gYyA9PSA5NSAoYyA+IDk0IGFuZCBjIDwgOTYpXG4gICAgICAgIHJlc3VsdCArPSAoKCg5NCAtIGMpICYgKGMgLSA5NikpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDk1ICsgNjMpO1xuICAgICAgICAvLyBjID4gNDcgYW5kIGMgPCA1OFxuICAgICAgICByZXN1bHQgKz0gKCgoNDcgLSBjKSAmIChjIC0gNTgpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA0OCArIDUyKTtcbiAgICAgICAgLy8gYyA+IDY0IGFuZCBjIDwgOTFcbiAgICAgICAgcmVzdWx0ICs9ICgoKDY0IC0gYykgJiAoYyAtIDkxKSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNjUgKyAwKTtcbiAgICAgICAgLy8gYyA+IDk2IGFuZCBjIDwgMTIzXG4gICAgICAgIHJlc3VsdCArPSAoKCg5NiAtIGMpICYgKGMgLSAxMjMpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA5NyArIDI2KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBVUkxTYWZlQ29kZXI7XG59KENvZGVyKSk7XG5leHBvcnRzLlVSTFNhZmVDb2RlciA9IFVSTFNhZmVDb2RlcjtcbnZhciB1cmxTYWZlQ29kZXIgPSBuZXcgVVJMU2FmZUNvZGVyKCk7XG5mdW5jdGlvbiBlbmNvZGVVUkxTYWZlKGRhdGEpIHtcbiAgICByZXR1cm4gdXJsU2FmZUNvZGVyLmVuY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuZW5jb2RlVVJMU2FmZSA9IGVuY29kZVVSTFNhZmU7XG5mdW5jdGlvbiBkZWNvZGVVUkxTYWZlKHMpIHtcbiAgICByZXR1cm4gdXJsU2FmZUNvZGVyLmRlY29kZShzKTtcbn1cbmV4cG9ydHMuZGVjb2RlVVJMU2FmZSA9IGRlY29kZVVSTFNhZmU7XG5leHBvcnRzLmVuY29kZWRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmVuY29kZWRMZW5ndGgobGVuZ3RoKTtcbn07XG5leHBvcnRzLm1heERlY29kZWRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLm1heERlY29kZWRMZW5ndGgobGVuZ3RoKTtcbn07XG5leHBvcnRzLmRlY29kZWRMZW5ndGggPSBmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzdGRDb2Rlci5kZWNvZGVkTGVuZ3RoKHMpO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENvcHlyaWdodCAoQykgMjAxNiBEbWl0cnkgQ2hlc3RueWtoXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogUGFja2FnZSB1dGY4IGltcGxlbWVudHMgVVRGLTggZW5jb2RpbmcgYW5kIGRlY29kaW5nLlxuICovXG52YXIgSU5WQUxJRF9VVEYxNiA9IFwidXRmODogaW52YWxpZCBzdHJpbmdcIjtcbnZhciBJTlZBTElEX1VURjggPSBcInV0Zjg6IGludmFsaWQgc291cmNlIGVuY29kaW5nXCI7XG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIHN0cmluZyBpbnRvIFVURi04IGJ5dGUgYXJyYXkuXG4gKiBUaHJvd3MgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaGFzIGludmFsaWQgVVRGLTE2IGVuY29kaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUocykge1xuICAgIC8vIENhbGN1bGF0ZSByZXN1bHQgbGVuZ3RoIGFuZCBhbGxvY2F0ZSBvdXRwdXQgYXJyYXkuXG4gICAgLy8gZW5jb2RlZExlbmd0aCgpIGFsc28gdmFsaWRhdGVzIHN0cmluZyBhbmQgdGhyb3dzIGVycm9ycyxcbiAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHJlcGVhdCB2YWxpZGF0aW9uIGhlcmUuXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGVuY29kZWRMZW5ndGgocykpO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGMwIHwgYyA+PiA2O1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwKSB7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHhlMCB8IGMgPj4gMTI7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IChjID4+IDYpICYgMHgzZjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpKys7IC8vIGdldCBvbmUgbW9yZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGMgPSAoYyAmIDB4M2ZmKSA8PCAxMDtcbiAgICAgICAgICAgIGMgfD0gcy5jaGFyQ29kZUF0KGkpICYgMHgzZmY7XG4gICAgICAgICAgICBjICs9IDB4MTAwMDA7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHhmMCB8IGMgPj4gMTg7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IChjID4+IDEyKSAmIDB4M2Y7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IChjID4+IDYpICYgMHgzZjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gZW5jb2RlIHRoZSBnaXZlbiBzdHJpbmcgaW50byBVVEYtOC5cbiAqIFRocm93cyBpZiB0aGUgc291cmNlIHN0cmluZyBoYXMgaW52YWxpZCBVVEYtMTYgZW5jb2RpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZWRMZW5ndGgocykge1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEYxNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7IC8vIFwiZWF0XCIgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHJlc3VsdCArPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGMTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmVuY29kZWRMZW5ndGggPSBlbmNvZGVkTGVuZ3RoO1xuLyoqXG4gKiBEZWNvZGVzIHRoZSBnaXZlbiBieXRlIGFycmF5IGZyb20gVVRGLTggaW50byBhIHN0cmluZy5cbiAqIFRocm93cyBpZiBlbmNvZGluZyBpcyBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBkZWNvZGUoYXJyKSB7XG4gICAgdmFyIGNoYXJzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGIgPSBhcnJbaV07XG4gICAgICAgIGlmIChiICYgMHg4MCkge1xuICAgICAgICAgICAgdmFyIG1pbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChiIDwgMHhlMCkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgMSBtb3JlIGJ5dGUuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG4xID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgaWYgKChuMSAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gKGIgJiAweDFmKSA8PCA2IHwgKG4xICYgMHgzZik7XG4gICAgICAgICAgICAgICAgbWluID0gMHg4MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPCAweGYwKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAyIG1vcmUgYnl0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuMSA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMiA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIGlmICgobjEgJiAweGMwKSAhPT0gMHg4MCB8fCAobjIgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IChiICYgMHgwZikgPDwgMTIgfCAobjEgJiAweDNmKSA8PCA2IHwgKG4yICYgMHgzZik7XG4gICAgICAgICAgICAgICAgbWluID0gMHg4MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiIDwgMHhmOCkge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgMyBtb3JlIGJ5dGVzLlxuICAgICAgICAgICAgICAgIGlmIChpID49IGFyci5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbjEgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICB2YXIgbjIgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICB2YXIgbjMgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG4xICYgMHhjMCkgIT09IDB4ODAgfHwgKG4yICYgMHhjMCkgIT09IDB4ODAgfHwgKG4zICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSAoYiAmIDB4MGYpIDw8IDE4IHwgKG4xICYgMHgzZikgPDwgMTIgfCAobjIgJiAweDNmKSA8PCA2IHwgKG4zICYgMHgzZik7XG4gICAgICAgICAgICAgICAgbWluID0gMHgxMDAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIgPCBtaW4gfHwgKGIgPj0gMHhkODAwICYmIGIgPD0gMHhkZmZmKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIgPj0gMHgxMDAwMCkge1xuICAgICAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgICAgIGlmIChiID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICBjaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwIHwgKGIgPj4gMTApKSk7XG4gICAgICAgICAgICAgICAgYiA9IDB4ZGMwMCB8IChiICYgMHgzZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiKSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKFwiXCIpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHJlcXVpcmVkIHNvIHdlIGRvbid0IGhhdmUgdG8gZG8gcmVxdWlyZSgncHVzaGVyJykuZGVmYXVsdCBldGMuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMykuZGVmYXVsdDtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL2RvbS9zY3JpcHRfcmVjZWl2ZXJfZmFjdG9yeS50c1xuY2xhc3MgU2NyaXB0UmVjZWl2ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5sYXN0SWQgPSAwO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgY3JlYXRlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGFzdElkKys7XG4gICAgICAgIHZhciBudW1iZXIgPSB0aGlzLmxhc3RJZDtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5wcmVmaXggKyBudW1iZXI7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lICsgJ1snICsgbnVtYmVyICsgJ10nO1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBjYWxsYmFja1dyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1tudW1iZXJdID0gY2FsbGJhY2tXcmFwcGVyO1xuICAgICAgICByZXR1cm4geyBudW1iZXI6IG51bWJlciwgaWQ6IGlkLCBuYW1lOiBuYW1lLCBjYWxsYmFjazogY2FsbGJhY2tXcmFwcGVyIH07XG4gICAgfVxuICAgIHJlbW92ZShyZWNlaXZlcikge1xuICAgICAgICBkZWxldGUgdGhpc1tyZWNlaXZlci5udW1iZXJdO1xuICAgIH1cbn1cbnZhciBTY3JpcHRSZWNlaXZlcnMgPSBuZXcgU2NyaXB0UmVjZWl2ZXJGYWN0b3J5KCdfcHVzaGVyX3NjcmlwdF8nLCAnUHVzaGVyLlNjcmlwdFJlY2VpdmVycycpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2RlZmF1bHRzLnRzXG52YXIgRGVmYXVsdHMgPSB7XG4gICAgVkVSU0lPTjogXCI4LjQuMFwiLFxuICAgIFBST1RPQ09MOiA3LFxuICAgIHdzUG9ydDogODAsXG4gICAgd3NzUG9ydDogNDQzLFxuICAgIHdzUGF0aDogJycsXG4gICAgaHR0cEhvc3Q6ICdzb2NranMucHVzaGVyLmNvbScsXG4gICAgaHR0cFBvcnQ6IDgwLFxuICAgIGh0dHBzUG9ydDogNDQzLFxuICAgIGh0dHBQYXRoOiAnL3B1c2hlcicsXG4gICAgc3RhdHNfaG9zdDogJ3N0YXRzLnB1c2hlci5jb20nLFxuICAgIGF1dGhFbmRwb2ludDogJy9wdXNoZXIvYXV0aCcsXG4gICAgYXV0aFRyYW5zcG9ydDogJ2FqYXgnLFxuICAgIGFjdGl2aXR5VGltZW91dDogMTIwMDAwLFxuICAgIHBvbmdUaW1lb3V0OiAzMDAwMCxcbiAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IDEwMDAwLFxuICAgIHVzZXJBdXRoZW50aWNhdGlvbjoge1xuICAgICAgICBlbmRwb2ludDogJy9wdXNoZXIvdXNlci1hdXRoJyxcbiAgICAgICAgdHJhbnNwb3J0OiAnYWpheCcsXG4gICAgfSxcbiAgICBjaGFubmVsQXV0aG9yaXphdGlvbjoge1xuICAgICAgICBlbmRwb2ludDogJy9wdXNoZXIvYXV0aCcsXG4gICAgICAgIHRyYW5zcG9ydDogJ2FqYXgnLFxuICAgIH0sXG4gICAgY2RuX2h0dHA6IFwiaHR0cDovL2pzLnB1c2hlci5jb21cIixcbiAgICBjZG5faHR0cHM6IFwiaHR0cHM6Ly9qcy5wdXNoZXIuY29tXCIsXG4gICAgZGVwZW5kZW5jeV9zdWZmaXg6IFwiXCIsXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVmYXVsdHMgPSAoRGVmYXVsdHMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZG9tL2RlcGVuZGVuY3lfbG9hZGVyLnRzXG5cblxuY2xhc3MgZGVwZW5kZW5jeV9sb2FkZXJfRGVwZW5kZW5jeUxvYWRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlY2VpdmVycyA9IG9wdGlvbnMucmVjZWl2ZXJzIHx8IFNjcmlwdFJlY2VpdmVycztcbiAgICAgICAgdGhpcy5sb2FkaW5nID0ge307XG4gICAgfVxuICAgIGxvYWQobmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5sb2FkaW5nW25hbWVdICYmIHNlbGYubG9hZGluZ1tuYW1lXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRpbmdbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRpbmdbbmFtZV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBydW50aW1lLmNyZWF0ZVNjcmlwdFJlcXVlc3Qoc2VsZi5nZXRQYXRoKG5hbWUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHNlbGYucmVjZWl2ZXJzLmNyZWF0ZShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlY2VpdmVycy5yZW1vdmUocmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvYWRpbmdbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHNlbGYubG9hZGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYubG9hZGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICh3YXNTdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhc1N1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXShlcnJvciwgc3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSb290KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNkbjtcbiAgICAgICAgdmFyIHByb3RvY29sID0gcnVudGltZS5nZXREb2N1bWVudCgpLmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy51c2VUTFMpIHx8IHByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgY2RuID0gdGhpcy5vcHRpb25zLmNkbl9odHRwcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNkbiA9IHRoaXMub3B0aW9ucy5jZG5faHR0cDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2RuLnJlcGxhY2UoL1xcLyokLywgJycpICsgJy8nICsgdGhpcy5vcHRpb25zLnZlcnNpb247XG4gICAgfVxuICAgIGdldFBhdGgobmFtZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSb290KG9wdGlvbnMpICsgJy8nICsgbmFtZSArIHRoaXMub3B0aW9ucy5zdWZmaXggKyAnLmpzJztcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9kb20vZGVwZW5kZW5jaWVzLnRzXG5cblxuXG52YXIgRGVwZW5kZW5jaWVzUmVjZWl2ZXJzID0gbmV3IFNjcmlwdFJlY2VpdmVyRmFjdG9yeSgnX3B1c2hlcl9kZXBlbmRlbmNpZXMnLCAnUHVzaGVyLkRlcGVuZGVuY2llc1JlY2VpdmVycycpO1xudmFyIERlcGVuZGVuY2llcyA9IG5ldyBkZXBlbmRlbmN5X2xvYWRlcl9EZXBlbmRlbmN5TG9hZGVyKHtcbiAgICBjZG5faHR0cDogZGVmYXVsdHMuY2RuX2h0dHAsXG4gICAgY2RuX2h0dHBzOiBkZWZhdWx0cy5jZG5faHR0cHMsXG4gICAgdmVyc2lvbjogZGVmYXVsdHMuVkVSU0lPTixcbiAgICBzdWZmaXg6IGRlZmF1bHRzLmRlcGVuZGVuY3lfc3VmZml4LFxuICAgIHJlY2VpdmVyczogRGVwZW5kZW5jaWVzUmVjZWl2ZXJzLFxufSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdXJsX3N0b3JlLnRzXG5jb25zdCB1cmxTdG9yZSA9IHtcbiAgICBiYXNlVXJsOiAnaHR0cHM6Ly9wdXNoZXIuY29tJyxcbiAgICB1cmxzOiB7XG4gICAgICAgIGF1dGhlbnRpY2F0aW9uRW5kcG9pbnQ6IHtcbiAgICAgICAgICAgIHBhdGg6ICcvZG9jcy9jaGFubmVscy9zZXJ2ZXJfYXBpL2F1dGhlbnRpY2F0aW5nX3VzZXJzJyxcbiAgICAgICAgfSxcbiAgICAgICAgYXV0aG9yaXphdGlvbkVuZHBvaW50OiB7XG4gICAgICAgICAgICBwYXRoOiAnL2RvY3MvY2hhbm5lbHMvc2VydmVyX2FwaS9hdXRob3JpemluZy11c2Vycy8nLFxuICAgICAgICB9LFxuICAgICAgICBqYXZhc2NyaXB0UXVpY2tTdGFydDoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2phdmFzY3JpcHRfcXVpY2tfc3RhcnQnLFxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyaW5nQ2xpZW50RXZlbnRzOiB7XG4gICAgICAgICAgICBwYXRoOiAnL2RvY3MvY2xpZW50X2FwaV9ndWlkZS9jbGllbnRfZXZlbnRzI3RyaWdnZXItZXZlbnRzJyxcbiAgICAgICAgfSxcbiAgICAgICAgZW5jcnlwdGVkQ2hhbm5lbFN1cHBvcnQ6IHtcbiAgICAgICAgICAgIGZ1bGxVcmw6ICdodHRwczovL2dpdGh1Yi5jb20vcHVzaGVyL3B1c2hlci1qcy90cmVlL2NjNDkxMDE1MzcxYTRiZGU1NzQzZDFjODdhMGZiYWMwZmViNTMxOTUjZW5jcnlwdGVkLWNoYW5uZWwtc3VwcG9ydCcsXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG5jb25zdCBidWlsZExvZ1N1ZmZpeCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjb25zdCB1cmxQcmVmaXggPSAnU2VlOic7XG4gICAgY29uc3QgdXJsT2JqID0gdXJsU3RvcmUudXJsc1trZXldO1xuICAgIGlmICghdXJsT2JqKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgbGV0IHVybDtcbiAgICBpZiAodXJsT2JqLmZ1bGxVcmwpIHtcbiAgICAgICAgdXJsID0gdXJsT2JqLmZ1bGxVcmw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVybE9iai5wYXRoKSB7XG4gICAgICAgIHVybCA9IHVybFN0b3JlLmJhc2VVcmwgKyB1cmxPYmoucGF0aDtcbiAgICB9XG4gICAgaWYgKCF1cmwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4gYCR7dXJsUHJlZml4fSAke3VybH1gO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHVybF9zdG9yZSA9ICh7IGJ1aWxkTG9nU3VmZml4IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvb3B0aW9ucy50c1xudmFyIEF1dGhSZXF1ZXN0VHlwZTtcbihmdW5jdGlvbiAoQXV0aFJlcXVlc3RUeXBlKSB7XG4gICAgQXV0aFJlcXVlc3RUeXBlW1wiVXNlckF1dGhlbnRpY2F0aW9uXCJdID0gXCJ1c2VyLWF1dGhlbnRpY2F0aW9uXCI7XG4gICAgQXV0aFJlcXVlc3RUeXBlW1wiQ2hhbm5lbEF1dGhvcml6YXRpb25cIl0gPSBcImNoYW5uZWwtYXV0aG9yaXphdGlvblwiO1xufSkoQXV0aFJlcXVlc3RUeXBlIHx8IChBdXRoUmVxdWVzdFR5cGUgPSB7fSkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Vycm9ycy50c1xuY2xhc3MgQmFkRXZlbnROYW1lIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIEJhZENoYW5uZWxOYW1lIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFJlcXVlc3RUaW1lZE91dCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBUcmFuc3BvcnRQcmlvcml0eVRvb0xvdyBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5jbGFzcyBUcmFuc3BvcnRDbG9zZWQgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgVW5zdXBwb3J0ZWRGZWF0dXJlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFVuc3VwcG9ydGVkVHJhbnNwb3J0IGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmNsYXNzIFVuc3VwcG9ydGVkU3RyYXRlZ3kgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuY2xhc3MgSFRUUEF1dGhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXMsIG1zZykge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL2lzb21vcnBoaWMvYXV0aC94aHJfYXV0aC50c1xuXG5cblxuXG5jb25zdCBhamF4ID0gZnVuY3Rpb24gKGNvbnRleHQsIHF1ZXJ5LCBhdXRoT3B0aW9ucywgYXV0aFJlcXVlc3RUeXBlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHhociA9IHJ1bnRpbWUuY3JlYXRlWEhSKCk7XG4gICAgeGhyLm9wZW4oJ1BPU1QnLCBhdXRoT3B0aW9ucy5lbmRwb2ludCwgdHJ1ZSk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICBmb3IgKHZhciBoZWFkZXJOYW1lIGluIGF1dGhPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgYXV0aE9wdGlvbnMuaGVhZGVyc1toZWFkZXJOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZHluYW1pY0hlYWRlcnMgPSBhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIoKTtcbiAgICAgICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBkeW5hbWljSGVhZGVycykge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgZHluYW1pY0hlYWRlcnNbaGVhZGVyTmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEhUVFBBdXRoRXJyb3IoMjAwLCBgSlNPTiByZXR1cm5lZCBmcm9tICR7YXV0aFJlcXVlc3RUeXBlLnRvU3RyaW5nKCl9IGVuZHBvaW50IHdhcyBpbnZhbGlkLCB5ZXQgc3RhdHVzIGNvZGUgd2FzIDIwMC4gRGF0YSB3YXM6ICR7eGhyLnJlc3BvbnNlVGV4dH1gKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXV0aFJlcXVlc3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0aFJlcXVlc3RUeXBlLlVzZXJBdXRoZW50aWNhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnYXV0aGVudGljYXRpb25FbmRwb2ludCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0aFJlcXVlc3RUeXBlLkNoYW5uZWxBdXRob3JpemF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gYENsaWVudHMgbXVzdCBiZSBhdXRob3JpemVkIHRvIGpvaW4gcHJpdmF0ZSBvciBwcmVzZW5jZSBjaGFubmVscy4gJHt1cmxfc3RvcmUuYnVpbGRMb2dTdWZmaXgoJ2F1dGhvcml6YXRpb25FbmRwb2ludCcpfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEhUVFBBdXRoRXJyb3IoeGhyLnN0YXR1cywgYFVuYWJsZSB0byByZXRyaWV2ZSBhdXRoIHN0cmluZyBmcm9tICR7YXV0aFJlcXVlc3RUeXBlLnRvU3RyaW5nKCl9IGVuZHBvaW50IC0gYCArXG4gICAgICAgICAgICAgICAgICAgIGByZWNlaXZlZCBzdGF0dXM6ICR7eGhyLnN0YXR1c30gZnJvbSAke2F1dGhPcHRpb25zLmVuZHBvaW50fS4gJHtzdWZmaXh9YCksIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB4aHIuc2VuZChxdWVyeSk7XG4gICAgcmV0dXJuIHhocjtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJfYXV0aCA9IChhamF4KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9iYXNlNjQudHNcbmZ1bmN0aW9uIGVuY29kZShzKSB7XG4gICAgcmV0dXJuIGJ0b2EodXRvYihzKSk7XG59XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciBiNjRjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbnZhciBiNjR0YWIgPSB7fTtcbmZvciAodmFyIGJhc2U2NF9pID0gMCwgbCA9IGI2NGNoYXJzLmxlbmd0aDsgYmFzZTY0X2kgPCBsOyBiYXNlNjRfaSsrKSB7XG4gICAgYjY0dGFiW2I2NGNoYXJzLmNoYXJBdChiYXNlNjRfaSldID0gYmFzZTY0X2k7XG59XG52YXIgY2JfdXRvYiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBjYyA8IDB4ODBcbiAgICAgICAgPyBjXG4gICAgICAgIDogY2MgPCAweDgwMFxuICAgICAgICAgICAgPyBmcm9tQ2hhckNvZGUoMHhjMCB8IChjYyA+Pj4gNikpICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSlcbiAgICAgICAgICAgIDogZnJvbUNoYXJDb2RlKDB4ZTAgfCAoKGNjID4+PiAxMikgJiAweDBmKSkgK1xuICAgICAgICAgICAgICAgIGZyb21DaGFyQ29kZSgweDgwIHwgKChjYyA+Pj4gNikgJiAweDNmKSkgK1xuICAgICAgICAgICAgICAgIGZyb21DaGFyQ29kZSgweDgwIHwgKGNjICYgMHgzZikpO1xufTtcbnZhciB1dG9iID0gZnVuY3Rpb24gKHUpIHtcbiAgICByZXR1cm4gdS5yZXBsYWNlKC9bXlxceDAwLVxceDdGXS9nLCBjYl91dG9iKTtcbn07XG52YXIgY2JfZW5jb2RlID0gZnVuY3Rpb24gKGNjYykge1xuICAgIHZhciBwYWRsZW4gPSBbMCwgMiwgMV1bY2NjLmxlbmd0aCAlIDNdO1xuICAgIHZhciBvcmQgPSAoY2NjLmNoYXJDb2RlQXQoMCkgPDwgMTYpIHxcbiAgICAgICAgKChjY2MubGVuZ3RoID4gMSA/IGNjYy5jaGFyQ29kZUF0KDEpIDogMCkgPDwgOCkgfFxuICAgICAgICAoY2NjLmxlbmd0aCA+IDIgPyBjY2MuY2hhckNvZGVBdCgyKSA6IDApO1xuICAgIHZhciBjaGFycyA9IFtcbiAgICAgICAgYjY0Y2hhcnMuY2hhckF0KG9yZCA+Pj4gMTgpLFxuICAgICAgICBiNjRjaGFycy5jaGFyQXQoKG9yZCA+Pj4gMTIpICYgNjMpLFxuICAgICAgICBwYWRsZW4gPj0gMiA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiA2KSAmIDYzKSxcbiAgICAgICAgcGFkbGVuID49IDEgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQob3JkICYgNjMpLFxuICAgIF07XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xufTtcbnZhciBidG9hID0gd2luZG93LmJ0b2EgfHxcbiAgICBmdW5jdGlvbiAoYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKC9bXFxzXFxTXXsxLDN9L2csIGNiX2VuY29kZSk7XG4gICAgfTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy90aW1lcnMvYWJzdHJhY3RfdGltZXIudHNcbmNsYXNzIFRpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQsIGNsZWFyLCBkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jbGVhciA9IGNsZWFyO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IGNhbGxiYWNrKHRoaXMudGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBkZWxheSk7XG4gICAgfVxuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXIgIT09IG51bGw7XG4gICAgfVxuICAgIGVuc3VyZUFib3J0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhYnN0cmFjdF90aW1lciA9IChUaW1lcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdGltZXJzL2luZGV4LnRzXG5cbmZ1bmN0aW9uIHRpbWVyc19jbGVhclRpbWVvdXQodGltZXIpIHtcbiAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVyKTtcbn1cbmZ1bmN0aW9uIHRpbWVyc19jbGVhckludGVydmFsKHRpbWVyKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZXIpO1xufVxuY2xhc3MgdGltZXJzX09uZU9mZlRpbWVyIGV4dGVuZHMgYWJzdHJhY3RfdGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcihzZXRUaW1lb3V0LCB0aW1lcnNfY2xlYXJUaW1lb3V0LCBkZWxheSwgZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIHRpbWVyc19QZXJpb2RpY1RpbWVyIGV4dGVuZHMgYWJzdHJhY3RfdGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcihzZXRJbnRlcnZhbCwgdGltZXJzX2NsZWFySW50ZXJ2YWwsIGRlbGF5LCBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gdGltZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlsLnRzXG5cbnZhciBVdGlsID0ge1xuICAgIG5vdygpIHtcbiAgICAgICAgaWYgKERhdGUubm93KSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVmZXIoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aW1lcnNfT25lT2ZmVGltZXIoMCwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgbWV0aG9kKG5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgdmFyIGJvdW5kQXJndW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbbmFtZV0uYXBwbHkob2JqZWN0LCBib3VuZEFyZ3VtZW50cy5jb25jYXQoYXJndW1lbnRzKSk7XG4gICAgICAgIH07XG4gICAgfSxcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsID0gKFV0aWwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3V0aWxzL2NvbGxlY3Rpb25zLnRzXG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgLi4uc291cmNlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zW3Byb3BlcnR5XSAmJlxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNbcHJvcGVydHldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1twcm9wZXJ0eV0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBleHRlbmQodGFyZ2V0W3Byb3BlcnR5XSB8fCB7fSwgZXh0ZW5zaW9uc1twcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGV4dGVuc2lvbnNbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgdmFyIG0gPSBbJ1B1c2hlciddO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbS5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtLnB1c2goc2FmZUpTT05TdHJpbmdpZnkoYXJndW1lbnRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uam9pbignIDogJyk7XG59XG5mdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyYXksIGl0ZW0pIHtcbiAgICB2YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIGlmIChhcnJheSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gb2JqZWN0QXBwbHkob2JqZWN0LCBmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgZihvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBhcHBseShhcnJheSwgZiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZi5jYWxsKGNvbnRleHQgfHwgd2luZG93LCBhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGYoYXJyYXlbaV0sIGksIGFycmF5LCByZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGYpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGYodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXIoYXJyYXksIHRlc3QpIHtcbiAgICB0ZXN0ID1cbiAgICAgICAgdGVzdCB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXN0KGFycmF5W2ldLCBpLCBhcnJheSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXJPYmplY3Qob2JqZWN0LCB0ZXN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKCh0ZXN0ICYmIHRlc3QodmFsdWUsIGtleSwgb2JqZWN0LCByZXN1bHQpKSB8fCBCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmbGF0dGVuKG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBvYmplY3RBcHBseShvYmplY3QsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFueShhcnJheSwgdGVzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdGlvbnNfYWxsKGFycmF5LCB0ZXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5jb2RlUGFyYW1zT2JqZWN0KGRhdGEpIHtcbiAgICByZXR1cm4gbWFwT2JqZWN0KGRhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSBzYWZlSlNPTlN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlbmNvZGUodmFsdWUudG9TdHJpbmcoKSkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRRdWVyeVN0cmluZyhkYXRhKSB7XG4gICAgdmFyIHBhcmFtcyA9IGZpbHRlck9iamVjdChkYXRhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgdmFyIHF1ZXJ5ID0gbWFwKGZsYXR0ZW4oZW5jb2RlUGFyYW1zT2JqZWN0KHBhcmFtcykpLCB1dGlsLm1ldGhvZCgnam9pbicsICc9JykpLmpvaW4oJyYnKTtcbiAgICByZXR1cm4gcXVlcnk7XG59XG5mdW5jdGlvbiBkZWN5Y2xlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBvYmplY3RzID0gW10sIHBhdGhzID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBkZXJleih2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgaSwgbmFtZSwgbnU7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgJHJlZjogcGF0aHNbaV0gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICAgIG51ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVbaV0gPSBkZXJleih2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBudSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVbbmFtZV0gPSBkZXJleih2YWx1ZVtuYW1lXSwgcGF0aCArICdbJyArIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnU7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pKG9iamVjdCwgJyQnKTtcbn1cbmZ1bmN0aW9uIHNhZmVKU09OU3RyaW5naWZ5KHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3VyY2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGVjeWNsZU9iamVjdChzb3VyY2UpKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvbG9nZ2VyLnRzXG5cblxuY2xhc3MgbG9nZ2VyX0xvZ2dlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsTG9nID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5sb2codGhpcy5nbG9iYWxMb2csIGFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5sb2codGhpcy5nbG9iYWxMb2dXYXJuLCBhcmdzKTtcbiAgICB9XG4gICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICB0aGlzLmxvZyh0aGlzLmdsb2JhbExvZ0Vycm9yLCBhcmdzKTtcbiAgICB9XG4gICAgZ2xvYmFsTG9nV2FybihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2xvYmFsTG9nRXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dXYXJuKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZyhkZWZhdWx0TG9nZ2luZ0Z1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gc3RyaW5naWZ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChjb3JlX3B1c2hlci5sb2cpIHtcbiAgICAgICAgICAgIGNvcmVfcHVzaGVyLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JlX3B1c2hlci5sb2dUb0NvbnNvbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvZyA9IGRlZmF1bHRMb2dnaW5nRnVuY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxvZ2dlciA9IChuZXcgbG9nZ2VyX0xvZ2dlcigpKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL2F1dGgvanNvbnBfYXV0aC50c1xuXG52YXIganNvbnAgPSBmdW5jdGlvbiAoY29udGV4dCwgcXVlcnksIGF1dGhPcHRpb25zLCBhdXRoUmVxdWVzdFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGF1dGhPcHRpb25zLmhlYWRlcnMgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICBsb2dnZXIud2FybihgVG8gc2VuZCBoZWFkZXJzIHdpdGggdGhlICR7YXV0aFJlcXVlc3RUeXBlLnRvU3RyaW5nKCl9IHJlcXVlc3QsIHlvdSBtdXN0IHVzZSBBSkFYLCByYXRoZXIgdGhhbiBKU09OUC5gKTtcbiAgICB9XG4gICAgdmFyIGNhbGxiYWNrTmFtZSA9IGNvbnRleHQubmV4dEF1dGhDYWxsYmFja0lELnRvU3RyaW5nKCk7XG4gICAgY29udGV4dC5uZXh0QXV0aENhbGxiYWNrSUQrKztcbiAgICB2YXIgZG9jdW1lbnQgPSBjb250ZXh0LmdldERvY3VtZW50KCk7XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIGNvbnRleHQuYXV0aF9jYWxsYmFja3NbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH07XG4gICAgdmFyIGNhbGxiYWNrX25hbWUgPSBcIlB1c2hlci5hdXRoX2NhbGxiYWNrc1snXCIgKyBjYWxsYmFja05hbWUgKyBcIiddXCI7XG4gICAgc2NyaXB0LnNyYyA9XG4gICAgICAgIGF1dGhPcHRpb25zLmVuZHBvaW50ICtcbiAgICAgICAgICAgICc/Y2FsbGJhY2s9JyArXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoY2FsbGJhY2tfbmFtZSkgK1xuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgIHF1ZXJ5O1xuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGpzb25wX2F1dGggPSAoanNvbnApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZG9tL3NjcmlwdF9yZXF1ZXN0LnRzXG5jbGFzcyBTY3JpcHRSZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3RvcihzcmMpIHtcbiAgICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgfVxuICAgIHNlbmQocmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSAnRXJyb3IgbG9hZGluZyAnICsgc2VsZi5zcmM7XG4gICAgICAgIHNlbGYuc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNlbGYuc2NyaXB0LmlkID0gcmVjZWl2ZXIuaWQ7XG4gICAgICAgIHNlbGYuc2NyaXB0LnNyYyA9IHNlbGYuc3JjO1xuICAgICAgICBzZWxmLnNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNlbGYuc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICAgICAgICBpZiAoc2VsZi5zY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgc2VsZi5zY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5jYWxsYmFjayhlcnJvclN0cmluZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5zY3JpcHQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLmNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zY3JpcHQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRlZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JpcHQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlci5jYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnNjcmlwdC5hc3luYyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCAmJlxuICAgICAgICAgICAgL29wZXJhL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgc2VsZi5lcnJvclNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgc2VsZi5lcnJvclNjcmlwdC5pZCA9IHJlY2VpdmVyLmlkICsgJ19lcnJvcic7XG4gICAgICAgICAgICBzZWxmLmVycm9yU2NyaXB0LnRleHQgPSByZWNlaXZlci5uYW1lICsgXCIoJ1wiICsgZXJyb3JTdHJpbmcgKyBcIicpO1wiO1xuICAgICAgICAgICAgc2VsZi5zY3JpcHQuYXN5bmMgPSBzZWxmLmVycm9yU2NyaXB0LmFzeW5jID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzZWxmLnNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgICAgICAgaWYgKHNlbGYuZXJyb3JTY3JpcHQpIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNlbGYuZXJyb3JTY3JpcHQsIHNlbGYuc2NyaXB0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0Lm9ubG9hZCA9IHRoaXMuc2NyaXB0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY3JpcHQgJiYgdGhpcy5zY3JpcHQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXJyb3JTY3JpcHQgJiYgdGhpcy5lcnJvclNjcmlwdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yU2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lcnJvclNjcmlwdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yU2NyaXB0ID0gbnVsbDtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9kb20vanNvbnBfcmVxdWVzdC50c1xuXG5cbmNsYXNzIGpzb25wX3JlcXVlc3RfSlNPTlBSZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGRhdGEpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHNlbmQocmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcodGhpcy5kYXRhKTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMudXJsICsgJy8nICsgcmVjZWl2ZXIubnVtYmVyICsgJz8nICsgcXVlcnk7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJ1bnRpbWUuY3JlYXRlU2NyaXB0UmVxdWVzdCh1cmwpO1xuICAgICAgICB0aGlzLnJlcXVlc3Quc2VuZChyZWNlaXZlcik7XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5jbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi90aW1lbGluZS9qc29ucF90aW1lbGluZS50c1xuXG5cbnZhciBnZXRBZ2VudCA9IGZ1bmN0aW9uIChzZW5kZXIsIHVzZVRMUykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICdodHRwJyArICh1c2VUTFMgPyAncycgOiAnJykgKyAnOi8vJztcbiAgICAgICAgdmFyIHVybCA9IHNjaGVtZSArIChzZW5kZXIuaG9zdCB8fCBzZW5kZXIub3B0aW9ucy5ob3N0KSArIHNlbmRlci5vcHRpb25zLnBhdGg7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gcnVudGltZS5jcmVhdGVKU09OUFJlcXVlc3QodXJsLCBkYXRhKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcnVudGltZS5TY3JpcHRSZWNlaXZlcnMuY3JlYXRlKGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBTY3JpcHRSZWNlaXZlcnMucmVtb3ZlKHJlY2VpdmVyKTtcbiAgICAgICAgICAgIHJlcXVlc3QuY2xlYW51cCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuaG9zdCkge1xuICAgICAgICAgICAgICAgIHNlbmRlci5ob3N0ID0gcmVzdWx0Lmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3Quc2VuZChyZWNlaXZlcik7XG4gICAgfTtcbn07XG52YXIganNvbnBfdGltZWxpbmVfanNvbnAgPSB7XG4gICAgbmFtZTogJ2pzb25wJyxcbiAgICBnZXRBZ2VudCxcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBqc29ucF90aW1lbGluZSA9IChqc29ucF90aW1lbGluZV9qc29ucCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy91cmxfc2NoZW1lcy50c1xuXG5mdW5jdGlvbiBnZXRHZW5lcmljVVJMKGJhc2VTY2hlbWUsIHBhcmFtcywgcGF0aCkge1xuICAgIHZhciBzY2hlbWUgPSBiYXNlU2NoZW1lICsgKHBhcmFtcy51c2VUTFMgPyAncycgOiAnJyk7XG4gICAgdmFyIGhvc3QgPSBwYXJhbXMudXNlVExTID8gcGFyYW1zLmhvc3RUTFMgOiBwYXJhbXMuaG9zdE5vblRMUztcbiAgICByZXR1cm4gc2NoZW1lICsgJzovLycgKyBob3N0ICsgcGF0aDtcbn1cbmZ1bmN0aW9uIGdldEdlbmVyaWNQYXRoKGtleSwgcXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcGF0aCA9ICcvYXBwLycgKyBrZXk7XG4gICAgdmFyIHF1ZXJ5ID0gJz9wcm90b2NvbD0nICtcbiAgICAgICAgZGVmYXVsdHMuUFJPVE9DT0wgK1xuICAgICAgICAnJmNsaWVudD1qcycgK1xuICAgICAgICAnJnZlcnNpb249JyArXG4gICAgICAgIGRlZmF1bHRzLlZFUlNJT04gK1xuICAgICAgICAocXVlcnlTdHJpbmcgPyAnJicgKyBxdWVyeVN0cmluZyA6ICcnKTtcbiAgICByZXR1cm4gcGF0aCArIHF1ZXJ5O1xufVxudmFyIHdzID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICB2YXIgcGF0aCA9IChwYXJhbXMuaHR0cFBhdGggfHwgJycpICsgZ2V0R2VuZXJpY1BhdGgoa2V5LCAnZmxhc2g9ZmFsc2UnKTtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ3dzJywgcGFyYW1zLCBwYXRoKTtcbiAgICB9LFxufTtcbnZhciBodHRwID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICB2YXIgcGF0aCA9IChwYXJhbXMuaHR0cFBhdGggfHwgJy9wdXNoZXInKSArIGdldEdlbmVyaWNQYXRoKGtleSk7XG4gICAgICAgIHJldHVybiBnZXRHZW5lcmljVVJMKCdodHRwJywgcGFyYW1zLCBwYXRoKTtcbiAgICB9LFxufTtcbnZhciBzb2NranMgPSB7XG4gICAgZ2V0SW5pdGlhbDogZnVuY3Rpb24gKGtleSwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBnZXRHZW5lcmljVVJMKCdodHRwJywgcGFyYW1zLCBwYXJhbXMuaHR0cFBhdGggfHwgJy9wdXNoZXInKTtcbiAgICB9LFxuICAgIGdldFBhdGg6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gZ2V0R2VuZXJpY1BhdGgoa2V5KTtcbiAgICB9LFxufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9ldmVudHMvY2FsbGJhY2tfcmVnaXN0cnkudHNcblxuY2xhc3MgY2FsbGJhY2tfcmVnaXN0cnlfQ2FsbGJhY2tSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW3ByZWZpeChuYW1lKV07XG4gICAgfVxuICAgIGFkZChuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgcHJlZml4ZWRFdmVudE5hbWUgPSBwcmVmaXgobmFtZSk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrc1twcmVmaXhlZEV2ZW50TmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW3ByZWZpeGVkRXZlbnROYW1lXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzW3ByZWZpeGVkRXZlbnROYW1lXS5wdXNoKHtcbiAgICAgICAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmUobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWVzID0gbmFtZSA/IFtwcmVmaXgobmFtZSldIDoga2V5cyh0aGlzLl9jYWxsYmFja3MpO1xuICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDYWxsYmFjayhuYW1lcywgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxDYWxsYmFja3MobmFtZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNhbGxiYWNrKG5hbWVzLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICBhcHBseShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1tuYW1lXSA9IGZpbHRlcih0aGlzLl9jYWxsYmFja3NbbmFtZV0gfHwgW10sIGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGJpbmRpbmcuZm4pIHx8XG4gICAgICAgICAgICAgICAgICAgIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGJpbmRpbmcuY29udGV4dCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICByZW1vdmVBbGxDYWxsYmFja3MobmFtZXMpIHtcbiAgICAgICAgYXBwbHkobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW25hbWVdO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVmaXgobmFtZSkge1xuICAgIHJldHVybiAnXycgKyBuYW1lO1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2V2ZW50cy9kaXNwYXRjaGVyLnRzXG5cblxuY2xhc3MgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihmYWlsVGhyb3VnaCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBjYWxsYmFja19yZWdpc3RyeV9DYWxsYmFja1JlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmZhaWxUaHJvdWdoID0gZmFpbFRocm91Z2g7XG4gICAgfVxuICAgIGJpbmQoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5hZGQoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBiaW5kX2dsb2JhbChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmQoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5yZW1vdmUoZXZlbnROYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB1bmJpbmRfZ2xvYmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gZmlsdGVyKHRoaXMuZ2xvYmFsX2NhbGxiYWNrcyB8fCBbXSwgKGMpID0+IGMgIT09IGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9hbGwoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgIHRoaXMudW5iaW5kX2dsb2JhbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIGRhdGEsIG1ldGFkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbG9iYWxfY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3NbaV0oZXZlbnROYW1lLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MuZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGRhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrcyAmJiBjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uZm4uYXBwbHkoY2FsbGJhY2tzW2ldLmNvbnRleHQgfHwgd2luZG93LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZhaWxUaHJvdWdoKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWxUaHJvdWdoKGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RyYW5zcG9ydHMvdHJhbnNwb3J0X2Nvbm5lY3Rpb24udHNcblxuXG5cblxuXG5jbGFzcyB0cmFuc3BvcnRfY29ubmVjdGlvbl9UcmFuc3BvcnRDb25uZWN0aW9uIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihob29rcywgbmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUgPSBydW50aW1lLnRyYW5zcG9ydENvbm5lY3Rpb25Jbml0aWFsaXplcjtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ25ldyc7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSBvcHRpb25zLnRpbWVsaW5lO1xuICAgICAgICB0aGlzLmFjdGl2aXR5VGltZW91dCA9IG9wdGlvbnMuYWN0aXZpdHlUaW1lb3V0O1xuICAgICAgICB0aGlzLmlkID0gdGhpcy50aW1lbGluZS5nZW5lcmF0ZVVuaXF1ZUlEKCk7XG4gICAgfVxuICAgIGhhbmRsZXNBY3Rpdml0eUNoZWNrcygpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5ob29rcy5oYW5kbGVzQWN0aXZpdHlDaGVja3MpO1xuICAgIH1cbiAgICBzdXBwb3J0c1BpbmcoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuaG9va3Muc3VwcG9ydHNQaW5nKTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0IHx8IHRoaXMuc3RhdGUgIT09ICdpbml0aWFsaXplZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJsID0gdGhpcy5ob29rcy51cmxzLmdldEluaXRpYWwodGhpcy5rZXksIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldCA9IHRoaXMuaG9va3MuZ2V0U29ja2V0KHVybCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdXRpbC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnQ29ubmVjdGluZycsIHsgdHJhbnNwb3J0OiB0aGlzLm5hbWUsIHVybCB9KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnY29ubmVjdGluZycpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmQoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgICB1dGlsLmRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnb3BlbicgJiYgdGhpcy5zdXBwb3J0c1BpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQucGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9va3MuYmVmb3JlT3Blbikge1xuICAgICAgICAgICAgdGhpcy5ob29rcy5iZWZvcmVPcGVuKHRoaXMuc29ja2V0LCB0aGlzLmhvb2tzLnVybHMuZ2V0UGF0aCh0aGlzLmtleSwgdGhpcy5vcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnb3BlbicpO1xuICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHsgdHlwZTogJ1dlYlNvY2tldEVycm9yJywgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmVycm9yKHRoaXMuYnVpbGRUaW1lbGluZU1lc3NhZ2UoeyBlcnJvcjogZXJyb3IudG9TdHJpbmcoKSB9KSk7XG4gICAgfVxuICAgIG9uQ2xvc2UoY2xvc2VFdmVudCkge1xuICAgICAgICBpZiAoY2xvc2VFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnY2xvc2VkJywge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNsb3NlRXZlbnQuY29kZSxcbiAgICAgICAgICAgICAgICByZWFzb246IGNsb3NlRXZlbnQucmVhc29uLFxuICAgICAgICAgICAgICAgIHdhc0NsZWFuOiBjbG9zZUV2ZW50Lndhc0NsZWFuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgfVxuICAgIG9uQWN0aXZpdHkoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnYWN0aXZpdHknKTtcbiAgICB9XG4gICAgYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IChjbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoY2xvc2VFdmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uYWN0aXZpdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQub25hY3Rpdml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShzdGF0ZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHRoaXMuYnVpbGRUaW1lbGluZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5lbWl0KHN0YXRlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBidWlsZFRpbWVsaW5lTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoeyBjaWQ6IHRoaXMuaWQgfSwgbWVzc2FnZSk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RyYW5zcG9ydHMvdHJhbnNwb3J0LnRzXG5cbmNsYXNzIHRyYW5zcG9ydF9UcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKGhvb2tzKSB7XG4gICAgICAgIHRoaXMuaG9va3MgPSBob29rcztcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9va3MuaXNTdXBwb3J0ZWQoZW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICBjcmVhdGVDb25uZWN0aW9uKG5hbWUsIHByaW9yaXR5LCBrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRfY29ubmVjdGlvbl9UcmFuc3BvcnRDb25uZWN0aW9uKHRoaXMuaG9va3MsIG5hbWUsIHByaW9yaXR5LCBrZXksIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy90cmFuc3BvcnRzL3RyYW5zcG9ydHMudHNcblxuXG5cblxudmFyIFdTVHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydF9UcmFuc3BvcnQoe1xuICAgIHVybHM6IHdzLFxuICAgIGhhbmRsZXNBY3Rpdml0eUNoZWNrczogZmFsc2UsXG4gICAgc3VwcG9ydHNQaW5nOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHJ1bnRpbWUuZ2V0V2ViU29ja2V0QVBJKCkpO1xuICAgIH0sXG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocnVudGltZS5nZXRXZWJTb2NrZXRBUEkoKSk7XG4gICAgfSxcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHJ1bnRpbWUuY3JlYXRlV2ViU29ja2V0KHVybCk7XG4gICAgfSxcbn0pO1xudmFyIGh0dHBDb25maWd1cmF0aW9uID0ge1xuICAgIHVybHM6IGh0dHAsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiBmYWxzZSxcbiAgICBzdXBwb3J0c1Bpbmc6IHRydWUsXG4gICAgaXNJbml0aWFsaXplZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcbnZhciBzdHJlYW1pbmdDb25maWd1cmF0aW9uID0gZXh0ZW5kKHtcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHJ1bnRpbWUuSFRUUEZhY3RvcnkuY3JlYXRlU3RyZWFtaW5nU29ja2V0KHVybCk7XG4gICAgfSxcbn0sIGh0dHBDb25maWd1cmF0aW9uKTtcbnZhciBwb2xsaW5nQ29uZmlndXJhdGlvbiA9IGV4dGVuZCh7XG4gICAgZ2V0U29ja2V0OiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBydW50aW1lLkhUVFBGYWN0b3J5LmNyZWF0ZVBvbGxpbmdTb2NrZXQodXJsKTtcbiAgICB9LFxufSwgaHR0cENvbmZpZ3VyYXRpb24pO1xudmFyIHhockNvbmZpZ3VyYXRpb24gPSB7XG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJ1bnRpbWUuaXNYSFJTdXBwb3J0ZWQoKTtcbiAgICB9LFxufTtcbnZhciBYSFJTdHJlYW1pbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCgoZXh0ZW5kKHt9LCBzdHJlYW1pbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSkpO1xudmFyIFhIUlBvbGxpbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0X1RyYW5zcG9ydCgoZXh0ZW5kKHt9LCBwb2xsaW5nQ29uZmlndXJhdGlvbiwgeGhyQ29uZmlndXJhdGlvbikpKTtcbnZhciBUcmFuc3BvcnRzID0ge1xuICAgIHdzOiBXU1RyYW5zcG9ydCxcbiAgICB4aHJfc3RyZWFtaW5nOiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQsXG4gICAgeGhyX3BvbGxpbmc6IFhIUlBvbGxpbmdUcmFuc3BvcnQsXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0cyA9IChUcmFuc3BvcnRzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL3RyYW5zcG9ydHMvdHJhbnNwb3J0cy50c1xuXG5cblxuXG5cblxudmFyIFNvY2tKU1RyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRfVHJhbnNwb3J0KHtcbiAgICBmaWxlOiAnc29ja2pzJyxcbiAgICB1cmxzOiBzb2NranMsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiB0cnVlLFxuICAgIHN1cHBvcnRzUGluZzogZmFsc2UsXG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBpc0luaXRpYWxpemVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuU29ja0pTICE9PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBnZXRTb2NrZXQ6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuU29ja0pTKHVybCwgbnVsbCwge1xuICAgICAgICAgICAganNfcGF0aDogRGVwZW5kZW5jaWVzLmdldFBhdGgoJ3NvY2tqcycsIHtcbiAgICAgICAgICAgICAgICB1c2VUTFM6IG9wdGlvbnMudXNlVExTLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpZ25vcmVfbnVsbF9vcmlnaW46IG9wdGlvbnMuaWdub3JlTnVsbE9yaWdpbixcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBiZWZvcmVPcGVuOiBmdW5jdGlvbiAoc29ja2V0LCBwYXRoKSB7XG4gICAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIH0pKTtcbiAgICB9LFxufSk7XG52YXIgeGRyQ29uZmlndXJhdGlvbiA9IHtcbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAgIHZhciB5ZXMgPSBydW50aW1lLmlzWERSU3VwcG9ydGVkKGVudmlyb25tZW50LnVzZVRMUyk7XG4gICAgICAgIHJldHVybiB5ZXM7XG4gICAgfSxcbn07XG52YXIgWERSU3RyZWFtaW5nVHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydF9UcmFuc3BvcnQoKGV4dGVuZCh7fSwgc3RyZWFtaW5nQ29uZmlndXJhdGlvbiwgeGRyQ29uZmlndXJhdGlvbikpKTtcbnZhciBYRFJQb2xsaW5nVHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydF9UcmFuc3BvcnQoKGV4dGVuZCh7fSwgcG9sbGluZ0NvbmZpZ3VyYXRpb24sIHhkckNvbmZpZ3VyYXRpb24pKSk7XG50cmFuc3BvcnRzLnhkcl9zdHJlYW1pbmcgPSBYRFJTdHJlYW1pbmdUcmFuc3BvcnQ7XG50cmFuc3BvcnRzLnhkcl9wb2xsaW5nID0gWERSUG9sbGluZ1RyYW5zcG9ydDtcbnRyYW5zcG9ydHMuc29ja2pzID0gU29ja0pTVHJhbnNwb3J0O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0c190cmFuc3BvcnRzID0gKHRyYW5zcG9ydHMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvbmV0X2luZm8udHNcblxuY2xhc3MgbmV0X2luZm9fTmV0SW5mbyBleHRlbmRzIGRpc3BhdGNoZXJfRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdvbmxpbmUnKTtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgnb2ZmbGluZScpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzT25saW5lKCkge1xuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5vbkxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5vbkxpbmU7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgbmV0X2luZm9fTmV0d29yayA9IG5ldyBuZXRfaW5mb19OZXRJbmZvKCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy9hc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyLnRzXG5cblxuY2xhc3MgYXNzaXN0YW50X3RvX3RoZV90cmFuc3BvcnRfbWFuYWdlcl9Bc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHRyYW5zcG9ydCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5taW5QaW5nRGVsYXkgPSBvcHRpb25zLm1pblBpbmdEZWxheTtcbiAgICAgICAgdGhpcy5tYXhQaW5nRGVsYXkgPSBvcHRpb25zLm1heFBpbmdEZWxheTtcbiAgICAgICAgdGhpcy5waW5nRGVsYXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNyZWF0ZUNvbm5lY3Rpb24obmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IHRoaXMucGluZ0RlbGF5LFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLnRyYW5zcG9ydC5jcmVhdGVDb25uZWN0aW9uKG5hbWUsIHByaW9yaXR5LCBrZXksIG9wdGlvbnMpO1xuICAgICAgICB2YXIgb3BlblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHZhciBvbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnVuYmluZCgnb3BlbicsIG9uT3Blbik7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmJpbmQoJ2Nsb3NlZCcsIG9uQ2xvc2VkKTtcbiAgICAgICAgICAgIG9wZW5UaW1lc3RhbXAgPSB1dGlsLm5vdygpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25DbG9zZWQgPSAoY2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51bmJpbmQoJ2Nsb3NlZCcsIG9uQ2xvc2VkKTtcbiAgICAgICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgPT09IDEwMDIgfHwgY2xvc2VFdmVudC5jb2RlID09PSAxMDAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLnJlcG9ydERlYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY2xvc2VFdmVudC53YXNDbGVhbiAmJiBvcGVuVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpZmVzcGFuID0gdXRpbC5ub3coKSAtIG9wZW5UaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgaWYgKGxpZmVzcGFuIDwgMiAqIHRoaXMubWF4UGluZ0RlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5yZXBvcnREZWF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBpbmdEZWxheSA9IE1hdGgubWF4KGxpZmVzcGFuIC8gMiwgdGhpcy5taW5QaW5nRGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29ubmVjdGlvbi5iaW5kKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKGVudmlyb25tZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuaXNBbGl2ZSgpICYmIHRoaXMudHJhbnNwb3J0LmlzU3VwcG9ydGVkKGVudmlyb25tZW50KTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9wcm90b2NvbC9wcm90b2NvbC50c1xuY29uc3QgUHJvdG9jb2wgPSB7XG4gICAgZGVjb2RlTWVzc2FnZTogZnVuY3Rpb24gKG1lc3NhZ2VFdmVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VEYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlRXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB2YXIgcHVzaGVyRXZlbnREYXRhID0gbWVzc2FnZURhdGEuZGF0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHVzaGVyRXZlbnREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hlckV2ZW50RGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZURhdGEuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwdXNoZXJFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogbWVzc2FnZURhdGEuZXZlbnQsXG4gICAgICAgICAgICAgICAgY2hhbm5lbDogbWVzc2FnZURhdGEuY2hhbm5lbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBwdXNoZXJFdmVudERhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VEYXRhLnVzZXJfaWQpIHtcbiAgICAgICAgICAgICAgICBwdXNoZXJFdmVudC51c2VyX2lkID0gbWVzc2FnZURhdGEudXNlcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdXNoZXJFdmVudDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnTWVzc2FnZVBhcnNlRXJyb3InLCBlcnJvcjogZSwgZGF0YTogbWVzc2FnZUV2ZW50LmRhdGEgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZW5jb2RlTWVzc2FnZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShldmVudCk7XG4gICAgfSxcbiAgICBwcm9jZXNzSGFuZHNoYWtlOiBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gUHJvdG9jb2wuZGVjb2RlTWVzc2FnZShtZXNzYWdlRXZlbnQpO1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudCA9PT0gJ3B1c2hlcjpjb25uZWN0aW9uX2VzdGFibGlzaGVkJykge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmRhdGEuYWN0aXZpdHlfdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdObyBhY3Rpdml0eSB0aW1lb3V0IHNwZWNpZmllZCBpbiBoYW5kc2hha2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdjb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAgIGlkOiBtZXNzYWdlLmRhdGEuc29ja2V0X2lkLFxuICAgICAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogbWVzc2FnZS5kYXRhLmFjdGl2aXR5X3RpbWVvdXQgKiAxMDAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlLmV2ZW50ID09PSAncHVzaGVyOmVycm9yJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IHRoaXMuZ2V0Q2xvc2VBY3Rpb24obWVzc2FnZS5kYXRhKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5nZXRDbG9zZUVycm9yKG1lc3NhZ2UuZGF0YSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0ludmFsaWQgaGFuZHNoYWtlJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Q2xvc2VBY3Rpb246IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgIGlmIChjbG9zZUV2ZW50LmNvZGUgPCA0MDAwKSB7XG4gICAgICAgICAgICBpZiAoY2xvc2VFdmVudC5jb2RlID49IDEwMDIgJiYgY2xvc2VFdmVudC5jb2RlIDw9IDEwMDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2JhY2tvZmYnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xvc2VFdmVudC5jb2RlID09PSA0MDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Rsc19vbmx5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPCA0MTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JlZnVzZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQyMDApIHtcbiAgICAgICAgICAgIHJldHVybiAnYmFja29mZic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xvc2VFdmVudC5jb2RlIDwgNDMwMCkge1xuICAgICAgICAgICAgcmV0dXJuICdyZXRyeSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JlZnVzZWQnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXRDbG9zZUVycm9yOiBmdW5jdGlvbiAoY2xvc2VFdmVudCkge1xuICAgICAgICBpZiAoY2xvc2VFdmVudC5jb2RlICE9PSAxMDAwICYmIGNsb3NlRXZlbnQuY29kZSAhPT0gMTAwMSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUHVzaGVyRXJyb3InLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY2xvc2VFdmVudC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjbG9zZUV2ZW50LnJlYXNvbiB8fCBjbG9zZUV2ZW50Lm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcHJvdG9jb2xfcHJvdG9jb2wgPSAoUHJvdG9jb2wpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi50c1xuXG5cblxuXG5jbGFzcyBjb25uZWN0aW9uX0Nvbm5lY3Rpb24gZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkLCB0cmFuc3BvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVvdXQgPSB0cmFuc3BvcnQuYWN0aXZpdHlUaW1lb3V0O1xuICAgICAgICB0aGlzLmJpbmRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuaGFuZGxlc0FjdGl2aXR5Q2hlY2tzKCk7XG4gICAgfVxuICAgIHNlbmQoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuc2VuZChkYXRhKTtcbiAgICB9XG4gICAgc2VuZF9ldmVudChuYW1lLCBkYXRhLCBjaGFubmVsKSB7XG4gICAgICAgIHZhciBldmVudCA9IHsgZXZlbnQ6IG5hbWUsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIGV2ZW50LmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnRXZlbnQgc2VudCcsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChwcm90b2NvbF9wcm90b2NvbC5lbmNvZGVNZXNzYWdlKGV2ZW50KSk7XG4gICAgfVxuICAgIHBpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydC5zdXBwb3J0c1BpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kX2V2ZW50KCdwdXNoZXI6cGluZycsIHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG4gICAgYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IChtZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcHVzaGVyRXZlbnQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaGVyRXZlbnQgPSBwcm90b2NvbF9wcm90b2NvbC5kZWNvZGVNZXNzYWdlKG1lc3NhZ2VFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTWVzc2FnZVBhcnNlRXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlRXZlbnQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwdXNoZXJFdmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRXZlbnQgcmVjZCcsIHB1c2hlckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwdXNoZXJFdmVudC5ldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOmVycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUHVzaGVyRXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwdXNoZXJFdmVudC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBvbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHB1c2hlckV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aXZpdHk6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2aXR5Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2VkOiAoY2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZUV2ZW50ICYmIGNsb3NlRXZlbnQuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlRXZlbnQoY2xvc2VFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVuYmluZExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgICAgICAgIG9iamVjdEFwcGx5KGxpc3RlbmVycywgKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnVuYmluZChldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIG9iamVjdEFwcGx5KGxpc3RlbmVycywgKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuYmluZChldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQ2xvc2VFdmVudChjbG9zZUV2ZW50KSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBwcm90b2NvbF9wcm90b2NvbC5nZXRDbG9zZUFjdGlvbihjbG9zZUV2ZW50KTtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvdG9jb2xfcHJvdG9jb2wuZ2V0Q2xvc2VFcnJvcihjbG9zZUV2ZW50KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChhY3Rpb24sIHsgYWN0aW9uOiBhY3Rpb24sIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25uZWN0aW9uL2hhbmRzaGFrZS9pbmRleC50c1xuXG5cblxuY2xhc3MgaGFuZHNoYWtlX0hhbmRzaGFrZSB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmJpbmRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgfVxuICAgIGJpbmRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMub25NZXNzYWdlID0gKG0pID0+IHtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm90b2NvbF9wcm90b2NvbC5wcm9jZXNzSGFuZHNoYWtlKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaCgnZXJyb3InLCB7IGVycm9yOiBlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5hY3Rpb24gPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2goJ2Nvbm5lY3RlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjogbmV3IGNvbm5lY3Rpb25fQ29ubmVjdGlvbihyZXN1bHQuaWQsIHRoaXMudHJhbnNwb3J0KSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlUaW1lb3V0OiByZXN1bHQuYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2gocmVzdWx0LmFjdGlvbiwgeyBlcnJvcjogcmVzdWx0LmVycm9yIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25DbG9zZWQgPSAoY2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBwcm90b2NvbF9wcm90b2NvbC5nZXRDbG9zZUFjdGlvbihjbG9zZUV2ZW50KSB8fCAnYmFja29mZic7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBwcm90b2NvbF9wcm90b2NvbC5nZXRDbG9zZUVycm9yKGNsb3NlRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goYWN0aW9uLCB7IGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuYmluZCgnbWVzc2FnZScsIHRoaXMub25NZXNzYWdlKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuYmluZCgnY2xvc2VkJywgdGhpcy5vbkNsb3NlZCk7XG4gICAgfVxuICAgIHVuYmluZExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQudW5iaW5kKCdtZXNzYWdlJywgdGhpcy5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoJ2Nsb3NlZCcsIHRoaXMub25DbG9zZWQpO1xuICAgIH1cbiAgICBmaW5pc2goYWN0aW9uLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhleHRlbmQoeyB0cmFuc3BvcnQ6IHRoaXMudHJhbnNwb3J0LCBhY3Rpb246IGFjdGlvbiB9LCBwYXJhbXMpKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdGltZWxpbmUvdGltZWxpbmVfc2VuZGVyLnRzXG5cbmNsYXNzIHRpbWVsaW5lX3NlbmRlcl9UaW1lbGluZVNlbmRlciB7XG4gICAgY29uc3RydWN0b3IodGltZWxpbmUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIH1cbiAgICBzZW5kKHVzZVRMUywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lbGluZS5zZW5kKHJ1bnRpbWUuVGltZWxpbmVUcmFuc3BvcnQuZ2V0QWdlbnQodGhpcywgdXNlVExTKSwgY2FsbGJhY2spO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9jaGFubmVsLnRzXG5cblxuXG5cblxuY2xhc3MgY2hhbm5lbF9DaGFubmVsIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgc3VwZXIoZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiAnICsgbmFtZSArICcgZm9yICcgKyBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnB1c2hlciA9IHB1c2hlcjtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBhdXRob3JpemUoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7IGF1dGg6ICcnIH0pO1xuICAgIH1cbiAgICB0cmlnZ2VyKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIGlmIChldmVudC5pbmRleE9mKCdjbGllbnQtJykgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCYWRFdmVudE5hbWUoXCJFdmVudCAnXCIgKyBldmVudCArIFwiJyBkb2VzIG5vdCBzdGFydCB3aXRoICdjbGllbnQtJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgndHJpZ2dlcmluZ0NsaWVudEV2ZW50cycpO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYENsaWVudCBldmVudCB0cmlnZ2VyZWQgYmVmb3JlIGNoYW5uZWwgJ3N1YnNjcmlwdGlvbl9zdWNjZWVkZWQnIGV2ZW50IC4gJHtzdWZmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoZXZlbnQsIGRhdGEsIHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uU3VjY2VlZGVkRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fY291bnQnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkNvdW50RXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnVuc3Vic2NyaWJlKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgZXZlbnQuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlU3Vic2NyaXB0aW9uQ291bnRFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YS5zdWJzY3JpcHRpb25fY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ291bnQgPSBldmVudC5kYXRhLnN1YnNjcmlwdGlvbl9jb3VudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fY291bnQnLCBldmVudC5kYXRhKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRob3JpemUodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zb2NrZXRfaWQsIChlcnJvciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOnN1YnNjcmlwdGlvbl9lcnJvcicsIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0F1dGhFcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sIGVycm9yIGluc3RhbmNlb2YgSFRUUEF1dGhFcnJvciA/IHsgc3RhdHVzOiBlcnJvci5zdGF0dXMgfSA6IHt9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hlci5zZW5kX2V2ZW50KCdwdXNoZXI6c3Vic2NyaWJlJywge1xuICAgICAgICAgICAgICAgICAgICBhdXRoOiBkYXRhLmF1dGgsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxfZGF0YTogZGF0YS5jaGFubmVsX2RhdGEsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoZXIuc2VuZF9ldmVudCgncHVzaGVyOnVuc3Vic2NyaWJlJywge1xuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIHJlaW5zdGF0ZVN1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY2hhbm5lbHMvcHJpdmF0ZV9jaGFubmVsLnRzXG5cbmNsYXNzIHByaXZhdGVfY2hhbm5lbF9Qcml2YXRlQ2hhbm5lbCBleHRlbmRzIGNoYW5uZWxfQ2hhbm5lbCB7XG4gICAgYXV0aG9yaXplKHNvY2tldElkLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXNoZXIuY29uZmlnLmNoYW5uZWxBdXRob3JpemVyKHtcbiAgICAgICAgICAgIGNoYW5uZWxOYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBzb2NrZXRJZDogc29ja2V0SWQsXG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY2hhbm5lbHMvbWVtYmVycy50c1xuXG5jbGFzcyBtZW1iZXJzX01lbWJlcnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIGdldChpZCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubWVtYmVycywgaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBpbmZvOiB0aGlzLm1lbWJlcnNbaWRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgb2JqZWN0QXBwbHkodGhpcy5tZW1iZXJzLCAobWVtYmVyLCBpZCkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5nZXQoaWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldE15SUQoaWQpIHtcbiAgICAgICAgdGhpcy5teUlEID0gaWQ7XG4gICAgfVxuICAgIG9uU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbkRhdGEpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gc3Vic2NyaXB0aW9uRGF0YS5wcmVzZW5jZS5oYXNoO1xuICAgICAgICB0aGlzLmNvdW50ID0gc3Vic2NyaXB0aW9uRGF0YS5wcmVzZW5jZS5jb3VudDtcbiAgICAgICAgdGhpcy5tZSA9IHRoaXMuZ2V0KHRoaXMubXlJRCk7XG4gICAgfVxuICAgIGFkZE1lbWJlcihtZW1iZXJEYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZW1iZXJzW21lbWJlckRhdGEudXNlcl9pZF0gPSBtZW1iZXJEYXRhLnVzZXJfaW5mbztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG1lbWJlckRhdGEudXNlcl9pZCk7XG4gICAgfVxuICAgIHJlbW92ZU1lbWJlcihtZW1iZXJEYXRhKSB7XG4gICAgICAgIHZhciBtZW1iZXIgPSB0aGlzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpO1xuICAgICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5tZW1iZXJzW21lbWJlckRhdGEudXNlcl9pZF07XG4gICAgICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbWJlcjtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IHt9O1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5teUlEID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZSA9IG51bGw7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL3ByZXNlbmNlX2NoYW5uZWwudHNcbnZhciBfX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcblxuXG5cblxuY2xhc3MgcHJlc2VuY2VfY2hhbm5lbF9QcmVzZW5jZUNoYW5uZWwgZXh0ZW5kcyBwcml2YXRlX2NoYW5uZWxfUHJpdmF0ZUNoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHB1c2hlcikge1xuICAgICAgICBzdXBlcihuYW1lLCBwdXNoZXIpO1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBuZXcgbWVtYmVyc19NZW1iZXJzKCk7XG4gICAgfVxuICAgIGF1dGhvcml6ZShzb2NrZXRJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIuYXV0aG9yaXplKHNvY2tldElkLCAoZXJyb3IsIGF1dGhEYXRhKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXV0aERhdGEgPSBhdXRoRGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aERhdGEuY2hhbm5lbF9kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWxEYXRhID0gSlNPTi5wYXJzZShhdXRoRGF0YS5jaGFubmVsX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbWJlcnMuc2V0TXlJRChjaGFubmVsRGF0YS51c2VyX2lkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucHVzaGVyLnVzZXIuc2lnbmluRG9uZVByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnB1c2hlci51c2VyLnVzZXJfZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbWJlcnMuc2V0TXlJRCh0aGlzLnB1c2hlci51c2VyLnVzZXJfZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3VmZml4ID0gdXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCdhdXRob3JpemF0aW9uRW5kcG9pbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgSW52YWxpZCBhdXRoIHJlc3BvbnNlIGZvciBjaGFubmVsICcke3RoaXMubmFtZX0nLCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgZXhwZWN0ZWQgJ2NoYW5uZWxfZGF0YScgZmllbGQuICR7c3VmZml4fSwgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYG9yIHRoZSB1c2VyIHNob3VsZCBiZSBzaWduZWQgaW4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygnSW52YWxpZCBhdXRoIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgYXV0aERhdGEpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW50ZXJuYWxFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgIGlmIChldmVudC51c2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEudXNlcl9pZCA9IGV2ZW50LnVzZXJfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCBkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlSW50ZXJuYWxFdmVudChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fY291bnQnOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uQ291bnRFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6bWVtYmVyX2FkZGVkJzpcbiAgICAgICAgICAgICAgICB2YXIgYWRkZWRNZW1iZXIgPSB0aGlzLm1lbWJlcnMuYWRkTWVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9hZGRlZCcsIGFkZGVkTWVtYmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDptZW1iZXJfcmVtb3ZlZCc6XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRNZW1iZXIgPSB0aGlzLm1lbWJlcnMucmVtb3ZlTWVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9yZW1vdmVkJywgcmVtb3ZlZE1lbWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnVuc3Vic2NyaWJlKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMub25TdWJzY3JpcHRpb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgdGhpcy5tZW1iZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMucmVzZXQoKTtcbiAgICAgICAgc3VwZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbn1cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9Ac3RhYmxlbGliL3V0ZjgvbGliL3V0ZjguanNcbnZhciB1dGY4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9Ac3RhYmxlbGliL2Jhc2U2NC9saWIvYmFzZTY0LmpzXG52YXIgYmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9lbmNyeXB0ZWRfY2hhbm5lbC50c1xuXG5cblxuXG5cbmNsYXNzIGVuY3J5cHRlZF9jaGFubmVsX0VuY3J5cHRlZENoYW5uZWwgZXh0ZW5kcyBwcml2YXRlX2NoYW5uZWxfUHJpdmF0ZUNoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHB1c2hlciwgbmFjbCkge1xuICAgICAgICBzdXBlcihuYW1lLCBwdXNoZXIpO1xuICAgICAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgICAgIHRoaXMubmFjbCA9IG5hY2w7XG4gICAgfVxuICAgIGF1dGhvcml6ZShzb2NrZXRJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIuYXV0aG9yaXplKHNvY2tldElkLCAoZXJyb3IsIGF1dGhEYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgYXV0aERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaGFyZWRTZWNyZXQgPSBhdXRoRGF0YVsnc2hhcmVkX3NlY3JldCddO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRTZWNyZXQpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoYE5vIHNoYXJlZF9zZWNyZXQga2V5IGluIGF1dGggcGF5bG9hZCBmb3IgZW5jcnlwdGVkIGNoYW5uZWw6ICR7dGhpcy5uYW1lfWApLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmtleSA9IE9iamVjdChiYXNlNjRbXCJkZWNvZGVcIl0pKHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICBkZWxldGUgYXV0aERhdGFbJ3NoYXJlZF9zZWNyZXQnXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGF1dGhEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyaWdnZXIoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRmVhdHVyZSgnQ2xpZW50IGV2ZW50cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIGVuY3J5cHRlZCBjaGFubmVscycpO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgPT09IDAgfHxcbiAgICAgICAgICAgIGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXI6JykgPT09IDApIHtcbiAgICAgICAgICAgIHN1cGVyLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZUVuY3J5cHRlZEV2ZW50KGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgfVxuICAgIGhhbmRsZUVuY3J5cHRlZEV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnUmVjZWl2ZWQgZW5jcnlwdGVkIGV2ZW50IGJlZm9yZSBrZXkgaGFzIGJlZW4gcmV0cmlldmVkIGZyb20gdGhlIGF1dGhFbmRwb2ludCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS5jaXBoZXJ0ZXh0IHx8ICFkYXRhLm5vbmNlKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgZm9ybWF0IGZvciBlbmNyeXB0ZWQgZXZlbnQsIGV4cGVjdGVkIG9iamVjdCB3aXRoIGBjaXBoZXJ0ZXh0YCBhbmQgYG5vbmNlYCBmaWVsZHMsIGdvdDogJyArXG4gICAgICAgICAgICAgICAgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNpcGhlclRleHQgPSBPYmplY3QoYmFzZTY0W1wiZGVjb2RlXCJdKShkYXRhLmNpcGhlcnRleHQpO1xuICAgICAgICBpZiAoY2lwaGVyVGV4dC5sZW5ndGggPCB0aGlzLm5hY2wuc2VjcmV0Ym94Lm92ZXJoZWFkTGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEV4cGVjdGVkIGVuY3J5cHRlZCBldmVudCBjaXBoZXJ0ZXh0IGxlbmd0aCB0byBiZSAke3RoaXMubmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGh9LCBnb3Q6ICR7Y2lwaGVyVGV4dC5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vbmNlID0gT2JqZWN0KGJhc2U2NFtcImRlY29kZVwiXSkoZGF0YS5ub25jZSk7XG4gICAgICAgIGlmIChub25jZS5sZW5ndGggPCB0aGlzLm5hY2wuc2VjcmV0Ym94Lm5vbmNlTGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYEV4cGVjdGVkIGVuY3J5cHRlZCBldmVudCBub25jZSBsZW5ndGggdG8gYmUgJHt0aGlzLm5hY2wuc2VjcmV0Ym94Lm5vbmNlTGVuZ3RofSwgZ290OiAke25vbmNlLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnl0ZXMgPSB0aGlzLm5hY2wuc2VjcmV0Ym94Lm9wZW4oY2lwaGVyVGV4dCwgbm9uY2UsIHRoaXMua2V5KTtcbiAgICAgICAgaWYgKGJ5dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ0ZhaWxlZCB0byBkZWNyeXB0IGFuIGV2ZW50LCBwcm9iYWJseSBiZWNhdXNlIGl0IHdhcyBlbmNyeXB0ZWQgd2l0aCBhIGRpZmZlcmVudCBrZXkuIEZldGNoaW5nIGEgbmV3IGtleSBmcm9tIHRoZSBhdXRoRW5kcG9pbnQuLi4nKTtcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXplKHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkLCAoZXJyb3IsIGF1dGhEYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBhdXRoRW5kcG9pbnQ6ICR7YXV0aERhdGF9LiBVbmFibGUgdG8gZmV0Y2ggbmV3IGtleSwgc28gZHJvcHBpbmcgZW5jcnlwdGVkIGV2ZW50YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSB0aGlzLm5hY2wuc2VjcmV0Ym94Lm9wZW4oY2lwaGVyVGV4dCwgbm9uY2UsIHRoaXMua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gZGVjcnlwdCBldmVudCB3aXRoIG5ldyBrZXkuIERyb3BwaW5nIGVuY3J5cHRlZCBldmVudGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudCwgdGhpcy5nZXREYXRhVG9FbWl0KGJ5dGVzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KGV2ZW50LCB0aGlzLmdldERhdGFUb0VtaXQoYnl0ZXMpKTtcbiAgICB9XG4gICAgZ2V0RGF0YVRvRW1pdChieXRlcykge1xuICAgICAgICBsZXQgcmF3ID0gT2JqZWN0KHV0ZjhbXCJkZWNvZGVcIl0pKGJ5dGVzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJhdyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Nvbm5lY3Rpb24vY29ubmVjdGlvbl9tYW5hZ2VyLnRzXG5cblxuXG5cblxuY2xhc3MgY29ubmVjdGlvbl9tYW5hZ2VyX0Nvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdpbml0aWFsaXplZCc7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gdGhpcy5vcHRpb25zLnRpbWVsaW5lO1xuICAgICAgICB0aGlzLnVzaW5nVExTID0gdGhpcy5vcHRpb25zLnVzZVRMUztcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrcyA9IHRoaXMuYnVpbGRFcnJvckNhbGxiYWNrcygpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3MgPSB0aGlzLmJ1aWxkQ29ubmVjdGlvbkNhbGxiYWNrcyh0aGlzLmVycm9yQ2FsbGJhY2tzKTtcbiAgICAgICAgdGhpcy5oYW5kc2hha2VDYWxsYmFja3MgPSB0aGlzLmJ1aWxkSGFuZHNoYWtlQ2FsbGJhY2tzKHRoaXMuZXJyb3JDYWxsYmFja3MpO1xuICAgICAgICB2YXIgTmV0d29yayA9IHJ1bnRpbWUuZ2V0TmV0d29yaygpO1xuICAgICAgICBOZXR3b3JrLmJpbmQoJ29ubGluZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IG5ldGluZm86ICdvbmxpbmUnIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJyB8fCB0aGlzLnN0YXRlID09PSAndW5hdmFpbGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgTmV0d29yay5iaW5kKCdvZmZsaW5lJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHsgbmV0aW5mbzogJ29mZmxpbmUnIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RyYXRlZ3koKTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbiB8fCB0aGlzLnJ1bm5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdmYWlsZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIHRoaXMuc2V0VW5hdmFpbGFibGVUaW1lcigpO1xuICAgIH1cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRfZXZlbnQobmFtZSwgZGF0YSwgY2hhbm5lbCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRfZXZlbnQobmFtZSwgZGF0YSwgY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SW50ZXJuYWxseSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICB9XG4gICAgaXNVc2luZ1RMUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNpbmdUTFM7XG4gICAgfVxuICAgIHN0YXJ0Q29ubmVjdGluZygpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gKGVycm9yLCBoYW5kc2hha2UpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmVyID0gdGhpcy5zdHJhdGVneS5jb25uZWN0KDAsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kc2hha2UuYWN0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnSGFuZHNoYWtlRXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGhhbmRzaGFrZS5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZWxpbmUuZXJyb3IoeyBoYW5kc2hha2VFcnJvcjogaGFuZHNoYWtlLmVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kc2hha2VDYWxsYmFja3NbaGFuZHNoYWtlLmFjdGlvbl0oaGFuZHNoYWtlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVubmVyID0gdGhpcy5zdHJhdGVneS5jb25uZWN0KDAsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgYWJvcnRDb25uZWN0aW5nKCkge1xuICAgICAgICBpZiAodGhpcy5ydW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMucnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB0aGlzLnJ1bm5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdEludGVybmFsbHkoKSB7XG4gICAgICAgIHRoaXMuYWJvcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIHRoaXMuY2xlYXJSZXRyeVRpbWVyKCk7XG4gICAgICAgIHRoaXMuY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5hYmFuZG9uQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0cmF0ZWd5KCkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5vcHRpb25zLmdldFN0cmF0ZWd5KHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgICAgICAgIHVzZVRMUzogdGhpcy51c2luZ1RMUyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHJ5SW4oZGVsYXkpIHtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHsgYWN0aW9uOiAncmV0cnknLCBkZWxheTogZGVsYXkgfSk7XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGluZ19pbicsIE1hdGgucm91bmQoZGVsYXkgLyAxMDAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcihkZWxheSB8fCAwLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RJbnRlcm5hbGx5KCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsZWFyUmV0cnlUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmV0cnlUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VW5hdmFpbGFibGVUaW1lcigpIHtcbiAgICAgICAgdGhpcy51bmF2YWlsYWJsZVRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcih0aGlzLm9wdGlvbnMudW5hdmFpbGFibGVUaW1lb3V0LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCd1bmF2YWlsYWJsZScpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy51bmF2YWlsYWJsZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnVuYXZhaWxhYmxlVGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRBY3Rpdml0eUNoZWNrKCkge1xuICAgICAgICB0aGlzLnN0b3BBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5waW5nKCk7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlUaW1lciA9IG5ldyB0aW1lcnNfT25lT2ZmVGltZXIodGhpcy5vcHRpb25zLnBvbmdUaW1lb3V0LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmVycm9yKHsgcG9uZ190aW1lZF9vdXQ6IHRoaXMub3B0aW9ucy5wb25nVGltZW91dCB9KTtcbiAgICAgICAgICAgIHRoaXMucmV0cnlJbigwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2V0QWN0aXZpdHlDaGVjaygpIHtcbiAgICAgICAgdGhpcy5zdG9wQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uICYmICF0aGlzLmNvbm5lY3Rpb24uaGFuZGxlc0FjdGl2aXR5Q2hlY2tzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlUaW1lciA9IG5ldyB0aW1lcnNfT25lT2ZmVGltZXIodGhpcy5hY3Rpdml0eVRpbWVvdXQsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wQWN0aXZpdHlDaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZpdHlUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZENvbm5lY3Rpb25DYWxsYmFja3MoZXJyb3JDYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZXJyb3JDYWxsYmFja3MsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwaW5nOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kX2V2ZW50KCdwdXNoZXI6cG9uZycsIHt9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3Rpdml0eTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2VkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYmFuZG9uQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFJldHJ5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZEhhbmRzaGFrZUNhbGxiYWNrcyhlcnJvckNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBlcnJvckNhbGxiYWNrcywge1xuICAgICAgICAgICAgY29ubmVjdGVkOiAoaGFuZHNoYWtlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVvdXQgPSBNYXRoLm1pbih0aGlzLm9wdGlvbnMuYWN0aXZpdHlUaW1lb3V0LCBoYW5kc2hha2UuYWN0aXZpdHlUaW1lb3V0LCBoYW5kc2hha2UuY29ubmVjdGlvbi5hY3Rpdml0eVRpbWVvdXQgfHwgSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uKGhhbmRzaGFrZS5jb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldF9pZCA9IHRoaXMuY29ubmVjdGlvbi5pZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdjb25uZWN0ZWQnLCB7IHNvY2tldF9pZDogdGhpcy5zb2NrZXRfaWQgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVpbGRFcnJvckNhbGxiYWNrcygpIHtcbiAgICAgICAgbGV0IHdpdGhFcnJvckVtaXR0ZWQgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgeyB0eXBlOiAnV2ViU29ja2V0RXJyb3InLCBlcnJvcjogcmVzdWx0LmVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRsc19vbmx5OiB3aXRoRXJyb3JFbWl0dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzaW5nVExTID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0cmF0ZWd5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZWZ1c2VkOiB3aXRoRXJyb3JFbWl0dGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYmFja29mZjogd2l0aEVycm9yRW1pdHRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDEwMDApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXRyeTogd2l0aEVycm9yRW1pdHRlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyeUluKDApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNldENvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5iaW5kKGV2ZW50LCB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3NbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0QWN0aXZpdHlDaGVjaygpO1xuICAgIH1cbiAgICBhYmFuZG9uQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3BBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgIGZvciAodmFyIGV2ZW50IGluIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnVuYmluZChldmVudCwgdGhpcy5jb25uZWN0aW9uQ2FsbGJhY2tzW2V2ZW50XSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgZGF0YSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5ld1N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGVEZXNjcmlwdGlvbiA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlRGVzY3JpcHRpb24gPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVEZXNjcmlwdGlvbiArPSAnIHdpdGggbmV3IHNvY2tldCBJRCAnICsgZGF0YS5zb2NrZXRfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ1N0YXRlIGNoYW5nZWQnLCBwcmV2aW91c1N0YXRlICsgJyAtPiAnICsgbmV3U3RhdGVEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBzdGF0ZTogbmV3U3RhdGUsIHBhcmFtczogZGF0YSB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhdGVfY2hhbmdlJywgeyBwcmV2aW91czogcHJldmlvdXNTdGF0ZSwgY3VycmVudDogbmV3U3RhdGUgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQobmV3U3RhdGUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZFJldHJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnIHx8IHRoaXMuc3RhdGUgPT09ICdjb25uZWN0ZWQnO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9jaGFubmVscy50c1xuXG5cblxuXG5jbGFzcyBjaGFubmVsc19DaGFubmVscyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSB7fTtcbiAgICB9XG4gICAgYWRkKG5hbWUsIHB1c2hlcikge1xuICAgICAgICBpZiAoIXRoaXMuY2hhbm5lbHNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHNbbmFtZV0gPSBjcmVhdGVDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh0aGlzLmNoYW5uZWxzKTtcbiAgICB9XG4gICAgZmluZChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgIH1cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgb2JqZWN0QXBwbHkodGhpcy5jaGFubmVscywgZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDaGFubmVsKG5hbWUsIHB1c2hlcikge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJ3ByaXZhdGUtZW5jcnlwdGVkLScpID09PSAwKSB7XG4gICAgICAgIGlmIChwdXNoZXIuY29uZmlnLm5hY2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUVuY3J5cHRlZENoYW5uZWwobmFtZSwgcHVzaGVyLCBwdXNoZXIuY29uZmlnLm5hY2wpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcnJNc2cgPSAnVHJpZWQgdG8gc3Vic2NyaWJlIHRvIGEgcHJpdmF0ZS1lbmNyeXB0ZWQtIGNoYW5uZWwgYnV0IG5vIG5hY2wgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlJztcbiAgICAgICAgbGV0IHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnZW5jcnlwdGVkQ2hhbm5lbFN1cHBvcnQnKTtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRmVhdHVyZShgJHtlcnJNc2d9LiAke3N1ZmZpeH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdwcml2YXRlLScpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZVByaXZhdGVDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuaW5kZXhPZigncHJlc2VuY2UtJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlUHJlc2VuY2VDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBCYWRDaGFubmVsTmFtZSgnQ2Fubm90IGNyZWF0ZSBhIGNoYW5uZWwgd2l0aCBuYW1lIFwiJyArIG5hbWUgKyAnXCIuJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVDaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3V0aWxzL2ZhY3RvcnkudHNcblxuXG5cblxuXG5cblxuXG5cbnZhciBGYWN0b3J5ID0ge1xuICAgIGNyZWF0ZUNoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGNoYW5uZWxzX0NoYW5uZWxzKCk7XG4gICAgfSxcbiAgICBjcmVhdGVDb25uZWN0aW9uTWFuYWdlcihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb25uZWN0aW9uX21hbmFnZXJfQ29ubmVjdGlvbk1hbmFnZXIoa2V5LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2hhbm5lbF9DaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfSxcbiAgICBjcmVhdGVQcml2YXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwcml2YXRlX2NoYW5uZWxfUHJpdmF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9LFxuICAgIGNyZWF0ZVByZXNlbmNlQ2hhbm5lbChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwcmVzZW5jZV9jaGFubmVsX1ByZXNlbmNlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH0sXG4gICAgY3JlYXRlRW5jcnlwdGVkQ2hhbm5lbChuYW1lLCBwdXNoZXIsIG5hY2wpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlbmNyeXB0ZWRfY2hhbm5lbF9FbmNyeXB0ZWRDaGFubmVsKG5hbWUsIHB1c2hlciwgbmFjbCk7XG4gICAgfSxcbiAgICBjcmVhdGVUaW1lbGluZVNlbmRlcih0aW1lbGluZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRpbWVsaW5lX3NlbmRlcl9UaW1lbGluZVNlbmRlcih0aW1lbGluZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBjcmVhdGVIYW5kc2hha2UodHJhbnNwb3J0LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IGhhbmRzaGFrZV9IYW5kc2hha2UodHJhbnNwb3J0LCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBjcmVhdGVBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNzaXN0YW50X3RvX3RoZV90cmFuc3BvcnRfbWFuYWdlcl9Bc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKTtcbiAgICB9LFxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGZhY3RvcnkgPSAoRmFjdG9yeSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy90cmFuc3BvcnRfbWFuYWdlci50c1xuXG5jbGFzcyB0cmFuc3BvcnRfbWFuYWdlcl9UcmFuc3BvcnRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMubGl2ZXNMZWZ0ID0gdGhpcy5vcHRpb25zLmxpdmVzIHx8IEluZmluaXR5O1xuICAgIH1cbiAgICBnZXRBc3Npc3RhbnQodHJhbnNwb3J0KSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUFzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlcih0aGlzLCB0cmFuc3BvcnQsIHtcbiAgICAgICAgICAgIG1pblBpbmdEZWxheTogdGhpcy5vcHRpb25zLm1pblBpbmdEZWxheSxcbiAgICAgICAgICAgIG1heFBpbmdEZWxheTogdGhpcy5vcHRpb25zLm1heFBpbmdEZWxheSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQWxpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdmVzTGVmdCA+IDA7XG4gICAgfVxuICAgIHJlcG9ydERlYXRoKCkge1xuICAgICAgICB0aGlzLmxpdmVzTGVmdCAtPSAxO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL3NlcXVlbnRpYWxfc3RyYXRlZ3kudHNcblxuXG5cbmNsYXNzIHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVnaWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ2llcyA9IHN0cmF0ZWdpZXM7XG4gICAgICAgIHRoaXMubG9vcCA9IEJvb2xlYW4ob3B0aW9ucy5sb29wKTtcbiAgICAgICAgdGhpcy5mYWlsRmFzdCA9IEJvb2xlYW4ob3B0aW9ucy5mYWlsRmFzdCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgdGhpcy50aW1lb3V0TGltaXQgPSBvcHRpb25zLnRpbWVvdXRMaW1pdDtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5zdHJhdGVnaWVzLCB1dGlsLm1ldGhvZCgnaXNTdXBwb3J0ZWQnKSk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdHJhdGVnaWVzID0gdGhpcy5zdHJhdGVnaWVzO1xuICAgICAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICB2YXIgcnVubmVyID0gbnVsbDtcbiAgICAgICAgdmFyIHRyeU5leHRTdHJhdGVneSA9IChlcnJvciwgaGFuZHNoYWtlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaGFuZHNoYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50ICUgc3RyYXRlZ2llcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50IDwgc3RyYXRlZ2llcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSB0aW1lb3V0ICogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0LCB0aGlzLnRpbWVvdXRMaW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcnVubmVyID0gdGhpcy50cnlTdHJhdGVneShzdHJhdGVnaWVzW2N1cnJlbnRdLCBtaW5Qcmlvcml0eSwgeyB0aW1lb3V0LCBmYWlsRmFzdDogdGhpcy5mYWlsRmFzdCB9LCB0cnlOZXh0U3RyYXRlZ3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBydW5uZXIgPSB0aGlzLnRyeVN0cmF0ZWd5KHN0cmF0ZWdpZXNbY3VycmVudF0sIG1pblByaW9yaXR5LCB7IHRpbWVvdXQ6IHRpbWVvdXQsIGZhaWxGYXN0OiB0aGlzLmZhaWxGYXN0IH0sIHRyeU5leHRTdHJhdGVneSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdHJ5U3RyYXRlZ3koc3RyYXRlZ3ksIG1pblByaW9yaXR5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgcnVubmVyID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHRpbWVyID0gbmV3IHRpbWVyc19PbmVPZmZUaW1lcihvcHRpb25zLnRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bm5lciA9IHN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgJiYgdGltZXIgJiYgdGltZXIuaXNSdW5uaW5nKCkgJiYgIW9wdGlvbnMuZmFpbEZhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICB0aW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgaGFuZHNoYWtlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICB0aW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2Jlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3kudHNcblxuXG5jbGFzcyBiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5X0Jlc3RDb25uZWN0ZWRFdmVyU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWdpZXMpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVnaWVzID0gc3RyYXRlZ2llcztcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5zdHJhdGVnaWVzLCB1dGlsLm1ldGhvZCgnaXNTdXBwb3J0ZWQnKSk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0KHRoaXMuc3RyYXRlZ2llcywgbWluUHJpb3JpdHksIGZ1bmN0aW9uIChpLCBydW5uZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICBydW5uZXJzW2ldLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxSdW5uZXJzRmFpbGVkKHJ1bm5lcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcGx5KHJ1bm5lcnMsIGZ1bmN0aW9uIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkoaGFuZHNoYWtlLnRyYW5zcG9ydC5wcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaGFuZHNoYWtlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbm5lY3Qoc3RyYXRlZ2llcywgbWluUHJpb3JpdHksIGNhbGxiYWNrQnVpbGRlcikge1xuICAgIHZhciBydW5uZXJzID0gbWFwKHN0cmF0ZWdpZXMsIGZ1bmN0aW9uIChzdHJhdGVneSwgaSwgXywgcnMpIHtcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrQnVpbGRlcihpLCBycykpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcHBseShydW5uZXJzLCBhYm9ydFJ1bm5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBhcHBseShydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWxsUnVubmVyc0ZhaWxlZChydW5uZXJzKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25zX2FsbChydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHJ1bm5lci5lcnJvcik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhYm9ydFJ1bm5lcihydW5uZXIpIHtcbiAgICBpZiAoIXJ1bm5lci5lcnJvciAmJiAhcnVubmVyLmFib3J0ZWQpIHtcbiAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgIHJ1bm5lci5hYm9ydGVkID0gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy93ZWJzb2NrZXRfcHJpb3JpdGl6ZWRfY2FjaGVkX3N0cmF0ZWd5LnRzXG5cblxuXG5cbmNsYXNzIHdlYnNvY2tldF9wcmlvcml0aXplZF9jYWNoZWRfc3RyYXRlZ3lfV2ViU29ja2V0UHJpb3JpdGl6ZWRDYWNoZWRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ3ksIHRyYW5zcG9ydHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzO1xuICAgICAgICB0aGlzLnR0bCA9IG9wdGlvbnMudHRsIHx8IDE4MDAgKiAxMDAwO1xuICAgICAgICB0aGlzLnVzaW5nVExTID0gb3B0aW9ucy51c2VUTFM7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSBvcHRpb25zLnRpbWVsaW5lO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9XG4gICAgY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHVzaW5nVExTID0gdGhpcy51c2luZ1RMUztcbiAgICAgICAgdmFyIGluZm8gPSBmZXRjaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKTtcbiAgICAgICAgdmFyIGNhY2hlU2tpcENvdW50ID0gaW5mbyAmJiBpbmZvLmNhY2hlU2tpcENvdW50ID8gaW5mby5jYWNoZVNraXBDb3VudCA6IDA7XG4gICAgICAgIHZhciBzdHJhdGVnaWVzID0gW3RoaXMuc3RyYXRlZ3ldO1xuICAgICAgICBpZiAoaW5mbyAmJiBpbmZvLnRpbWVzdGFtcCArIHRoaXMudHRsID49IHV0aWwubm93KCkpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbaW5mby50cmFuc3BvcnRdO1xuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGlmIChbJ3dzJywgJ3dzcyddLmluY2x1ZGVzKGluZm8udHJhbnNwb3J0KSB8fCBjYWNoZVNraXBDb3VudCA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogaW5mby50cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlbmN5OiBpbmZvLmxhdGVuY3ksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdHJhdGVnaWVzLnB1c2gobmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFt0cmFuc3BvcnRdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiBpbmZvLmxhdGVuY3kgKiAyICsgMTAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxGYXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZVNraXBDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRUaW1lc3RhbXAgPSB1dGlsLm5vdygpO1xuICAgICAgICB2YXIgcnVubmVyID0gc3RyYXRlZ2llc1xuICAgICAgICAgICAgLnBvcCgpXG4gICAgICAgICAgICAuY29ubmVjdChtaW5Qcmlvcml0eSwgZnVuY3Rpb24gY2IoZXJyb3IsIGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmF0ZWdpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcCA9IHV0aWwubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lciA9IHN0cmF0ZWdpZXMucG9wKCkuY29ubmVjdChtaW5Qcmlvcml0eSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JlVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMsIGhhbmRzaGFrZS50cmFuc3BvcnQubmFtZSwgdXRpbC5ub3coKSAtIHN0YXJ0VGltZXN0YW1wLCBjYWNoZVNraXBDb3VudCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgaGFuZHNoYWtlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUcmFuc3BvcnRDYWNoZUtleSh1c2luZ1RMUykge1xuICAgIHJldHVybiAncHVzaGVyVHJhbnNwb3J0JyArICh1c2luZ1RMUyA/ICdUTFMnIDogJ05vblRMUycpO1xufVxuZnVuY3Rpb24gZmV0Y2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUykge1xuICAgIHZhciBzdG9yYWdlID0gcnVudGltZS5nZXRMb2NhbFN0b3JhZ2UoKTtcbiAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRDYWNoZSA9IHN0b3JhZ2VbZ2V0VHJhbnNwb3J0Q2FjaGVLZXkodXNpbmdUTFMpXTtcbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzZXJpYWxpemVkQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBmbHVzaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHN0b3JlVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMsIHRyYW5zcG9ydCwgbGF0ZW5jeSwgY2FjaGVTa2lwQ291bnQpIHtcbiAgICB2YXIgc3RvcmFnZSA9IHJ1bnRpbWUuZ2V0TG9jYWxTdG9yYWdlKCk7XG4gICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0b3JhZ2VbZ2V0VHJhbnNwb3J0Q2FjaGVLZXkodXNpbmdUTFMpXSA9IHNhZmVKU09OU3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHV0aWwubm93KCksXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiB0cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgbGF0ZW5jeTogbGF0ZW5jeSxcbiAgICAgICAgICAgICAgICBjYWNoZVNraXBDb3VudDogY2FjaGVTa2lwQ291bnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmx1c2hUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUykge1xuICAgIHZhciBzdG9yYWdlID0gcnVudGltZS5nZXRMb2NhbFN0b3JhZ2UoKTtcbiAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIHN0b3JhZ2VbZ2V0VHJhbnNwb3J0Q2FjaGVLZXkodXNpbmdUTFMpXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvZGVsYXllZF9zdHJhdGVneS50c1xuXG5jbGFzcyBkZWxheWVkX3N0cmF0ZWd5X0RlbGF5ZWRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3Ioc3RyYXRlZ3ksIHsgZGVsYXk6IG51bWJlciB9KSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0geyBkZWxheTogbnVtYmVyIH07XG4gICAgfVxuICAgIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3RyYXRlZ3kgPSB0aGlzLnN0cmF0ZWd5O1xuICAgICAgICB2YXIgcnVubmVyO1xuICAgICAgICB2YXIgdGltZXIgPSBuZXcgdGltZXJzX09uZU9mZlRpbWVyKHRoaXMub3B0aW9ucy5kZWxheSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcnVubmVyID0gc3RyYXRlZ3kuY29ubmVjdChtaW5Qcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZXIuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgbWluUHJpb3JpdHkgPSBwO1xuICAgICAgICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyLmZvcmNlTWluUHJpb3JpdHkocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9pZl9zdHJhdGVneS50c1xuY2xhc3MgSWZTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IodGVzdCwgdHJ1ZUJyYW5jaCwgZmFsc2VCcmFuY2gpIHtcbiAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgdGhpcy50cnVlQnJhbmNoID0gdHJ1ZUJyYW5jaDtcbiAgICAgICAgdGhpcy5mYWxzZUJyYW5jaCA9IGZhbHNlQnJhbmNoO1xuICAgIH1cbiAgICBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgdmFyIGJyYW5jaCA9IHRoaXMudGVzdCgpID8gdGhpcy50cnVlQnJhbmNoIDogdGhpcy5mYWxzZUJyYW5jaDtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5pc1N1cHBvcnRlZCgpO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgYnJhbmNoID0gdGhpcy50ZXN0KCkgPyB0aGlzLnRydWVCcmFuY2ggOiB0aGlzLmZhbHNlQnJhbmNoO1xuICAgICAgICByZXR1cm4gYnJhbmNoLmNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9maXJzdF9jb25uZWN0ZWRfc3RyYXRlZ3kudHNcbmNsYXNzIEZpcnN0Q29ubmVjdGVkU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWd5KSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmlzU3VwcG9ydGVkKCk7XG4gICAgfVxuICAgIGNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBydW5uZXIgPSB0aGlzLnN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgaGFuZHNoYWtlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZGVmYXVsdF9zdHJhdGVneS50c1xuXG5cblxuXG5cblxuXG5mdW5jdGlvbiB0ZXN0U3VwcG9ydHNTdHJhdGVneShzdHJhdGVneSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzdHJhdGVneS5pc1N1cHBvcnRlZCgpO1xuICAgIH07XG59XG52YXIgZ2V0RGVmYXVsdFN0cmF0ZWd5ID0gZnVuY3Rpb24gKGNvbmZpZywgYmFzZU9wdGlvbnMsIGRlZmluZVRyYW5zcG9ydCkge1xuICAgIHZhciBkZWZpbmVkVHJhbnNwb3J0cyA9IHt9O1xuICAgIGZ1bmN0aW9uIGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KG5hbWUsIHR5cGUsIHByaW9yaXR5LCBvcHRpb25zLCBtYW5hZ2VyKSB7XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnQoY29uZmlnLCBuYW1lLCB0eXBlLCBwcmlvcml0eSwgb3B0aW9ucywgbWFuYWdlcik7XG4gICAgICAgIGRlZmluZWRUcmFuc3BvcnRzW25hbWVdID0gdHJhbnNwb3J0O1xuICAgICAgICByZXR1cm4gdHJhbnNwb3J0O1xuICAgIH1cbiAgICB2YXIgd3Nfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VPcHRpb25zLCB7XG4gICAgICAgIGhvc3ROb25UTFM6IGNvbmZpZy53c0hvc3QgKyAnOicgKyBjb25maWcud3NQb3J0LFxuICAgICAgICBob3N0VExTOiBjb25maWcud3NIb3N0ICsgJzonICsgY29uZmlnLndzc1BvcnQsXG4gICAgICAgIGh0dHBQYXRoOiBjb25maWcud3NQYXRoLFxuICAgIH0pO1xuICAgIHZhciB3c3Nfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHdzX29wdGlvbnMsIHtcbiAgICAgICAgdXNlVExTOiB0cnVlLFxuICAgIH0pO1xuICAgIHZhciBzb2NranNfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VPcHRpb25zLCB7XG4gICAgICAgIGhvc3ROb25UTFM6IGNvbmZpZy5odHRwSG9zdCArICc6JyArIGNvbmZpZy5odHRwUG9ydCxcbiAgICAgICAgaG9zdFRMUzogY29uZmlnLmh0dHBIb3N0ICsgJzonICsgY29uZmlnLmh0dHBzUG9ydCxcbiAgICAgICAgaHR0cFBhdGg6IGNvbmZpZy5odHRwUGF0aCxcbiAgICB9KTtcbiAgICB2YXIgdGltZW91dHMgPSB7XG4gICAgICAgIGxvb3A6IHRydWUsXG4gICAgICAgIHRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICB0aW1lb3V0TGltaXQ6IDYwMDAwLFxuICAgIH07XG4gICAgdmFyIHdzX21hbmFnZXIgPSBuZXcgdHJhbnNwb3J0X21hbmFnZXJfVHJhbnNwb3J0TWFuYWdlcih7XG4gICAgICAgIG1pblBpbmdEZWxheTogMTAwMDAsXG4gICAgICAgIG1heFBpbmdEZWxheTogY29uZmlnLmFjdGl2aXR5VGltZW91dCxcbiAgICB9KTtcbiAgICB2YXIgc3RyZWFtaW5nX21hbmFnZXIgPSBuZXcgdHJhbnNwb3J0X21hbmFnZXJfVHJhbnNwb3J0TWFuYWdlcih7XG4gICAgICAgIGxpdmVzOiAyLFxuICAgICAgICBtaW5QaW5nRGVsYXk6IDEwMDAwLFxuICAgICAgICBtYXhQaW5nRGVsYXk6IGNvbmZpZy5hY3Rpdml0eVRpbWVvdXQsXG4gICAgfSk7XG4gICAgdmFyIHdzX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd3cycsICd3cycsIDMsIHdzX29wdGlvbnMsIHdzX21hbmFnZXIpO1xuICAgIHZhciB3c3NfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3dzcycsICd3cycsIDMsIHdzc19vcHRpb25zLCB3c19tYW5hZ2VyKTtcbiAgICB2YXIgc29ja2pzX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCdzb2NranMnLCAnc29ja2pzJywgMSwgc29ja2pzX29wdGlvbnMpO1xuICAgIHZhciB4aHJfc3RyZWFtaW5nX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd4aHJfc3RyZWFtaW5nJywgJ3hocl9zdHJlYW1pbmcnLCAxLCBzb2NranNfb3B0aW9ucywgc3RyZWFtaW5nX21hbmFnZXIpO1xuICAgIHZhciB4ZHJfc3RyZWFtaW5nX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd4ZHJfc3RyZWFtaW5nJywgJ3hkcl9zdHJlYW1pbmcnLCAxLCBzb2NranNfb3B0aW9ucywgc3RyZWFtaW5nX21hbmFnZXIpO1xuICAgIHZhciB4aHJfcG9sbGluZ190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgneGhyX3BvbGxpbmcnLCAneGhyX3BvbGxpbmcnLCAxLCBzb2NranNfb3B0aW9ucyk7XG4gICAgdmFyIHhkcl9wb2xsaW5nX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd4ZHJfcG9sbGluZycsICd4ZHJfcG9sbGluZycsIDEsIHNvY2tqc19vcHRpb25zKTtcbiAgICB2YXIgd3NfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbd3NfdHJhbnNwb3J0XSwgdGltZW91dHMpO1xuICAgIHZhciB3c3NfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneShbd3NzX3RyYW5zcG9ydF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgc29ja2pzX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3koW3NvY2tqc190cmFuc3BvcnRdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHN0cmVhbWluZ19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFtcbiAgICAgICAgbmV3IElmU3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3koeGhyX3N0cmVhbWluZ190cmFuc3BvcnQpLCB4aHJfc3RyZWFtaW5nX3RyYW5zcG9ydCwgeGRyX3N0cmVhbWluZ190cmFuc3BvcnQpLFxuICAgIF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgcG9sbGluZ19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFtcbiAgICAgICAgbmV3IElmU3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3koeGhyX3BvbGxpbmdfdHJhbnNwb3J0KSwgeGhyX3BvbGxpbmdfdHJhbnNwb3J0LCB4ZHJfcG9sbGluZ190cmFuc3BvcnQpLFxuICAgIF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgaHR0cF9sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3lfU2VxdWVudGlhbFN0cmF0ZWd5KFtcbiAgICAgICAgbmV3IElmU3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3koc3RyZWFtaW5nX2xvb3ApLCBuZXcgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5KFtcbiAgICAgICAgICAgIHN0cmVhbWluZ19sb29wLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3lfRGVsYXllZFN0cmF0ZWd5KHBvbGxpbmdfbG9vcCwgeyBkZWxheTogNDAwMCB9KSxcbiAgICAgICAgXSksIHBvbGxpbmdfbG9vcCksXG4gICAgXSwgdGltZW91dHMpO1xuICAgIHZhciBodHRwX2ZhbGxiYWNrX2xvb3AgPSBuZXcgSWZTdHJhdGVneSh0ZXN0U3VwcG9ydHNTdHJhdGVneShodHRwX2xvb3ApLCBodHRwX2xvb3AsIHNvY2tqc19sb29wKTtcbiAgICB2YXIgd3NTdHJhdGVneTtcbiAgICBpZiAoYmFzZU9wdGlvbnMudXNlVExTKSB7XG4gICAgICAgIHdzU3RyYXRlZ3kgPSBuZXcgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5KFtcbiAgICAgICAgICAgIHdzX2xvb3AsXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3koaHR0cF9mYWxsYmFja19sb29wLCB7IGRlbGF5OiAyMDAwIH0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdzU3RyYXRlZ3kgPSBuZXcgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneV9CZXN0Q29ubmVjdGVkRXZlclN0cmF0ZWd5KFtcbiAgICAgICAgICAgIHdzX2xvb3AsXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3kod3NzX2xvb3AsIHsgZGVsYXk6IDIwMDAgfSksXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneV9EZWxheWVkU3RyYXRlZ3koaHR0cF9mYWxsYmFja19sb29wLCB7IGRlbGF5OiA1MDAwIH0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB3ZWJzb2NrZXRfcHJpb3JpdGl6ZWRfY2FjaGVkX3N0cmF0ZWd5X1dlYlNvY2tldFByaW9yaXRpemVkQ2FjaGVkU3RyYXRlZ3kobmV3IEZpcnN0Q29ubmVjdGVkU3RyYXRlZ3kobmV3IElmU3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3kod3NfdHJhbnNwb3J0KSwgd3NTdHJhdGVneSwgaHR0cF9mYWxsYmFja19sb29wKSksIGRlZmluZWRUcmFuc3BvcnRzLCB7XG4gICAgICAgIHR0bDogMTgwMDAwMCxcbiAgICAgICAgdGltZWxpbmU6IGJhc2VPcHRpb25zLnRpbWVsaW5lLFxuICAgICAgICB1c2VUTFM6IGJhc2VPcHRpb25zLnVzZVRMUyxcbiAgICB9KTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWZhdWx0X3N0cmF0ZWd5ID0gKGdldERlZmF1bHRTdHJhdGVneSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi90cmFuc3BvcnRzL3RyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyLnRzXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi50aW1lbGluZS5pbmZvKHNlbGYuYnVpbGRUaW1lbGluZU1lc3NhZ2Uoe1xuICAgICAgICB0cmFuc3BvcnQ6IHNlbGYubmFtZSArIChzZWxmLm9wdGlvbnMudXNlVExTID8gJ3MnIDogJycpLFxuICAgIH0pKTtcbiAgICBpZiAoc2VsZi5ob29rcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgc2VsZi5jaGFuZ2VTdGF0ZSgnaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsZi5ob29rcy5maWxlKSB7XG4gICAgICAgIHNlbGYuY2hhbmdlU3RhdGUoJ2luaXRpYWxpemluZycpO1xuICAgICAgICBEZXBlbmRlbmNpZXMubG9hZChzZWxmLmhvb2tzLmZpbGUsIHsgdXNlVExTOiBzZWxmLm9wdGlvbnMudXNlVExTIH0sIGZ1bmN0aW9uIChlcnJvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmhvb2tzLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlU3RhdGUoJ2luaXRpYWxpemVkJyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgIH1cbn0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvaHR0cC9odHRwX3hkb21haW5fcmVxdWVzdC50c1xuXG52YXIgaHR0cF94ZG9tYWluX3JlcXVlc3RfaG9va3MgPSB7XG4gICAgZ2V0UmVxdWVzdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICB2YXIgeGRyID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgbmV3IFJlcXVlc3RUaW1lZE91dCgpKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh4ZHIucmVzcG9uc2VUZXh0ICYmIHhkci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbkNodW5rKDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhkci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoeGRyLnJlc3BvbnNlVGV4dCAmJiB4ZHIucmVzcG9uc2VUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQub25DaHVuaygyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2ZpbmlzaGVkJywgMjAwKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geGRyO1xuICAgIH0sXG4gICAgYWJvcnRSZXF1ZXN0OiBmdW5jdGlvbiAoeGRyKSB7XG4gICAgICAgIHhkci5vbnRpbWVvdXQgPSB4ZHIub25lcnJvciA9IHhkci5vbnByb2dyZXNzID0geGRyLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHhkci5hYm9ydCgpO1xuICAgIH0sXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF94ZG9tYWluX3JlcXVlc3QgPSAoaHR0cF94ZG9tYWluX3JlcXVlc3RfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9yZXF1ZXN0LnRzXG5cblxuY29uc3QgTUFYX0JVRkZFUl9MRU5HVEggPSAyNTYgKiAxMDI0O1xuY2xhc3MgaHR0cF9yZXF1ZXN0X0hUVFBSZXF1ZXN0IGV4dGVuZHMgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihob29rcywgbWV0aG9kLCB1cmwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxuICAgIHN0YXJ0KHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMueGhyID0gdGhpcy5ob29rcy5nZXRSZXF1ZXN0KHRoaXMpO1xuICAgICAgICB0aGlzLnVubG9hZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICBydW50aW1lLmFkZFVubG9hZExpc3RlbmVyKHRoaXMudW5sb2FkZXIpO1xuICAgICAgICB0aGlzLnhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQocGF5bG9hZCk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy51bmxvYWRlcikge1xuICAgICAgICAgICAgcnVudGltZS5yZW1vdmVVbmxvYWRMaXN0ZW5lcih0aGlzLnVubG9hZGVyKTtcbiAgICAgICAgICAgIHRoaXMudW5sb2FkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnhocikge1xuICAgICAgICAgICAgdGhpcy5ob29rcy5hYm9ydFJlcXVlc3QodGhpcy54aHIpO1xuICAgICAgICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2h1bmsoc3RhdHVzLCBkYXRhKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgY2h1bmsgPSB0aGlzLmFkdmFuY2VCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NodW5rJywgeyBzdGF0dXM6IHN0YXR1cywgZGF0YTogY2h1bmsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0J1ZmZlclRvb0xvbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnYnVmZmVyX3Rvb19sb25nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWR2YW5jZUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgdmFyIHVucmVhZERhdGEgPSBidWZmZXIuc2xpY2UodGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHZhciBlbmRPZkxpbmVQb3NpdGlvbiA9IHVucmVhZERhdGEuaW5kZXhPZignXFxuJyk7XG4gICAgICAgIGlmIChlbmRPZkxpbmVQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gZW5kT2ZMaW5lUG9zaXRpb24gKyAxO1xuICAgICAgICAgICAgcmV0dXJuIHVucmVhZERhdGEuc2xpY2UoMCwgZW5kT2ZMaW5lUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNCdWZmZXJUb29Mb25nKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gYnVmZmVyLmxlbmd0aCAmJiBidWZmZXIubGVuZ3RoID4gTUFYX0JVRkZFUl9MRU5HVEg7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvc3RhdGUudHNcbnZhciBTdGF0ZTtcbihmdW5jdGlvbiAoU3RhdGUpIHtcbiAgICBTdGF0ZVtTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BFTlwiXSA9IDFdID0gXCJPUEVOXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJDTE9TRURcIl0gPSAzXSA9IFwiQ0xPU0VEXCI7XG59KShTdGF0ZSB8fCAoU3RhdGUgPSB7fSkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3RhdGUgPSAoU3RhdGUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9zb2NrZXQudHNcblxuXG5cbnZhciBhdXRvSW5jcmVtZW50ID0gMTtcbmNsYXNzIGh0dHBfc29ja2V0X0hUVFBTb2NrZXQge1xuICAgIGNvbnN0cnVjdG9yKGhvb2tzLCB1cmwpIHtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSByYW5kb21OdW1iZXIoMTAwMCkgKyAnLycgKyByYW5kb21TdHJpbmcoOCk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBnZXRMb2NhdGlvbih1cmwpO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBzdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLm9wZW5TdHJlYW0oKTtcbiAgICB9XG4gICAgc2VuZChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRSYXcoSlNPTi5zdHJpbmdpZnkoW3BheWxvYWRdKSk7XG4gICAgfVxuICAgIHBpbmcoKSB7XG4gICAgICAgIHRoaXMuaG9va3Muc2VuZEhlYXJ0YmVhdCh0aGlzKTtcbiAgICB9XG4gICAgY2xvc2UoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMub25DbG9zZShjb2RlLCByZWFzb24sIHRydWUpO1xuICAgIH1cbiAgICBzZW5kUmF3KHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gc3RhdGUuT1BFTikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW50aW1lLmNyZWF0ZVNvY2tldFJlcXVlc3QoJ1BPU1QnLCBnZXRVbmlxdWVVUkwoZ2V0U2VuZFVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLnNlc3Npb24pKSkuc3RhcnQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgdGhpcy5vcGVuU3RyZWFtKCk7XG4gICAgfVxuICAgIG9uQ2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICAgICAgICB0aGlzLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IHN0YXRlLkNMT1NFRDtcbiAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgIHdhc0NsZWFuOiB3YXNDbGVhbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQ2h1bmsoY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gc3RhdGUuT1BFTikge1xuICAgICAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBheWxvYWQ7XG4gICAgICAgIHZhciB0eXBlID0gY2h1bmsuZGF0YS5zbGljZSgwLCAxKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICd7fScpO1xuICAgICAgICAgICAgICAgIHRoaXMub25PcGVuKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY2h1bmsuZGF0YS5zbGljZSgxKSB8fCAnW10nKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBheWxvYWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkV2ZW50KHBheWxvYWRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ251bGwnKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXZlbnQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhvb2tzLm9uSGVhcnRiZWF0KHRoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY2h1bmsuZGF0YS5zbGljZSgxKSB8fCAnW10nKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UocGF5bG9hZFswXSwgcGF5bG9hZFsxXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gc3RhdGUuQ09OTkVDVElORykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ob3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24uYmFzZSA9IHJlcGxhY2VIb3N0KHRoaXMubG9jYXRpb24uYmFzZSwgb3B0aW9ucy5ob3N0bmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBzdGF0ZS5PUEVOO1xuICAgICAgICAgICAgaWYgKHRoaXMub25vcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbm9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gc3RhdGUuT1BFTiAmJiB0aGlzLm9ubWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5vbm1lc3NhZ2UoeyBkYXRhOiBldmVudCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkFjdGl2aXR5KCkge1xuICAgICAgICBpZiAodGhpcy5vbmFjdGl2aXR5KSB7XG4gICAgICAgICAgICB0aGlzLm9uYWN0aXZpdHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLm9uZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMub25lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BlblN0cmVhbSgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBydW50aW1lLmNyZWF0ZVNvY2tldFJlcXVlc3QoJ1BPU1QnLCBnZXRVbmlxdWVVUkwodGhpcy5ob29rcy5nZXRSZWNlaXZlVVJMKHRoaXMubG9jYXRpb24sIHRoaXMuc2Vzc2lvbikpKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnY2h1bmsnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DaHVuayhjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5iaW5kKCdmaW5pc2hlZCcsIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaG9va3Mub25GaW5pc2hlZCh0aGlzLCBzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYmluZCgnYnVmZmVyX3Rvb19sb25nJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdXRpbC5kZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoMTAwNiwgJ0NvdWxkIG5vdCBzdGFydCBzdHJlYW1pbmcnLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZVN0cmVhbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS51bmJpbmRfYWxsKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TG9jYXRpb24odXJsKSB7XG4gICAgdmFyIHBhcnRzID0gLyhbXlxcP10qKVxcLyooXFw/Py4qKS8uZXhlYyh1cmwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2U6IHBhcnRzWzFdLFxuICAgICAgICBxdWVyeVN0cmluZzogcGFydHNbMl0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlbmRVUkwodXJsLCBzZXNzaW9uKSB7XG4gICAgcmV0dXJuIHVybC5iYXNlICsgJy8nICsgc2Vzc2lvbiArICcveGhyX3NlbmQnO1xufVxuZnVuY3Rpb24gZ2V0VW5pcXVlVVJMKHVybCkge1xuICAgIHZhciBzZXBhcmF0b3IgPSB1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJztcbiAgICByZXR1cm4gdXJsICsgc2VwYXJhdG9yICsgJ3Q9JyArICtuZXcgRGF0ZSgpICsgJyZuPScgKyBhdXRvSW5jcmVtZW50Kys7XG59XG5mdW5jdGlvbiByZXBsYWNlSG9zdCh1cmwsIGhvc3RuYW1lKSB7XG4gICAgdmFyIHVybFBhcnRzID0gLyhodHRwcz86XFwvXFwvKShbXlxcLzpdKykoKFxcL3w6KT8uKikvLmV4ZWModXJsKTtcbiAgICByZXR1cm4gdXJsUGFydHNbMV0gKyBob3N0bmFtZSArIHVybFBhcnRzWzNdO1xufVxuZnVuY3Rpb24gcmFuZG9tTnVtYmVyKG1heCkge1xuICAgIHJldHVybiBydW50aW1lLnJhbmRvbUludChtYXgpO1xufVxuZnVuY3Rpb24gcmFuZG9tU3RyaW5nKGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJhbmRvbU51bWJlcigzMikudG9TdHJpbmcoMzIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfc29ja2V0ID0gKGh0dHBfc29ja2V0X0hUVFBTb2NrZXQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9zdHJlYW1pbmdfc29ja2V0LnRzXG52YXIgaHR0cF9zdHJlYW1pbmdfc29ja2V0X2hvb2tzID0ge1xuICAgIGdldFJlY2VpdmVVUkw6IGZ1bmN0aW9uICh1cmwsIHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHVybC5iYXNlICsgJy8nICsgc2Vzc2lvbiArICcveGhyX3N0cmVhbWluZycgKyB1cmwucXVlcnlTdHJpbmc7XG4gICAgfSxcbiAgICBvbkhlYXJ0YmVhdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQuc2VuZFJhdygnW10nKTtcbiAgICB9LFxuICAgIHNlbmRIZWFydGJlYXQ6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0LnNlbmRSYXcoJ1tdJyk7XG4gICAgfSxcbiAgICBvbkZpbmlzaGVkOiBmdW5jdGlvbiAoc29ja2V0LCBzdGF0dXMpIHtcbiAgICAgICAgc29ja2V0Lm9uQ2xvc2UoMTAwNiwgJ0Nvbm5lY3Rpb24gaW50ZXJydXB0ZWQgKCcgKyBzdGF0dXMgKyAnKScsIGZhbHNlKTtcbiAgICB9LFxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfc3RyZWFtaW5nX3NvY2tldCA9IChodHRwX3N0cmVhbWluZ19zb2NrZXRfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9wb2xsaW5nX3NvY2tldC50c1xudmFyIGh0dHBfcG9sbGluZ19zb2NrZXRfaG9va3MgPSB7XG4gICAgZ2V0UmVjZWl2ZVVSTDogZnVuY3Rpb24gKHVybCwgc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gdXJsLmJhc2UgKyAnLycgKyBzZXNzaW9uICsgJy94aHInICsgdXJsLnF1ZXJ5U3RyaW5nO1xuICAgIH0sXG4gICAgb25IZWFydGJlYXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB9LFxuICAgIHNlbmRIZWFydGJlYXQ6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0LnNlbmRSYXcoJ1tdJyk7XG4gICAgfSxcbiAgICBvbkZpbmlzaGVkOiBmdW5jdGlvbiAoc29ja2V0LCBzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICBzb2NrZXQucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb2NrZXQub25DbG9zZSgxMDA2LCAnQ29ubmVjdGlvbiBpbnRlcnJ1cHRlZCAoJyArIHN0YXR1cyArICcpJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3BvbGxpbmdfc29ja2V0ID0gKGh0dHBfcG9sbGluZ19zb2NrZXRfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2h0dHAvaHR0cF94aHJfcmVxdWVzdC50c1xuXG52YXIgaHR0cF94aHJfcmVxdWVzdF9ob29rcyA9IHtcbiAgICBnZXRSZXF1ZXN0OiBmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHJ1bnRpbWUuZ2V0WEhSQVBJKCk7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZVRleHQgJiYgeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQub25DaHVuayh4aHIuc3RhdHVzLCB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUZXh0ICYmIHhoci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uQ2h1bmsoeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2ZpbmlzaGVkJywgeGhyLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9LFxuICAgIGFib3J0UmVxdWVzdDogZnVuY3Rpb24gKHhocikge1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgfSxcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3hocl9yZXF1ZXN0ID0gKGh0dHBfeGhyX3JlcXVlc3RfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2h0dHAvaHR0cC50c1xuXG5cblxuXG5cbnZhciBIVFRQID0ge1xuICAgIGNyZWF0ZVN0cmVhbWluZ1NvY2tldCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29ja2V0KGh0dHBfc3RyZWFtaW5nX3NvY2tldCwgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVBvbGxpbmdTb2NrZXQodXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvY2tldChodHRwX3BvbGxpbmdfc29ja2V0LCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlU29ja2V0KGhvb2tzLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwX3NvY2tldChob29rcywgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVhIUihtZXRob2QsIHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXF1ZXN0KGh0dHBfeGhyX3JlcXVlc3QsIG1ldGhvZCwgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVJlcXVlc3QoaG9va3MsIG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgaHR0cF9yZXF1ZXN0X0hUVFBSZXF1ZXN0KGhvb2tzLCBtZXRob2QsIHVybCk7XG4gICAgfSxcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX2h0dHAgPSAoSFRUUCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9odHRwL2h0dHAudHNcblxuXG5odHRwX2h0dHAuY3JlYXRlWERSID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVxdWVzdChodHRwX3hkb21haW5fcmVxdWVzdCwgbWV0aG9kLCB1cmwpO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHdlYl9odHRwX2h0dHAgPSAoaHR0cF9odHRwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL3J1bnRpbWUudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBSdW50aW1lID0ge1xuICAgIG5leHRBdXRoQ2FsbGJhY2tJRDogMSxcbiAgICBhdXRoX2NhbGxiYWNrczoge30sXG4gICAgU2NyaXB0UmVjZWl2ZXJzOiBTY3JpcHRSZWNlaXZlcnMsXG4gICAgRGVwZW5kZW5jaWVzUmVjZWl2ZXJzOiBEZXBlbmRlbmNpZXNSZWNlaXZlcnMsXG4gICAgZ2V0RGVmYXVsdFN0cmF0ZWd5OiBkZWZhdWx0X3N0cmF0ZWd5LFxuICAgIFRyYW5zcG9ydHM6IHRyYW5zcG9ydHNfdHJhbnNwb3J0cyxcbiAgICB0cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXI6IHRyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyLFxuICAgIEhUVFBGYWN0b3J5OiB3ZWJfaHR0cF9odHRwLFxuICAgIFRpbWVsaW5lVHJhbnNwb3J0OiBqc29ucF90aW1lbGluZSxcbiAgICBnZXRYSFJBUEkoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7XG4gICAgfSxcbiAgICBnZXRXZWJTb2NrZXRBUEkoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuV2ViU29ja2V0IHx8IHdpbmRvdy5Nb3pXZWJTb2NrZXQ7XG4gICAgfSxcbiAgICBzZXR1cChQdXNoZXJDbGFzcykge1xuICAgICAgICB3aW5kb3cuUHVzaGVyID0gUHVzaGVyQ2xhc3M7XG4gICAgICAgIHZhciBpbml0aWFsaXplT25Eb2N1bWVudEJvZHkgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRG9jdW1lbnRCb2R5KFB1c2hlckNsYXNzLnJlYWR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF3aW5kb3cuSlNPTikge1xuICAgICAgICAgICAgRGVwZW5kZW5jaWVzLmxvYWQoJ2pzb24yJywge30sIGluaXRpYWxpemVPbkRvY3VtZW50Qm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsaXplT25Eb2N1bWVudEJvZHkoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0RG9jdW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9LFxuICAgIGdldFByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREb2N1bWVudCgpLmxvY2F0aW9uLnByb3RvY29sO1xuICAgIH0sXG4gICAgZ2V0QXV0aG9yaXplcnMoKSB7XG4gICAgICAgIHJldHVybiB7IGFqYXg6IHhocl9hdXRoLCBqc29ucDoganNvbnBfYXV0aCB9O1xuICAgIH0sXG4gICAgb25Eb2N1bWVudEJvZHkoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRG9jdW1lbnRCb2R5KGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVKU09OUFJlcXVlc3QodXJsLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcganNvbnBfcmVxdWVzdF9KU09OUFJlcXVlc3QodXJsLCBkYXRhKTtcbiAgICB9LFxuICAgIGNyZWF0ZVNjcmlwdFJlcXVlc3Qoc3JjKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NyaXB0UmVxdWVzdChzcmMpO1xuICAgIH0sXG4gICAgZ2V0TG9jYWxTdG9yYWdlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVhIUigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0WEhSQVBJKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVNaWNyb3NvZnRYSFIoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlWE1MSHR0cFJlcXVlc3QoKSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0WEhSQVBJKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICB9LFxuICAgIGNyZWF0ZU1pY3Jvc29mdFhIUigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0sXG4gICAgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIG5ldF9pbmZvX05ldHdvcms7XG4gICAgfSxcbiAgICBjcmVhdGVXZWJTb2NrZXQodXJsKSB7XG4gICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXMuZ2V0V2ViU29ja2V0QVBJKCk7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IodXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVNvY2tldFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNYSFJTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSFRUUEZhY3RvcnkuY3JlYXRlWEhSKG1ldGhvZCwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzWERSU3VwcG9ydGVkKHVybC5pbmRleE9mKCdodHRwczonKSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkhUVFBGYWN0b3J5LmNyZWF0ZVhEUihtZXRob2QsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnQ3Jvc3Mtb3JpZ2luIEhUVFAgcmVxdWVzdHMgYXJlIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBpc1hIUlN1cHBvcnRlZCgpIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcy5nZXRYSFJBUEkoKTtcbiAgICAgICAgcmV0dXJuIChCb29sZWFuKENvbnN0cnVjdG9yKSAmJiBuZXcgQ29uc3RydWN0b3IoKS53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpc1hEUlN1cHBvcnRlZCh1c2VUTFMpIHtcbiAgICAgICAgdmFyIHByb3RvY29sID0gdXNlVExTID8gJ2h0dHBzOicgOiAnaHR0cDonO1xuICAgICAgICB2YXIgZG9jdW1lbnRQcm90b2NvbCA9IHRoaXMuZ2V0UHJvdG9jb2woKTtcbiAgICAgICAgcmV0dXJuIChCb29sZWFuKHdpbmRvd1snWERvbWFpblJlcXVlc3QnXSkgJiYgZG9jdW1lbnRQcm90b2NvbCA9PT0gcHJvdG9jb2wpO1xuICAgIH0sXG4gICAgYWRkVW5sb2FkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmxvYWQnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHdpbmRvdy5hdHRhY2hFdmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVVbmxvYWRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2luZG93LmRldGFjaEV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5kZXRhY2hFdmVudCgnb251bmxvYWQnLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJhbmRvbUludChtYXgpIHtcbiAgICAgICAgY29uc3QgcmFuZG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgY3J5cHRvID0gd2luZG93LmNyeXB0byB8fCB3aW5kb3dbJ21zQ3J5cHRvJ107XG4gICAgICAgICAgICBjb25zdCByYW5kb20gPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tIC8gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyYW5kb20oKSAqIG1heCk7XG4gICAgfSxcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBydW50aW1lID0gKFJ1bnRpbWUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RpbWVsaW5lL2xldmVsLnRzXG52YXIgVGltZWxpbmVMZXZlbDtcbihmdW5jdGlvbiAoVGltZWxpbmVMZXZlbCkge1xuICAgIFRpbWVsaW5lTGV2ZWxbVGltZWxpbmVMZXZlbFtcIkVSUk9SXCJdID0gM10gPSBcIkVSUk9SXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiSU5GT1wiXSA9IDZdID0gXCJJTkZPXCI7XG4gICAgVGltZWxpbmVMZXZlbFtUaW1lbGluZUxldmVsW1wiREVCVUdcIl0gPSA3XSA9IFwiREVCVUdcIjtcbn0pKFRpbWVsaW5lTGV2ZWwgfHwgKFRpbWVsaW5lTGV2ZWwgPSB7fSkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGltZWxpbmVfbGV2ZWwgPSAoVGltZWxpbmVMZXZlbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdGltZWxpbmUvdGltZWxpbmUudHNcblxuXG5cbmNsYXNzIHRpbWVsaW5lX1RpbWVsaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuc2VudCA9IDA7XG4gICAgICAgIHRoaXMudW5pcXVlSUQgPSAwO1xuICAgIH1cbiAgICBsb2cobGV2ZWwsIGV2ZW50KSB7XG4gICAgICAgIGlmIChsZXZlbCA8PSB0aGlzLm9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXh0ZW5kKHt9LCBldmVudCwgeyB0aW1lc3RhbXA6IHV0aWwubm93KCkgfSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW1pdCAmJiB0aGlzLmV2ZW50cy5sZW5ndGggPiB0aGlzLm9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVycm9yKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nKHRpbWVsaW5lX2xldmVsLkVSUk9SLCBldmVudCk7XG4gICAgfVxuICAgIGluZm8oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2codGltZWxpbmVfbGV2ZWwuSU5GTywgZXZlbnQpO1xuICAgIH1cbiAgICBkZWJ1ZyhldmVudCkge1xuICAgICAgICB0aGlzLmxvZyh0aW1lbGluZV9sZXZlbC5ERUJVRywgZXZlbnQpO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBzZW5kKHNlbmRmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRhdGEgPSBleHRlbmQoe1xuICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5zZXNzaW9uLFxuICAgICAgICAgICAgYnVuZGxlOiB0aGlzLnNlbnQgKyAxLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGxpYjogJ2pzJyxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMub3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5vcHRpb25zLmNsdXN0ZXIsXG4gICAgICAgICAgICBmZWF0dXJlczogdGhpcy5vcHRpb25zLmZlYXR1cmVzLFxuICAgICAgICAgICAgdGltZWxpbmU6IHRoaXMuZXZlbnRzLFxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgc2VuZGZuKGRhdGEsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZW5lcmF0ZVVuaXF1ZUlEKCkge1xuICAgICAgICB0aGlzLnVuaXF1ZUlEKys7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaXF1ZUlEO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL3RyYW5zcG9ydF9zdHJhdGVneS50c1xuXG5cblxuXG5jbGFzcyB0cmFuc3BvcnRfc3RyYXRlZ3lfVHJhbnNwb3J0U3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHByaW9yaXR5LCB0cmFuc3BvcnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB9XG4gICAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5pc1N1cHBvcnRlZCh7XG4gICAgICAgICAgICB1c2VUTFM6IHRoaXMub3B0aW9ucy51c2VUTFMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWxBdHRlbXB0KG5ldyBVbnN1cHBvcnRlZFN0cmF0ZWd5KCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByaW9yaXR5IDwgbWluUHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsQXR0ZW1wdChuZXcgVHJhbnNwb3J0UHJpb3JpdHlUb29Mb3coKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0LmNyZWF0ZUNvbm5lY3Rpb24odGhpcy5uYW1lLCB0aGlzLnByaW9yaXR5LCB0aGlzLm9wdGlvbnMua2V5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB2YXIgaGFuZHNoYWtlID0gbnVsbDtcbiAgICAgICAgdmFyIG9uSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdpbml0aWFsaXplZCcsIG9uSW5pdGlhbGl6ZWQpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhhbmRzaGFrZSA9IGZhY3RvcnkuY3JlYXRlSGFuZHNoYWtlKHRyYW5zcG9ydCwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRUcmFuc3BvcnQ7XG4gICAgICAgICAgICBzZXJpYWxpemVkVHJhbnNwb3J0ID0gc2FmZUpTT05TdHJpbmdpZnkodHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBUcmFuc3BvcnRDbG9zZWQoc2VyaWFsaXplZFRyYW5zcG9ydCkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdW5iaW5kTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnaW5pdGlhbGl6ZWQnLCBvbkluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2Nsb3NlZCcsIG9uQ2xvc2VkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNwb3J0LmJpbmQoJ2luaXRpYWxpemVkJywgb25Jbml0aWFsaXplZCk7XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgdHJhbnNwb3J0LmJpbmQoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgIHRyYW5zcG9ydC5pbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IChwKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByaW9yaXR5IDwgcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kc2hha2UuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBmYWlsQXR0ZW1wdChlcnJvciwgY2FsbGJhY2spIHtcbiAgICB1dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICB9O1xufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3N0cmF0ZWdpZXMvc3RyYXRlZ3lfYnVpbGRlci50c1xuXG5cblxuXG5cbmNvbnN0IHsgVHJhbnNwb3J0czogc3RyYXRlZ3lfYnVpbGRlcl9UcmFuc3BvcnRzIH0gPSBydW50aW1lO1xudmFyIHN0cmF0ZWd5X2J1aWxkZXJfZGVmaW5lVHJhbnNwb3J0ID0gZnVuY3Rpb24gKGNvbmZpZywgbmFtZSwgdHlwZSwgcHJpb3JpdHksIG9wdGlvbnMsIG1hbmFnZXIpIHtcbiAgICB2YXIgdHJhbnNwb3J0Q2xhc3MgPSBzdHJhdGVneV9idWlsZGVyX1RyYW5zcG9ydHNbdHlwZV07XG4gICAgaWYgKCF0cmFuc3BvcnRDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUcmFuc3BvcnQodHlwZSk7XG4gICAgfVxuICAgIHZhciBlbmFibGVkID0gKCFjb25maWcuZW5hYmxlZFRyYW5zcG9ydHMgfHxcbiAgICAgICAgYXJyYXlJbmRleE9mKGNvbmZpZy5lbmFibGVkVHJhbnNwb3J0cywgbmFtZSkgIT09IC0xKSAmJlxuICAgICAgICAoIWNvbmZpZy5kaXNhYmxlZFRyYW5zcG9ydHMgfHxcbiAgICAgICAgICAgIGFycmF5SW5kZXhPZihjb25maWcuZGlzYWJsZWRUcmFuc3BvcnRzLCBuYW1lKSA9PT0gLTEpO1xuICAgIHZhciB0cmFuc3BvcnQ7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBpZ25vcmVOdWxsT3JpZ2luOiBjb25maWcuaWdub3JlTnVsbE9yaWdpbiB9LCBvcHRpb25zKTtcbiAgICAgICAgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydF9zdHJhdGVneV9UcmFuc3BvcnRTdHJhdGVneShuYW1lLCBwcmlvcml0eSwgbWFuYWdlciA/IG1hbmFnZXIuZ2V0QXNzaXN0YW50KHRyYW5zcG9ydENsYXNzKSA6IHRyYW5zcG9ydENsYXNzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyYW5zcG9ydCA9IHN0cmF0ZWd5X2J1aWxkZXJfVW5zdXBwb3J0ZWRTdHJhdGVneTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG52YXIgc3RyYXRlZ3lfYnVpbGRlcl9VbnN1cHBvcnRlZFN0cmF0ZWd5ID0ge1xuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNvbm5lY3Q6IGZ1bmN0aW9uIChfLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBVbnN1cHBvcnRlZFN0cmF0ZWd5KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9vcHRpb25zLnRzXG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyAnWW91IG11c3QgcGFzcyBhbiBvcHRpb25zIG9iamVjdCc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNsdXN0ZXIgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyAnT3B0aW9ucyBvYmplY3QgbXVzdCBwcm92aWRlIGEgY2x1c3Rlcic7XG4gICAgfVxuICAgIGlmICgnZGlzYWJsZVN0YXRzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdUaGUgZGlzYWJsZVN0YXRzIG9wdGlvbiBpcyBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGVuYWJsZVN0YXRzJyk7XG4gICAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvdXNlcl9hdXRoZW50aWNhdG9yLnRzXG5cblxuY29uc3QgY29tcG9zZUNoYW5uZWxRdWVyeSA9IChwYXJhbXMsIGF1dGhPcHRpb25zKSA9PiB7XG4gICAgdmFyIHF1ZXJ5ID0gJ3NvY2tldF9pZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zb2NrZXRJZCk7XG4gICAgZm9yICh2YXIga2V5IGluIGF1dGhPcHRpb25zLnBhcmFtcykge1xuICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoYXV0aE9wdGlvbnMucGFyYW1zW2tleV0pO1xuICAgIH1cbiAgICBpZiAoYXV0aE9wdGlvbnMucGFyYW1zUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICBsZXQgZHluYW1pY1BhcmFtcyA9IGF1dGhPcHRpb25zLnBhcmFtc1Byb3ZpZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkeW5hbWljUGFyYW1zKSB7XG4gICAgICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGR5bmFtaWNQYXJhbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xufTtcbmNvbnN0IFVzZXJBdXRoZW50aWNhdG9yID0gKGF1dGhPcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgYCcke2F1dGhPcHRpb25zLnRyYW5zcG9ydH0nIGlzIG5vdCBhIHJlY29nbml6ZWQgYXV0aCB0cmFuc3BvcnRgO1xuICAgIH1cbiAgICByZXR1cm4gKHBhcmFtcywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBjb21wb3NlQ2hhbm5lbFF1ZXJ5KHBhcmFtcywgYXV0aE9wdGlvbnMpO1xuICAgICAgICBydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XShydW50aW1lLCBxdWVyeSwgYXV0aE9wdGlvbnMsIEF1dGhSZXF1ZXN0VHlwZS5Vc2VyQXV0aGVudGljYXRpb24sIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHVzZXJfYXV0aGVudGljYXRvciA9IChVc2VyQXV0aGVudGljYXRvcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvYXV0aC9jaGFubmVsX2F1dGhvcml6ZXIudHNcblxuXG5jb25zdCBjaGFubmVsX2F1dGhvcml6ZXJfY29tcG9zZUNoYW5uZWxRdWVyeSA9IChwYXJhbXMsIGF1dGhPcHRpb25zKSA9PiB7XG4gICAgdmFyIHF1ZXJ5ID0gJ3NvY2tldF9pZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zb2NrZXRJZCk7XG4gICAgcXVlcnkgKz0gJyZjaGFubmVsX25hbWU9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY2hhbm5lbE5hbWUpO1xuICAgIGZvciAodmFyIGtleSBpbiBhdXRoT3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgcXVlcnkgKz1cbiAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgK1xuICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGF1dGhPcHRpb25zLnBhcmFtc1trZXldKTtcbiAgICB9XG4gICAgaWYgKGF1dGhPcHRpb25zLnBhcmFtc1Byb3ZpZGVyICE9IG51bGwpIHtcbiAgICAgICAgbGV0IGR5bmFtaWNQYXJhbXMgPSBhdXRoT3B0aW9ucy5wYXJhbXNQcm92aWRlcigpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZHluYW1pY1BhcmFtcykge1xuICAgICAgICAgICAgcXVlcnkgKz1cbiAgICAgICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChkeW5hbWljUGFyYW1zW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbn07XG5jb25zdCBDaGFubmVsQXV0aG9yaXplciA9IChhdXRoT3B0aW9ucykgPT4ge1xuICAgIGlmICh0eXBlb2YgcnVudGltZS5nZXRBdXRob3JpemVycygpW2F1dGhPcHRpb25zLnRyYW5zcG9ydF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IGAnJHthdXRoT3B0aW9ucy50cmFuc3BvcnR9JyBpcyBub3QgYSByZWNvZ25pemVkIGF1dGggdHJhbnNwb3J0YDtcbiAgICB9XG4gICAgcmV0dXJuIChwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gY2hhbm5lbF9hdXRob3JpemVyX2NvbXBvc2VDaGFubmVsUXVlcnkocGFyYW1zLCBhdXRoT3B0aW9ucyk7XG4gICAgICAgIHJ1bnRpbWUuZ2V0QXV0aG9yaXplcnMoKVthdXRoT3B0aW9ucy50cmFuc3BvcnRdKHJ1bnRpbWUsIHF1ZXJ5LCBhdXRoT3B0aW9ucywgQXV0aFJlcXVlc3RUeXBlLkNoYW5uZWxBdXRob3JpemF0aW9uLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjaGFubmVsX2F1dGhvcml6ZXIgPSAoQ2hhbm5lbEF1dGhvcml6ZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvZGVwcmVjYXRlZF9jaGFubmVsX2F1dGhvcml6ZXIudHNcbmNvbnN0IENoYW5uZWxBdXRob3JpemVyUHJveHkgPSAocHVzaGVyLCBhdXRoT3B0aW9ucywgY2hhbm5lbEF1dGhvcml6ZXJHZW5lcmF0b3IpID0+IHtcbiAgICBjb25zdCBkZXByZWNhdGVkQXV0aG9yaXplck9wdGlvbnMgPSB7XG4gICAgICAgIGF1dGhUcmFuc3BvcnQ6IGF1dGhPcHRpb25zLnRyYW5zcG9ydCxcbiAgICAgICAgYXV0aEVuZHBvaW50OiBhdXRoT3B0aW9ucy5lbmRwb2ludCxcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgcGFyYW1zOiBhdXRoT3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICBoZWFkZXJzOiBhdXRoT3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIChwYXJhbXMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBwdXNoZXIuY2hhbm5lbChwYXJhbXMuY2hhbm5lbE5hbWUpO1xuICAgICAgICBjb25zdCBjaGFubmVsQXV0aG9yaXplciA9IGNoYW5uZWxBdXRob3JpemVyR2VuZXJhdG9yKGNoYW5uZWwsIGRlcHJlY2F0ZWRBdXRob3JpemVyT3B0aW9ucyk7XG4gICAgICAgIGNoYW5uZWxBdXRob3JpemVyLmF1dGhvcml6ZShwYXJhbXMuc29ja2V0SWQsIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25maWcudHNcblxuXG5cblxuXG5mdW5jdGlvbiBnZXRDb25maWcob3B0cywgcHVzaGVyKSB7XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgYWN0aXZpdHlUaW1lb3V0OiBvcHRzLmFjdGl2aXR5VGltZW91dCB8fCBkZWZhdWx0cy5hY3Rpdml0eVRpbWVvdXQsXG4gICAgICAgIGNsdXN0ZXI6IG9wdHMuY2x1c3RlcixcbiAgICAgICAgaHR0cFBhdGg6IG9wdHMuaHR0cFBhdGggfHwgZGVmYXVsdHMuaHR0cFBhdGgsXG4gICAgICAgIGh0dHBQb3J0OiBvcHRzLmh0dHBQb3J0IHx8IGRlZmF1bHRzLmh0dHBQb3J0LFxuICAgICAgICBodHRwc1BvcnQ6IG9wdHMuaHR0cHNQb3J0IHx8IGRlZmF1bHRzLmh0dHBzUG9ydCxcbiAgICAgICAgcG9uZ1RpbWVvdXQ6IG9wdHMucG9uZ1RpbWVvdXQgfHwgZGVmYXVsdHMucG9uZ1RpbWVvdXQsXG4gICAgICAgIHN0YXRzSG9zdDogb3B0cy5zdGF0c0hvc3QgfHwgZGVmYXVsdHMuc3RhdHNfaG9zdCxcbiAgICAgICAgdW5hdmFpbGFibGVUaW1lb3V0OiBvcHRzLnVuYXZhaWxhYmxlVGltZW91dCB8fCBkZWZhdWx0cy51bmF2YWlsYWJsZVRpbWVvdXQsXG4gICAgICAgIHdzUGF0aDogb3B0cy53c1BhdGggfHwgZGVmYXVsdHMud3NQYXRoLFxuICAgICAgICB3c1BvcnQ6IG9wdHMud3NQb3J0IHx8IGRlZmF1bHRzLndzUG9ydCxcbiAgICAgICAgd3NzUG9ydDogb3B0cy53c3NQb3J0IHx8IGRlZmF1bHRzLndzc1BvcnQsXG4gICAgICAgIGVuYWJsZVN0YXRzOiBnZXRFbmFibGVTdGF0c0NvbmZpZyhvcHRzKSxcbiAgICAgICAgaHR0cEhvc3Q6IGdldEh0dHBIb3N0KG9wdHMpLFxuICAgICAgICB1c2VUTFM6IHNob3VsZFVzZVRMUyhvcHRzKSxcbiAgICAgICAgd3NIb3N0OiBnZXRXZWJzb2NrZXRIb3N0KG9wdHMpLFxuICAgICAgICB1c2VyQXV0aGVudGljYXRvcjogYnVpbGRVc2VyQXV0aGVudGljYXRvcihvcHRzKSxcbiAgICAgICAgY2hhbm5lbEF1dGhvcml6ZXI6IGJ1aWxkQ2hhbm5lbEF1dGhvcml6ZXIob3B0cywgcHVzaGVyKSxcbiAgICB9O1xuICAgIGlmICgnZGlzYWJsZWRUcmFuc3BvcnRzJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcuZGlzYWJsZWRUcmFuc3BvcnRzID0gb3B0cy5kaXNhYmxlZFRyYW5zcG9ydHM7XG4gICAgaWYgKCdlbmFibGVkVHJhbnNwb3J0cycgaW4gb3B0cylcbiAgICAgICAgY29uZmlnLmVuYWJsZWRUcmFuc3BvcnRzID0gb3B0cy5lbmFibGVkVHJhbnNwb3J0cztcbiAgICBpZiAoJ2lnbm9yZU51bGxPcmlnaW4nIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy5pZ25vcmVOdWxsT3JpZ2luID0gb3B0cy5pZ25vcmVOdWxsT3JpZ2luO1xuICAgIGlmICgndGltZWxpbmVQYXJhbXMnIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy50aW1lbGluZVBhcmFtcyA9IG9wdHMudGltZWxpbmVQYXJhbXM7XG4gICAgaWYgKCduYWNsJyBpbiBvcHRzKSB7XG4gICAgICAgIGNvbmZpZy5uYWNsID0gb3B0cy5uYWNsO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gZ2V0SHR0cEhvc3Qob3B0cykge1xuICAgIGlmIChvcHRzLmh0dHBIb3N0KSB7XG4gICAgICAgIHJldHVybiBvcHRzLmh0dHBIb3N0O1xuICAgIH1cbiAgICBpZiAob3B0cy5jbHVzdGVyKSB7XG4gICAgICAgIHJldHVybiBgc29ja2pzLSR7b3B0cy5jbHVzdGVyfS5wdXNoZXIuY29tYDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzLmh0dHBIb3N0O1xufVxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0SG9zdChvcHRzKSB7XG4gICAgaWYgKG9wdHMud3NIb3N0KSB7XG4gICAgICAgIHJldHVybiBvcHRzLndzSG9zdDtcbiAgICB9XG4gICAgcmV0dXJuIGdldFdlYnNvY2tldEhvc3RGcm9tQ2x1c3RlcihvcHRzLmNsdXN0ZXIpO1xufVxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0SG9zdEZyb21DbHVzdGVyKGNsdXN0ZXIpIHtcbiAgICByZXR1cm4gYHdzLSR7Y2x1c3Rlcn0ucHVzaGVyLmNvbWA7XG59XG5mdW5jdGlvbiBzaG91bGRVc2VUTFMob3B0cykge1xuICAgIGlmIChydW50aW1lLmdldFByb3RvY29sKCkgPT09ICdodHRwczonKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRzLmZvcmNlVExTID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0RW5hYmxlU3RhdHNDb25maWcob3B0cykge1xuICAgIGlmICgnZW5hYmxlU3RhdHMnIGluIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIG9wdHMuZW5hYmxlU3RhdHM7XG4gICAgfVxuICAgIGlmICgnZGlzYWJsZVN0YXRzJyBpbiBvcHRzKSB7XG4gICAgICAgIHJldHVybiAhb3B0cy5kaXNhYmxlU3RhdHM7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVXNlckF1dGhlbnRpY2F0b3Iob3B0cykge1xuICAgIGNvbnN0IHVzZXJBdXRoZW50aWNhdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMudXNlckF1dGhlbnRpY2F0aW9uKSwgb3B0cy51c2VyQXV0aGVudGljYXRpb24pO1xuICAgIGlmICgnY3VzdG9tSGFuZGxlcicgaW4gdXNlckF1dGhlbnRpY2F0aW9uICYmXG4gICAgICAgIHVzZXJBdXRoZW50aWNhdGlvblsnY3VzdG9tSGFuZGxlciddICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJBdXRoZW50aWNhdGlvblsnY3VzdG9tSGFuZGxlciddO1xuICAgIH1cbiAgICByZXR1cm4gdXNlcl9hdXRoZW50aWNhdG9yKHVzZXJBdXRoZW50aWNhdGlvbik7XG59XG5mdW5jdGlvbiBidWlsZENoYW5uZWxBdXRoKG9wdHMsIHB1c2hlcikge1xuICAgIGxldCBjaGFubmVsQXV0aG9yaXphdGlvbjtcbiAgICBpZiAoJ2NoYW5uZWxBdXRob3JpemF0aW9uJyBpbiBvcHRzKSB7XG4gICAgICAgIGNoYW5uZWxBdXRob3JpemF0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cy5jaGFubmVsQXV0aG9yaXphdGlvbiksIG9wdHMuY2hhbm5lbEF1dGhvcml6YXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24gPSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQ6IG9wdHMuYXV0aFRyYW5zcG9ydCB8fCBkZWZhdWx0cy5hdXRoVHJhbnNwb3J0LFxuICAgICAgICAgICAgZW5kcG9pbnQ6IG9wdHMuYXV0aEVuZHBvaW50IHx8IGRlZmF1bHRzLmF1dGhFbmRwb2ludCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCdhdXRoJyBpbiBvcHRzKSB7XG4gICAgICAgICAgICBpZiAoJ3BhcmFtcycgaW4gb3B0cy5hdXRoKVxuICAgICAgICAgICAgICAgIGNoYW5uZWxBdXRob3JpemF0aW9uLnBhcmFtcyA9IG9wdHMuYXV0aC5wYXJhbXM7XG4gICAgICAgICAgICBpZiAoJ2hlYWRlcnMnIGluIG9wdHMuYXV0aClcbiAgICAgICAgICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbi5oZWFkZXJzID0gb3B0cy5hdXRoLmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdhdXRob3JpemVyJyBpbiBvcHRzKVxuICAgICAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24uY3VzdG9tSGFuZGxlciA9IENoYW5uZWxBdXRob3JpemVyUHJveHkocHVzaGVyLCBjaGFubmVsQXV0aG9yaXphdGlvbiwgb3B0cy5hdXRob3JpemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxBdXRob3JpemF0aW9uO1xufVxuZnVuY3Rpb24gYnVpbGRDaGFubmVsQXV0aG9yaXplcihvcHRzLCBwdXNoZXIpIHtcbiAgICBjb25zdCBjaGFubmVsQXV0aG9yaXphdGlvbiA9IGJ1aWxkQ2hhbm5lbEF1dGgob3B0cywgcHVzaGVyKTtcbiAgICBpZiAoJ2N1c3RvbUhhbmRsZXInIGluIGNoYW5uZWxBdXRob3JpemF0aW9uICYmXG4gICAgICAgIGNoYW5uZWxBdXRob3JpemF0aW9uWydjdXN0b21IYW5kbGVyJ10gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2hhbm5lbEF1dGhvcml6YXRpb25bJ2N1c3RvbUhhbmRsZXInXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxfYXV0aG9yaXplcihjaGFubmVsQXV0aG9yaXphdGlvbik7XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvd2F0Y2hsaXN0LnRzXG5cblxuY2xhc3Mgd2F0Y2hsaXN0X1dhdGNobGlzdEZhY2FkZSBleHRlbmRzIGRpc3BhdGNoZXJfRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocHVzaGVyKSB7XG4gICAgICAgIHN1cGVyKGZ1bmN0aW9uIChldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTm8gY2FsbGJhY2tzIG9uIHdhdGNobGlzdCBldmVudHMgZm9yICR7ZXZlbnROYW1lfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wdXNoZXIgPSBwdXNoZXI7XG4gICAgICAgIHRoaXMuYmluZFdhdGNobGlzdEludGVybmFsRXZlbnQoKTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQocHVzaGVyRXZlbnQpIHtcbiAgICAgICAgcHVzaGVyRXZlbnQuZGF0YS5ldmVudHMuZm9yRWFjaCgod2F0Y2hsaXN0RXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCh3YXRjaGxpc3RFdmVudC5uYW1lLCB3YXRjaGxpc3RFdmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBiaW5kV2F0Y2hsaXN0SW50ZXJuYWxFdmVudCgpIHtcbiAgICAgICAgdGhpcy5wdXNoZXIuY29ubmVjdGlvbi5iaW5kKCdtZXNzYWdlJywgKHB1c2hlckV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gcHVzaGVyRXZlbnQuZXZlbnQ7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAncHVzaGVyX2ludGVybmFsOndhdGNobGlzdF9ldmVudHMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFdmVudChwdXNoZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy9mbGF0X3Byb21pc2UudHNcbmZ1bmN0aW9uIGZsYXRQcm9taXNlKCkge1xuICAgIGxldCByZXNvbHZlLCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH07XG59XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmbGF0X3Byb21pc2UgPSAoZmxhdFByb21pc2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3VzZXIudHNcblxuXG5cblxuXG5jbGFzcyB1c2VyX1VzZXJGYWNhZGUgZXh0ZW5kcyBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHB1c2hlcikge1xuICAgICAgICBzdXBlcihmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ05vIGNhbGxiYWNrcyBvbiB1c2VyIGZvciAnICsgZXZlbnROYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVzZXJfZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2lnbmluRG9uZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zaWduaW5Eb25lUmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uQXV0aG9yaXplID0gKGVyciwgYXV0aERhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3IgZHVyaW5nIHNpZ25pbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjpzaWduaW4nLCB7XG4gICAgICAgICAgICAgICAgYXV0aDogYXV0aERhdGEuYXV0aCxcbiAgICAgICAgICAgICAgICB1c2VyX2RhdGE6IGF1dGhEYXRhLnVzZXJfZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnB1c2hlciA9IHB1c2hlcjtcbiAgICAgICAgdGhpcy5wdXNoZXIuY29ubmVjdGlvbi5iaW5kKCdzdGF0ZV9jaGFuZ2UnLCAoeyBwcmV2aW91cywgY3VycmVudCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMgIT09ICdjb25uZWN0ZWQnICYmIGN1cnJlbnQgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2lnbmluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldmlvdXMgPT09ICdjb25uZWN0ZWQnICYmIGN1cnJlbnQgIT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53YXRjaGxpc3QgPSBuZXcgd2F0Y2hsaXN0X1dhdGNobGlzdEZhY2FkZShwdXNoZXIpO1xuICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXI6c2lnbmluX3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TaWduaW5TdWNjZXNzKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5uYW1lID09PSBldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25pbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmluX3JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NpZ25pbigpO1xuICAgIH1cbiAgICBfc2lnbmluKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpO1xuICAgICAgICBpZiAodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hlci5jb25maWcudXNlckF1dGhlbnRpY2F0b3Ioe1xuICAgICAgICAgICAgc29ja2V0SWQ6IHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkLFxuICAgICAgICB9LCB0aGlzLl9vbkF1dGhvcml6ZSk7XG4gICAgfVxuICAgIF9vblNpZ25pblN1Y2Nlc3MoZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51c2VyX2RhdGEgPSBKU09OLnBhcnNlKGRhdGEudXNlcl9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgcGFyc2luZyB1c2VyIGRhdGEgYWZ0ZXIgc2lnbmluOiAke2RhdGEudXNlcl9kYXRhfWApO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy51c2VyX2RhdGEuaWQgIT09ICdzdHJpbmcnIHx8IHRoaXMudXNlcl9kYXRhLmlkID09PSAnJykge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGB1c2VyX2RhdGEgZG9lc24ndCBjb250YWluIGFuIGlkLiB1c2VyX2RhdGE6ICR7dGhpcy51c2VyX2RhdGF9YCk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2lnbmluRG9uZVJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlQ2hhbm5lbHMoKTtcbiAgICB9XG4gICAgX3N1YnNjcmliZUNoYW5uZWxzKCkge1xuICAgICAgICBjb25zdCBlbnN1cmVfc3Vic2NyaWJlZCA9IChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5yZWluc3RhdGVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hlci5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG5ldyBjaGFubmVsX0NoYW5uZWwoYCNzZXJ2ZXItdG8tdXNlci0ke3RoaXMudXNlcl9kYXRhLmlkfWAsIHRoaXMucHVzaGVyKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmJpbmRfZ2xvYmFsKChldmVudE5hbWUsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwIHx8XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgZW5zdXJlX3N1YnNjcmliZWQodGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsKTtcbiAgICB9XG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIHRoaXMudXNlcl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLnVuYmluZF9hbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlclRvVXNlckNoYW5uZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaWduaW5Eb25lUHJvbWlzZSAmJiAhdGhpcy5zaWduaW5Eb25lUHJvbWlzZS5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3Q6IF8gfSA9IGZsYXRfcHJvbWlzZSgpO1xuICAgICAgICBwcm9taXNlLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc2V0RG9uZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UuZG9uZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHByb21pc2UudGhlbihzZXREb25lKS5jYXRjaChzZXREb25lKTtcbiAgICAgICAgdGhpcy5zaWduaW5Eb25lUHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvcHVzaGVyLnRzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIHB1c2hlcl9QdXNoZXIge1xuICAgIHN0YXRpYyByZWFkeSgpIHtcbiAgICAgICAgcHVzaGVyX1B1c2hlci5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwdXNoZXJfUHVzaGVyLmluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzW2ldLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q2xpZW50RmVhdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGZpbHRlck9iamVjdCh7IHdzOiBydW50aW1lLlRyYW5zcG9ydHMud3MgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmlzU3VwcG9ydGVkKHt9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhcHBfa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIGNoZWNrQXBwS2V5KGFwcF9rZXkpO1xuICAgICAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMua2V5ID0gYXBwX2tleTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBnZXRDb25maWcob3B0aW9ucywgdGhpcyk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBmYWN0b3J5LmNyZWF0ZUNoYW5uZWxzKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIgPSBuZXcgZGlzcGF0Y2hlcl9EaXNwYXRjaGVyKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbklEID0gcnVudGltZS5yYW5kb21JbnQoMTAwMDAwMDAwMCk7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSBuZXcgdGltZWxpbmVfVGltZWxpbmUodGhpcy5rZXksIHRoaXMuc2Vzc2lvbklELCB7XG4gICAgICAgICAgICBjbHVzdGVyOiB0aGlzLmNvbmZpZy5jbHVzdGVyLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHB1c2hlcl9QdXNoZXIuZ2V0Q2xpZW50RmVhdHVyZXMoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy5jb25maWcudGltZWxpbmVQYXJhbXMgfHwge30sXG4gICAgICAgICAgICBsaW1pdDogNTAsXG4gICAgICAgICAgICBsZXZlbDogdGltZWxpbmVfbGV2ZWwuSU5GTyxcbiAgICAgICAgICAgIHZlcnNpb246IGRlZmF1bHRzLlZFUlNJT04sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlU3RhdHMpIHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXIgPSBmYWN0b3J5LmNyZWF0ZVRpbWVsaW5lU2VuZGVyKHRoaXMudGltZWxpbmUsIHtcbiAgICAgICAgICAgICAgICBob3N0OiB0aGlzLmNvbmZpZy5zdGF0c0hvc3QsXG4gICAgICAgICAgICAgICAgcGF0aDogJy90aW1lbGluZS92Mi8nICsgcnVudGltZS5UaW1lbGluZVRyYW5zcG9ydC5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdldFN0cmF0ZWd5ID0gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBydW50aW1lLmdldERlZmF1bHRTdHJhdGVneSh0aGlzLmNvbmZpZywgb3B0aW9ucywgc3RyYXRlZ3lfYnVpbGRlcl9kZWZpbmVUcmFuc3BvcnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBmYWN0b3J5LmNyZWF0ZUNvbm5lY3Rpb25NYW5hZ2VyKHRoaXMua2V5LCB7XG4gICAgICAgICAgICBnZXRTdHJhdGVneTogZ2V0U3RyYXRlZ3ksXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogdGhpcy5jb25maWcuYWN0aXZpdHlUaW1lb3V0LFxuICAgICAgICAgICAgcG9uZ1RpbWVvdXQ6IHRoaXMuY29uZmlnLnBvbmdUaW1lb3V0LFxuICAgICAgICAgICAgdW5hdmFpbGFibGVUaW1lb3V0OiB0aGlzLmNvbmZpZy51bmF2YWlsYWJsZVRpbWVvdXQsXG4gICAgICAgICAgICB1c2VUTFM6IEJvb2xlYW4odGhpcy5jb25maWcudXNlVExTKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5iaW5kKCdjb25uZWN0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZUFsbCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZWxpbmVTZW5kZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVsaW5lU2VuZGVyLnNlbmQodGhpcy5jb25uZWN0aW9uLmlzVXNpbmdUTFMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICAgICAgdmFyIGludGVybmFsID0gZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMDtcbiAgICAgICAgICAgIGlmIChldmVudC5jaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIuZW1pdChldmVudC5ldmVudCwgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnY29ubmVjdGluZycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Rpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHB1c2hlcl9QdXNoZXIuaW5zdGFuY2VzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IGluc3RhbmNlczogcHVzaGVyX1B1c2hlci5pbnN0YW5jZXMubGVuZ3RoIH0pO1xuICAgICAgICB0aGlzLnVzZXIgPSBuZXcgdXNlcl9Vc2VyRmFjYWRlKHRoaXMpO1xuICAgICAgICBpZiAocHVzaGVyX1B1c2hlci5pc1JlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFubmVsKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHMuZmluZChuYW1lKTtcbiAgICB9XG4gICAgYWxsQ2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzLmFsbCgpO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXNpbmdUTFMgPSB0aGlzLmNvbm5lY3Rpb24uaXNVc2luZ1RMUygpO1xuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZVNlbmRlciA9IHRoaXMudGltZWxpbmVTZW5kZXI7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlclRpbWVyID0gbmV3IHRpbWVyc19QZXJpb2RpY1RpbWVyKDYwMDAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsaW5lU2VuZGVyLnNlbmQodXNpbmdUTFMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXJUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci5iaW5kKGV2ZW50X25hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZChldmVudF9uYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmdsb2JhbF9lbWl0dGVyLnVuYmluZChldmVudF9uYW1lLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBiaW5kX2dsb2JhbChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdsb2JhbF9lbWl0dGVyLmJpbmRfZ2xvYmFsKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9nbG9iYWwoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci51bmJpbmRfZ2xvYmFsKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVuYmluZF9hbGwoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5nbG9iYWxfZW1pdHRlci51bmJpbmRfYWxsKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdWJzY3JpYmVBbGwoKSB7XG4gICAgICAgIHZhciBjaGFubmVsTmFtZTtcbiAgICAgICAgZm9yIChjaGFubmVsTmFtZSBpbiB0aGlzLmNoYW5uZWxzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVscy5jaGFubmVscy5oYXNPd25Qcm9wZXJ0eShjaGFubmVsTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZShjaGFubmVsTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlKGNoYW5uZWxfbmFtZSkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuYWRkKGNoYW5uZWxfbmFtZSwgdGhpcyk7XG4gICAgICAgIGlmIChjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiYgY2hhbm5lbC5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucmVpbnN0YXRlU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoYW5uZWwuc3Vic2NyaXB0aW9uUGVuZGluZyAmJlxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgY2hhbm5lbC5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUoY2hhbm5lbF9uYW1lKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKGNoYW5uZWxfbmFtZSk7XG4gICAgICAgIGlmIChjaGFubmVsICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uUGVuZGluZykge1xuICAgICAgICAgICAgY2hhbm5lbC5jYW5jZWxTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLnJlbW92ZShjaGFubmVsX25hbWUpO1xuICAgICAgICAgICAgaWYgKGNoYW5uZWwgJiYgY2hhbm5lbC5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRfZXZlbnQoZXZlbnRfbmFtZSwgZGF0YSwgY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRfZXZlbnQoZXZlbnRfbmFtZSwgZGF0YSwgY2hhbm5lbCk7XG4gICAgfVxuICAgIHNob3VsZFVzZVRMUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnVzZVRMUztcbiAgICB9XG4gICAgc2lnbmluKCkge1xuICAgICAgICB0aGlzLnVzZXIuc2lnbmluKCk7XG4gICAgfVxufVxucHVzaGVyX1B1c2hlci5pbnN0YW5jZXMgPSBbXTtcbnB1c2hlcl9QdXNoZXIuaXNSZWFkeSA9IGZhbHNlO1xucHVzaGVyX1B1c2hlci5sb2dUb0NvbnNvbGUgPSBmYWxzZTtcbnB1c2hlcl9QdXNoZXIuUnVudGltZSA9IHJ1bnRpbWU7XG5wdXNoZXJfUHVzaGVyLlNjcmlwdFJlY2VpdmVycyA9IHJ1bnRpbWUuU2NyaXB0UmVjZWl2ZXJzO1xucHVzaGVyX1B1c2hlci5EZXBlbmRlbmNpZXNSZWNlaXZlcnMgPSBydW50aW1lLkRlcGVuZGVuY2llc1JlY2VpdmVycztcbnB1c2hlcl9QdXNoZXIuYXV0aF9jYWxsYmFja3MgPSBydW50aW1lLmF1dGhfY2FsbGJhY2tzO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29yZV9wdXNoZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChwdXNoZXJfUHVzaGVyKTtcbmZ1bmN0aW9uIGNoZWNrQXBwS2V5KGtleSkge1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgJ1lvdSBtdXN0IHBhc3MgeW91ciBhcHAga2V5IHdoZW4geW91IGluc3RhbnRpYXRlIFB1c2hlci4nO1xuICAgIH1cbn1cbnJ1bnRpbWUuc2V0dXAocHVzaGVyX1B1c2hlcik7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pusher-js/dist/web/pusher.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CAdministrator%5CDesktop%5CRewards%5Cpages%5Cindex.js&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);